<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Capítulo 6 Introdução a base de dados relacionais no R | Introdução à Linguagem R: seus fundamentos e sua prática</title>
<meta name="author" content="Pedro Faria">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.2"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.9/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.2.5.1/tabs.js"></script><script src="libs/bs3compat-0.2.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/mark.min.js"></script><!-- CSS -->
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Introdução à Linguagem R: seus fundamentos e sua prática</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Bem vindo!</a></li>
<li><a class="" href="sobre-os-autores.html">Sobre os autores</a></li>
<li><a class="" href="pref%C3%A1cio.html">Prefácio</a></li>
<li><a class="" href="no%C3%A7%C3%B5es-b%C3%A1sicas-do-r.html"><span class="header-section-number">1</span> Noções Básicas do R</a></li>
<li><a class="" href="fundamentos-da-linguagem-r.html"><span class="header-section-number">2</span> Fundamentos da Linguagem R</a></li>
<li><a class="" href="importando-e-exportando-dados-com-o-r.html"><span class="header-section-number">3</span> Importando e exportando dados com o R</a></li>
<li><a class="" href="transformando-dados-com-dplyr.html"><span class="header-section-number">4</span> Transformando dados com dplyr</a></li>
<li><a class="" href="fun%C3%A7%C3%B5es-e-loops-no-r.html"><span class="header-section-number">5</span> Funções e Loops no R</a></li>
<li><a class="active" href="introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-no-r.html"><span class="header-section-number">6</span> Introdução a base de dados relacionais no R</a></li>
<li><a class="" href="tidy-data-uma-abordagem-para-organizar-os-seus-dados.html"><span class="header-section-number">7</span> Tidy Data: Uma abordagem para organizar os seus dados</a></li>
<li><a class="" href="visualiza%C3%A7%C3%A3o-de-dados-com-ggplot2.html"><span class="header-section-number">8</span> Visualização de dados com ggplot2</a></li>
<li><a class="" href="configurando-componentes-est%C3%A9ticos-do-gr%C3%A1fico-no-ggplot2.html"><span class="header-section-number">9</span> Configurando componentes estéticos do gráfico no ggplot2</a></li>
<li><a class="" href="manipula%C3%A7%C3%A3o-e-transforma%C3%A7%C3%A3o-de-strings-com-stringr.html"><span class="header-section-number">10</span> Manipulação e transformação de strings com stringr</a></li>
<li><a class="" href="introduzindo-fatores-factors-com-forcats.html"><span class="header-section-number">11</span> Introduzindo fatores (factor’s) com forcats</a></li>
<li><a class="" href="introdu%C3%A7%C3%A3o-%C3%A0-vari%C3%A1veis-de-tempo-com-lubridate.html"><span class="header-section-number">12</span> Introdução à variáveis de tempo com lubridate</a></li>
<li><a class="" href="pnad-cont%C3%ADnua-arquivo-csv-para-input.html"><span class="header-section-number">13</span> PNAD Contínua: arquivo CSV para input</a></li>
<li><a class="" href="refer%C3%AAncias.html">Referências</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/pedropark99/Introducao_R/">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="introdução-a-base-de-dados-relacionais-no-r" class="section level1" number="6">
<h1>
<span class="header-section-number">Capítulo 6</span> Introdução a base de dados relacionais no R<a class="anchor" aria-label="anchor" href="#introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-no-r"><i class="fas fa-link"></i></a>
</h1>
<div id="introdução-e-pré-requisitos-1" class="section level2" number="6.1">
<h2>
<span class="header-section-number">6.1</span> Introdução e pré-requisitos<a class="anchor" aria-label="anchor" href="#introdu%C3%A7%C3%A3o-e-pr%C3%A9-requisitos-1"><i class="fas fa-link"></i></a>
</h2>
<p>Segundo <span class="citation"><a href="refer%C3%AAncias.html#ref-nield2016" role="doc-biblioref">Nield</a> (<a href="refer%C3%AAncias.html#ref-nield2016" role="doc-biblioref">2016</a>, p 53)</span>, <em>joins</em> são uma das funcionalidades que definem a linguagem SQL (<em>Structured Query Language</em>). Por isso, <em>joins</em> são um tipo de operação muito relacionado à RDBMS (<em>Relational DataBase Management Systems</em>), que em sua maioria, utilizam a linguagem SQL. Logo, essa seção será muito familiar para aqueles que possuem experiência com essa linguagem.</p>
<p>Para executarmos uma operação de <em>join</em>, os pacotes básicos do R oferecem a função <code><a href="https://rdrr.io/r/base/merge.html">merge()</a></code>. Entretanto, vamos abordar o pacote <code>dplyr</code> neste capítulo, que também possui funções especializadas neste tipo de operação. Com isso, para ter acesso às funções que vamos mostrar aqui, você pode chamar tanto pelo pacote <code>dplyr</code> quanto pelo <code>tidyverse</code>.</p>
<p></p>
<div class="sourceCode" id="cb619"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org">dplyr</a></span><span class="op">)</span></code></pre></div>
<p></p>
</div>
<div id="sec:relational_data_keys" class="section level2" number="6.2">
<h2>
<span class="header-section-number">6.2</span> Dados relacionais e o conceito de <em>key</em><a class="anchor" aria-label="anchor" href="#sec:relational_data_keys"><i class="fas fa-link"></i></a>
</h2>
<p>Normalmente, trabalhamos com diversas bases de dados diferentes ao mesmo tempo. Pois é muito incomum, que uma única tabela contenha todas as informações das quais necessitamos e, por isso, transportar os dados de uma tabela para outra se torna uma atividade essencial em muitas ocasiões.</p>
<p>Logo, de alguma maneira, os dados presentes nessas diversas tabelas se relacionam entre si. Por exemplo, suponha que você possua uma tabela contendo o PIB dos municípios do estado de Minas Gerais, e uma outra tabela contendo dados demográficos desses mesmos municípios. Se você deseja unir essas duas tabelas em uma só, você precisa de algum mecanismo que possa conectar um valor do município X na tabela A com a linha da tabela B correspondente ao mesmo município X, e através dessa conexão, conduzir o valor da tabela A para esse local específico da tabela B, ou vice-versa. O processo que realiza esse cruzamento entre as informações, e que por fim, mescla ou funde as duas tabelas de acordo com essas conexões, é chamado de <em>join</em>.</p>
<p>Por isso, dizemos que os nossos dados são “relacionais.” Pelo fato de que nós possuímos diversas tabelas que descrevem os mesmos indivíduos, municípios, firmas ou eventos. Mesmo que essas tabelas estejam trazendo variáveis ou informações muito diferentes desses indivíduos, elas possuem essa característica em comum e, com isso, possuem uma relação entre si, e vamos frequentemente nos aproveitar dessa relação para executarmos análises mais completas.</p>
<p>Porém, para transportarmos esses dados de uma tabela a outra, precisamos de alguma chave, ou de algum mecanismo que seja capaz de identificar as relações entre as duas tabelas. Em outras palavras, se temos na tabela A, um valor pertencente ao indivíduo X, e queremos transportar esse valor para a tabela B, nós precisamos de algum meio que possa identificar o local da tabela B que seja referente ao indivíduo X. O mecanismo que permite essa comparação, é o que chamamos de <em>key</em> ou de “chave.”</p>
<p></p>
<div class="sourceCode" id="cb620"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"1943-07-26"</span>, <span class="st">"1940-09-10"</span>, <span class="st">"1942-06-18"</span>, <span class="st">"1943-02-25"</span>, <span class="st">"1940-07-07"</span><span class="op">)</span>

<span class="va">info</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span>
  name <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Mick"</span>, <span class="st">"John"</span>, <span class="st">"Paul"</span>, <span class="st">"George"</span>, <span class="st">"Ringo"</span><span class="op">)</span>,
  band <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Rolling Stones"</span>, <span class="st">"Beatles"</span>, <span class="st">"Beatles"</span>, <span class="st">"Beatles"</span>, <span class="st">"Beatles"</span><span class="op">)</span>,
  born <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html">as.Date</a></span><span class="op">(</span><span class="va">d</span><span class="op">)</span>,
  children <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span>
<span class="op">)</span>

<span class="va">band_instruments</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span>
  name <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"John"</span>, <span class="st">"Paul"</span>, <span class="st">"Keith"</span><span class="op">)</span>,
  plays <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"guitar"</span>, <span class="st">"bass"</span>, <span class="st">"guitar"</span><span class="op">)</span>
<span class="op">)</span></code></pre></div>
<p></p>
<p>Como exemplo inicial, vamos utilizar a tabela <code>info</code>, que descreve características pessoais de um conjunto de músicos famosos. Também temos a tabela <code>band_instruments</code>, que apenas indica qual o instrumento musical utilizado por parte dos músicos descritos na tabela <code>info</code>.</p>
<p></p>
<div class="sourceCode" id="cb621"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">info</span></code></pre></div>
<pre><code>## # A tibble: 5 x 4
##   name   band           born       children
##   &lt;chr&gt;  &lt;chr&gt;          &lt;date&gt;     &lt;lgl&gt;   
## 1 Mick   Rolling Stones 1943-07-26 TRUE    
## 2 John   Beatles        1940-09-10 TRUE    
## 3 Paul   Beatles        1942-06-18 TRUE    
## 4 George Beatles        1943-02-25 TRUE    
## 5 Ringo  Beatles        1940-07-07 TRUE</code></pre>
<div class="sourceCode" id="cb623"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">band_instruments</span></code></pre></div>
<pre><code>## # A tibble: 3 x 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Keith guitar</code></pre>
<p></p>
<p>Portanto, precisamos de uma <em>key</em> para detectarmos as relações entre as tabelas <code>info</code> e <code>band_instruments</code>. Uma <em>key</em> conciste em uma variável (ou um conjunto de variáveis), que é capaz de identificar unicamente cada indivíduo descrito em uma tabela, sendo que essa variável (ou esse conjunto de variáveis), deve obrigatoriamente estar presente em ambas as tabelas em que desejamos aplicar o <em>join</em>. Dessa forma, podemos através dessa variável, discenir quais indivíduos estão presentes nas duas tabelas, e quais se encontram em apenas uma delas.</p>
<p>Ao observar as tabelas <code>info</code> e <code>band_instruments</code>, você talvez perceba que ambas possuem uma coluna denominada <code>name</code>. No nosso caso, essa é a coluna que representa a <em>key</em> entre as tabelas <code>info</code> e <code>band_instruments</code>. Logo, ao identificar o músico que está sendo tratado em cada linha, a coluna <code>name</code> nos permite cruzar as informações existentes em ambas tabelas. Com isso, podemos observar que os músicos John e Paul, estão disponíveis em ambas as tabelas, mas os músicos Mick, George e Ringo estão descritos apenas na tabela <code>info</code>, enquanto o músico Keith se encontra apenas na tabela <code>band_instruments</code>.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-360"></span>
<img src="Figuras/keys_comparacao.png" alt="Cruzamento entre as tabelas de acordo com a coluna name"><p class="caption">
Figure 6.1: Cruzamento entre as tabelas de acordo com a coluna name
</p>
</div>
<p></p>
<p>Segundo <span class="citation"><a href="refer%C3%AAncias.html#ref-nield2016" role="doc-biblioref">Nield</a> (<a href="refer%C3%AAncias.html#ref-nield2016" role="doc-biblioref">2016</a>)</span>, podemos ter dois tipos de <em>keys</em> existentes em uma tabela:</p>
<ol style="list-style-type: decimal">
<li><p><em>Primary key</em>: uma variável capaz de identificar unicamente cada uma das observações presentes em sua tabela.</p></li>
<li><p><em>Foreign key</em>: uma variável capaz de identificar unicamente cada uma das observações presentes em uma outra tabela.</p></li>
</ol>
<p>Com essas características em mente, podemos afirmar que a coluna <code>name</code> existente nas tabelas <code>info</code> e <code>band_instruments</code>, se trata de uma <em>primary key</em>. Pois em ambas as tabelas, mais especificamente em cada linha dessa coluna, temos um músico diferente, ou em outras palavras, não há um músico duplicado.</p>
<p>Por outro lado, uma <em>foreign key</em> normalmente contém valores repetidos ao longo da base e, por essa razão, não são capazes de identificar unicamente uma observação na tabela em que se encontram. Porém, os valores de uma <em>foreign key</em> certamente fazem referência a uma <em>primary key</em> existente em uma outra tabela. Tendo isso em mente, o objetivo de uma <em>foreign key</em> não é o de identificar cada observação presente em uma tabela, mas sim, de indicar ou explicitar a relação que a sua tabela possui com a <em>primary key</em> presente em uma outra tabela.</p>
<p>Por exemplo, suponha que eu tenha a tabela <code>children</code> abaixo. Essa tabela descreve os filhos de alguns músicos famosos, e a coluna <code>father</code> caracteriza-se como a <em>foreign key</em> dessa tabela. Não apenas porque os valores da coluna <code>father</code> se repetem ao longo da base, mas também, porque essa coluna pode ser claramente cruzada com a coluna <code>name</code> pertencente às tabelas <code>info</code> e <code>band_instruments</code>.</p>
<p></p>
<div class="sourceCode" id="cb625"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">children</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span>
  child <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Stella"</span>, <span class="st">"Beatrice"</span>, <span class="st">"James"</span>, <span class="st">"Mary"</span>,
            <span class="st">"Heather"</span>, <span class="st">"Sean"</span>, <span class="st">"Julian"</span>, <span class="st">"Zak"</span>,
            <span class="st">"Lee"</span>, <span class="st">"Jason"</span>, <span class="st">"Dhani"</span><span class="op">)</span>,
  sex <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"F"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"M"</span><span class="op">)</span>,
  father <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="st">"Paul"</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>, <span class="st">"John"</span>, <span class="st">"John"</span>,
             <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="st">"Ringo"</span>, times <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>, <span class="st">"Harrison"</span><span class="op">)</span>
<span class="op">)</span>

<span class="va">children</span></code></pre></div>
<pre><code>## # A tibble: 11 x 3
##    child    sex   father  
##    &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;   
##  1 Stella   F     Paul    
##  2 Beatrice F     Paul    
##  3 James    M     Paul    
##  4 Mary     F     Paul    
##  5 Heather  F     Paul    
##  6 Sean     M     John    
##  7 Julian   M     John    
##  8 Zak      M     Ringo   
##  9 Lee      F     Ringo   
## 10 Jason    M     Ringo   
## 11 Dhani    M     Harrison</code></pre>
<p></p>
</div>
<div id="introduzindo-joins" class="section level2" number="6.3">
<h2>
<span class="header-section-number">6.3</span> Introduzindo <em>joins</em><a class="anchor" aria-label="anchor" href="#introduzindo-joins"><i class="fas fa-link"></i></a>
</h2>
<p>Tendo esses pontos em mente, o pacote <code>dplyr</code> nos oferece quatro funções voltadas para operações de <em>join</em>. Cada uma dessas funções executam um tipo de <em>join</em> diferente, que vamos comentar na próxima seção. Por agora, vamos focar apenas na função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join()</a></code>, que como o seu próprio nome dá a entender, busca aplicar um <em>inner join</em>.</p>
<p>Para utilizar essa função, precisamos nos preocupar com três argumentos principais. Os dois primeiros argumentos (<code>x</code> e <code>y</code>), definem os <code>data.frame</code>’s a serem fundidos pela função. Já no terceiro argumento (<code>by</code>), você deve delimitar a coluna, ou o conjunto de colunas que representam a <em>key</em> entre as tabelas fornecidas em <code>x</code> e <code>y</code>.</p>
<p>Assim como em qualquer outro tipo de <em>join</em>, as duas tabelas envolvidas serão unidas, porém, em um <em>inner join</em>, apenas as linhas de indivíduos que se encontram em ambas as tabelas serão retornadas na nova tabela gerada. Perceba abaixo, que a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join()</a></code> criou uma nova tabela contendo todas as colunas presentes nas tabelas <code>info</code> e <code>band_instruments</code> como esperávamos, e que ela manteve apenas as linhas referentes aos músicos John e Paul, que são os únicos indivíduos que aparecem em ambas as tabelas.</p>
<p></p>
<div class="sourceCode" id="cb627"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join</a></span><span class="op">(</span><span class="va">info</span>, <span class="va">band_instruments</span>, by <span class="op">=</span> <span class="st">"name"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 5
##   name  band    born       children plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;date&gt;     &lt;lgl&gt;    &lt;chr&gt; 
## 1 John  Beatles 1940-09-10 TRUE     guitar
## 2 Paul  Beatles 1942-06-18 TRUE     bass</code></pre>
<p></p>
<p></p>
<div class="sourceCode" id="cb629"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## -----------------------------------------------</span>
<span class="co">## A mesma operação com o uso do pipe ( %&gt;% ):</span>
<span class="va">info</span> <span class="op">%&gt;%</span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join</a></span><span class="op">(</span><span class="va">band_instruments</span>, by <span class="op">=</span> <span class="st">"name"</span><span class="op">)</span></code></pre></div>
<p></p>
<p>Ao observar esse resultado, você talvez chegue a conclusão de que um processo de <em>join</em> se trata do mesmo processo executado pela função <code>PROCV()</code> do Excel. Essa é uma ótima comparação! Pois a função <code>PROCV()</code> realiza justamente um <em>join</em> parcial, ao trazer para a tabela A, uma coluna pertencente a tabela B, de acordo com uma <em>key</em> que conecta as duas tabelas.</p>
<p>Por outro lado, nós não podemos afirmar que a função <code>PROCV()</code> busca construir um <em>join per se</em>. Pois um <em>join</em> conciste em um processo de união, em que estamos literalmente fundindo duas tabelas em uma só. Já a função <code>PROCV()</code>, é capaz de transportar apenas uma única coluna por tabela, logo, não é de sua filosofia, fundir as tabelas envolvidas. Por isso, se temos cinco colunas em uma tabela A, as quais desejamos levar até a tabela B, nós precisamos de cinco <code>PROCV()</code>’s diferentes no Excel, enquanto no R, precisamos de apenas um <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join()</a></code> para realizarmos tal ação.</p>
<p>Por último, vale destacar uma característica muito importante de um <em>join</em>, que é o seu processo de pareamento. Devido a essa característica, a ordem da linhas presentes em ambas as tabelas se torna irrelevante para o resultado. Por exemplo, veja na figura 6.2, um exemplo de <em>join</em>, onde a coluna <code>ID</code> representa a <em>key</em> entre as duas tabelas. Repare que as linhas na tabela à esquerda que se referem, por exemplo, aos indivíduos de ID 105, 107 e 108, se encontram em linhas diferentes na tabela à direita. Mesmo que esses indivíduos estejam em locais diferentes, a função responsável pelo <em>join</em>, vai realizar um pareamento entre as duas tabelas, antes de fundí-las. Dessa maneira, podemos nos certificar que as informações de cada indivíduo são corretamente posicionadas na tabela resultante.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-364"></span>
<img src="Figuras/pareamento1.png" alt="Representação de um join entre duas tabelas"><p class="caption">
Figure 6.2: Representação de um join entre duas tabelas
</p>
</div>
<p></p>
</div>
<div id="sec:config_colunas_keys" class="section level2" number="6.4">
<h2>
<span class="header-section-number">6.4</span> Configurações sobre as colunas e <em>keys</em> utilizadas no <em>join</em><a class="anchor" aria-label="anchor" href="#sec:config_colunas_keys"><i class="fas fa-link"></i></a>
</h2>
<p>Haverá momentos em que uma única coluna não será o bastante para identificarmos cada observação de nossa base. Por isso, teremos oportunidades em que devemos utilizar a combinação entre várias colunas, com o objetivo de formarmos uma <em>primary key</em> em nossa tabela.</p>
<p>Por exemplo, suponha que você trabalha diariamente com o registro de entradas no estoque de um supermercado. Imagine que você possua a tabela <code>registro</code> abaixo, que contém dados da seção de bebidas do estoque, e que apresentam o <code>dia</code> e <code>mes</code> em que uma determinada carga chegou ao estoque da empresa, além de uma descrição de seu conteúdo (<code>descricao</code>), seu valor de compra (<code>valor</code>) e as unidades inclusas (<code>unidades</code>).</p>
<p></p>
<div class="sourceCode" id="cb630"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">registro</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span>
  dia <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">18</span>, <span class="fl">18</span>, <span class="fl">25</span>, <span class="fl">25</span><span class="op">)</span>,
  mes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span>,
  ano <span class="op">=</span> <span class="fl">2020</span>,
  unidades <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">410</span>, <span class="fl">325</span>, <span class="fl">325</span>, <span class="fl">400</span>, <span class="fl">50</span><span class="op">)</span>,
  valor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">450</span>, <span class="fl">1400</span>, <span class="fl">1150</span>, <span class="fl">670</span>, <span class="fl">2490</span><span class="op">)</span>,
  descricao <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Fanta Laranja 350ml"</span>, 
                <span class="st">"Coca Cola 2L"</span>, <span class="st">"Mate Couro 2L"</span>,
                <span class="st">"Kapo Uva 200ml"</span>, <span class="st">"Absolut Vodka 1L"</span><span class="op">)</span>
<span class="op">)</span>

<span class="va">registro</span></code></pre></div>
<pre><code>## # A tibble: 5 x 6
##     dia   mes   ano unidades valor descricao          
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;              
## 1     3     2  2020      410   450 Fanta Laranja 350ml
## 2    18     2  2020      325  1400 Coca Cola 2L       
## 3    18     2  2020      325  1150 Mate Couro 2L      
## 4    25     2  2020      400   670 Kapo Uva 200ml     
## 5    25     3  2020       50  2490 Absolut Vodka 1L</code></pre>
<p></p>
<p>Nessa tabela, as colunas <code>dia</code>, <code>mes</code>, <code>ano</code>, <code>valor</code>, <code>unidades</code> e <code>descricao</code>, sozinhas, são insuficientes para identificarmos cada carga registrada na tabela. Mesmo que, <strong>atualmente</strong>, cada valor presente na coluna <code>descricao</code> seja único, essa característica provavelmente não vai resistir por muito tempo. Pois o supermercado pode muito bem receber amanhã, por exemplo, uma outra carga de refrigerantes de 2 litros da Mate Couro.</p>
<p>Por outro lado, a combinação dos valores presentes nas colunas <code>dia</code>, <code>mes</code>, <code>ano</code>, <code>valor</code>, <code>unidades</code> e <code>descricao</code>, pode ser o suficiente para criarmos um código de identificação único para cada carga. Por exemplo, ao voltarmos à tabela <code>registro</code>, podemos encontrar duas cargas que chegaram no mesmo dia 18, no mesmo mês 2, no mesmo ano de 2020, e trazendo as mesmas 325 unidades. Todavia, essas duas cargas, possuem descrições diferentes: uma delas incluía garrafas preenchidas com Coca Cola, enquanto a outra, continha Mate Couro. Concluindo, ao aliarmos as informações referentes a data de entrada (18/02/2020), as quantidades inclusas nas cargas (325 unidades), e as suas descrições (Coca Cola 2L e Mate Couro 2L), podemos enfim diferenciar essas duas cargas:</p>
<ol style="list-style-type: decimal">
<li><p>Uma carga que entrou no dia 18/02/2020, incluía 325 unidades de 2 litros de Coca Cola.</p></li>
<li><p>Uma carga que entrou no dia 18/02/2020, incluía 325 unidades de 2 litros de Mate Couro.</p></li>
</ol>
<p>Como um outro exemplo, podemos utilizar as bases <code>flights</code> e <code>weather</code>, provenientes do pacote <code>nycflights13</code>. Perceba abaixo, que a base <code>flights</code> já possui um número grande colunas. Essa tabela apresenta dados diários, referentes a diversos voôs que partiram da cidade de Nova York (EUA) durante o ano de 2013. Já a tabela <code>weather</code>, contém dados meteorológicos em uma dada hora, e em diversas datas do mesmo ano, e que foram especificamente coletados nos aeroportos da mesma cidade de Nova York.</p>
<p></p>
<div class="sourceCode" id="cb632"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/hadley/nycflights13">nycflights13</a></span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb633"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">flights</span></code></pre></div>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;dbl&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;dbl&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<div class="sourceCode" id="cb635"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">weather</span></code></pre></div>
<pre><code>## # A tibble: 26,115 x 15
##    origin  year month   day  hour  temp  dewp humid wind_dir wind_speed
##    &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;
##  1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 
##  2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06
##  3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 
##  4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 
##  5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 
##  6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 
##  7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 
##  8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 
##  9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 
## 10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 
## # ... with 26,105 more rows, and 5 more variables: wind_gust &lt;dbl&gt;,
## #   precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p></p>
<p>Ao aplicarmos um <em>join</em> entre essas tabelas, poderíamos analisar as características meterológicas que um determinado avião enfrentou ao levantar voô. Entretanto, necessitaríamos empregar ao menos cinco colunas diferentes para formarmos uma <em>key</em> adequada entre essas tabelas. Pois cada situação meterológica descrita na tabela <code>weather</code>, ocorre em um uma dada localidade, e em um horário específico de um determinado dia. Com isso, teríamos de utilizar as colunas: <code>year</code>, <code>month</code> e <code>day</code> para identificarmos a data correspondente a cada situação; mais a coluna <code>hour</code> para determinarmos o momento do dia em que essa situação ocorreu; além da coluna <code>origin</code>, que marca o aeroporto de onde cada voô partiu e, portanto, nos fornece uma localização no espaço geográfico para cada situação meteorológica.</p>
<p>Portanto, em todos os momentos em que você precisar utilizar um conjunto de colunas para formar uma <em>key</em>, como o caso das tabelas <code>weather</code> e <code>flights</code> acima, você deve fornecer um vetor contendo o nome dessas colunas para o argumento <code>by</code> da função de <em>join</em> que está utilizando, assim como no exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb637"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join</a></span><span class="op">(</span>
  <span class="va">flights</span>,
  <span class="va">weather</span>,
  by <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"year"</span>, <span class="st">"month"</span>, <span class="st">"day"</span>, <span class="st">"hour"</span>, <span class="st">"origin"</span><span class="op">)</span>
<span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 335,220 x 29
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 335,210 more rows, and 22 more variables: sched_arr_time &lt;dbl&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;dbl&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour.x &lt;dttm&gt;, temp &lt;dbl&gt;, dewp &lt;dbl&gt;, humid &lt;dbl&gt;,
## #   wind_dir &lt;dbl&gt;, wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;,
## #   pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour.y &lt;dttm&gt;</code></pre>
<p></p>
<p>Porém, a tabela <code>flights</code> já possui um número muito grande colunas e, por essa razão, não conseguimos visualizar no resultado do <em>join</em>, as diversas colunas importadas da tabela <code>weather</code>. Sabemos que um <em>join</em> gera, por padrão, uma nova tabela contendo todas as colunas de ambas as tabelas utilizadas. Contudo, o exemplo acima demonstra que em certas ocasiões, o uso de muitas colunas pode sobrecarregar a sua visão e, com isso, dificultar o seu foco no que é de fato importante em sua análise.</p>
<p>Tendo isso em mente, haverá instantes em que você deseja trazer apenas algumas colunas de uma das tabelas envolvidas no <em>join</em>. Mas não há como alterarmos a natureza de um <em>join</em>, logo, todas as colunas de ambas as colunas serão sempre incluídas em seu resultado. Por isso, o ideal é que você selecione as colunas desejadas de uma das tabelas antes de empregá-las em um <em>join</em>.</p>
<p>Ou seja, ao invés de fornecer a tabela completa à função, você pode utilizar ferramentas como <code><a href="https://dplyr.tidyverse.org/reference/select.html">select()</a></code> ou <em>subsetting</em>, para extrair a parte desejada de uma das tabelas, e fornecer o resultado dessa seleção para a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join()</a></code>. Entretanto, . De outra forma, não se esqueça de incluir em sua seleção, as colunas que você proveu ao argumento <code>by</code>.</p>
<p>Por exemplo, supondo que você precisasse em seu resultado apenas das colunas <code>dep_time</code> e <code>dep_delay</code> da tabela <code>flights</code>, você poderia fornecer os comandos a seguir:</p>
<p></p>
<div class="sourceCode" id="cb639"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">cols_para_key</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>
  <span class="st">"year"</span>, <span class="co"># Coluna 1 para key</span>
  <span class="st">"month"</span>, <span class="co"># Coluna 2 para key </span>
  <span class="st">"day"</span>, <span class="co"># Coluna 3 para key</span>
  <span class="st">"hour"</span>, <span class="co"># Coluna 4 para key</span>
  <span class="st">"origin"</span> <span class="co"># Coluna 5 para key</span>
<span class="op">)</span>

<span class="va">cols_desejadas</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"dep_time"</span>, <span class="st">"dep_delay"</span><span class="op">)</span>

<span class="va">cols_c</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">cols_para_key</span>, <span class="va">cols_desejadas</span><span class="op">)</span>

<span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join</a></span><span class="op">(</span>
  <span class="va">flights</span> <span class="op">%&gt;%</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html">select</a></span><span class="op">(</span><span class="fu"><a href="https://tidyselect.r-lib.org/reference/all_of.html">all_of</a></span><span class="op">(</span><span class="va">cols_c</span><span class="op">)</span><span class="op">)</span>,
  <span class="va">weather</span>,
  by <span class="op">=</span> <span class="va">cols_para_key</span>
<span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 335,220 x 17
##     year month   day  hour origin dep_time dep_delay  temp  dewp humid
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  2013     1     1     5 EWR         517         2  39.0  28.0  64.4
##  2  2013     1     1     5 LGA         533         4  39.9  25.0  54.8
##  3  2013     1     1     5 JFK         542         2  39.0  27.0  61.6
##  4  2013     1     1     5 JFK         544        -1  39.0  27.0  61.6
##  5  2013     1     1     6 LGA         554        -6  39.9  25.0  54.8
##  6  2013     1     1     5 EWR         554        -4  39.0  28.0  64.4
##  7  2013     1     1     6 EWR         555        -5  37.9  28.0  67.2
##  8  2013     1     1     6 LGA         557        -3  39.9  25.0  54.8
##  9  2013     1     1     6 JFK         557        -3  37.9  27.0  64.3
## 10  2013     1     1     6 LGA         558        -2  39.9  25.0  54.8
## # ... with 335,210 more rows, and 7 more variables: wind_dir &lt;dbl&gt;,
## #   wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;,
## #   visib &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p></p>
<p></p>
<div class="sourceCode" id="cb641"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## ----------------------------------------</span>
<span class="co">## Ou por subsetting:</span>
<span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join</a></span><span class="op">(</span>
  <span class="va">flights</span><span class="op">[</span> , <span class="va">cols_c</span><span class="op">]</span>,
  <span class="va">weather</span>,
  by <span class="op">=</span> <span class="va">cols_para_key</span>
<span class="op">)</span></code></pre></div>
<p></p>
<p>Antes de partirmos para a próxima seção, vale a pena comentar sobre um outro aspecto importante em um <em>join</em>. As colunas que formam a sua <em>key</em> <strong>devem estar nomeadas da mesma maneira em ambas as tabelas</strong>. Por exemplo, se nós voltarmos às tabelas <code>info</code> e <code>band_instruments</code>, e renomearmos a coluna <code>name</code> para <code>member</code> em uma das tabelas, um erro será levantado ao tentarmos aplicar novamente um <em>join</em> sobre as tabelas.</p>
<p></p>
<div class="sourceCode" id="cb642"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">band_instruments</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"member"</span>

<span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join</a></span><span class="op">(</span><span class="va">info</span>, <span class="va">band_instruments</span>, by <span class="op">=</span> <span class="st">"name"</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>Erro: Join columns must be present in data.
x Problem with `name`.
Run `rlang::last_error()` to see where the error occurred.</code></pre>
<p>Logo, ajustes são necessários sobre o argumento <code>by</code>, de forma a revelarmos para a função reponsável pelo <em>join</em>, a existência dessa diferença existente entre os nomes dados às colunas que representam a <em>key</em> entre as tabelas. Fazendo uso dos argumentos <code>x</code> e <code>y</code> como referências, para realizar esse ajuste, você deve igualar o nome dado à coluna da tabela <code>x</code> ao nome dado à coluna correspondente na tabela <code>y</code>, dentro de um vetor - <code><a href="https://rdrr.io/r/base/c.html">c()</a></code>, como está demonstrado abaixo.</p>
<p></p>
<div class="sourceCode" id="cb644"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join</a></span><span class="op">(</span><span class="va">info</span>, <span class="va">band_instruments</span>, by <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"name"</span> <span class="op">=</span> <span class="st">"member"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 5
##   name  band    born       children plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;date&gt;     &lt;lgl&gt;    &lt;chr&gt; 
## 1 John  Beatles 1940-09-10 TRUE     guitar
## 2 Paul  Beatles 1942-06-18 TRUE     bass</code></pre>
<p></p>
</div>
<div id="diferentes-tipos-de-join" class="section level2" number="6.5">
<h2>
<span class="header-section-number">6.5</span> Diferentes tipos de <em>join</em><a class="anchor" aria-label="anchor" href="#diferentes-tipos-de-join"><i class="fas fa-link"></i></a>
</h2>
<p>Portanto, um <em>join</em> busca construir uma união entre duas tabelas. Porém, podemos realizar essa união de diferentes formas, e até o momento, apresentei apenas uma de suas formas, o <em>inner join</em>, que é executado pela função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join()</a></code>. Nesse método, o <em>join</em> mantém apenas as linhas que puderam ser encontradas em ambas as tabelas. Logo, se um indivíduo está presente na tabela A, mas não se encontra na tabela B, esse indivíduo será descartado em um <em>inner join</em> entre as tabelas A e B. Como foi destacado por <span class="citation"><a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">Wickham and Grolemund</a> (<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">2017</a>, p 181)</span>, essa característica torna o <em>inner join</em> pouco apropriado para a maioria das análises, pois uma importante perda de observações pode ser facilmente gerada neste processo.</p>
<p>Com isso, nós podemos empregar tipos diferentes de <em>joins</em>, que são comumente chamados de <em>outer joins</em>, pois esses tipos buscam preservar as linhas de pelo menos uma das tabelas envolvidas no <em>join</em> em questão. Sendo eles:</p>
<ol style="list-style-type: decimal">
<li><p><code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join()</a></code>: mantém todas as linhas da tabela definida no argumento <code>x</code>, ou a tabela à esquerda do <em>join</em>, mesmo que os indivíduos descritos nessa tabela não tenham sido encontrados em ambas as tabelas.</p></li>
<li><p><code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">right_join()</a></code>: mantém todas as linhas da tabela definida no argumento <code>y</code>, ou a tabela à direita do <em>join</em>, mesmo que os indivíduos descritos nessa tabela não tenham sido encontrados em ambas as tabelas.</p></li>
<li><p><code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join()</a></code>: mantém todas as linhas de ambas as tabelas definidas nos argumentos <code>x</code> e <code>y</code>, mesmo que os indivíduos de uma dessas tabelas não tenham sido encontrados em ambas as tabelas.</p></li>
</ol>
<p>Em todas as funções de <em>join</em> mostradas aqui, o primeiro argumento é chamado de <code>x</code>, e o segundo, de <code>y</code>, sendo esses os argumentos que definem as duas tabelas a serem utilizadas no <em>join</em>. Simplificadamente, a diferença entre <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join()</a></code>, <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">right_join()</a></code> e <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join()</a></code> reside apenas em quais linhas das tabelas utilizadas, são conservadas por essas funções no produto final do <em>join</em>. Como essas diferenças são simples, as descrições acima já lhe dão uma boa ideia de quais serão as linhas conservadas em cada função. Todavia, darei a seguir, uma visão mais formal desses comportamentos, com o objetivo principal de fornecer uma segunda visão que pode, principalmente, facilitar a sua memorização do que cada função faz.</p>
<p>Para seguir esse caminho, é interessante que você tente interpretar um <em>join</em> a partir de uma perspectiva mais geral ou menos minuciosa do processo. Ao aplicarmos um <em>join</em> entre as tabelas A e B, estamos resumidamente, extraindo as colunas da tabela B e as adicionando à tabela A (ou vice-versa). Com isso, temos nessa concepção, a <strong>tabela fonte</strong>, ou a tabela <strong>de onde</strong> as colunas são retiradas, e a <strong>tabela destinatária</strong>, ou a tabela <strong>para onde</strong> essas colunas são levadas. Portanto, segundo esse ponto de vista, o <em>join</em> possui sentido e direção, assim como um vetor em um espaço tridimensional. Pois o processo sempre parte da tabela fonte em direção a tabela destinatária. Dessa forma, em um <em>join</em>, ao construírmos uma nova tabela que representa a união entre duas tabelas, estamos basicamente extraindo as colunas da tabela fonte e as incorporando à tabela destinatária.</p>
<p>Com isso, eu quero criar a perspectiva, de que a tabela fonte e a tabela destinatária, ocupam lados do <em>join</em>, como na figura 6.3. Ou seja, por esse ângulo, estamos compreendendo o <em>join</em> como uma operação que ocorre sempre da direita para esquerda, ou um processo em que estamos sempre carregando um conjunto de colunas da tabela à direita em direção a tabela à esquerda. Se mesclarmos essa visão, com as primeiras descrições dos <em>outer joins</em> que fornecemos, temos que o argumento <code>x</code> corresponde a tabela destinatária, e o argumento <code>y</code>, a tabela fonte. Dessa maneira, a tabela destinatária (ou o argumento <code>x</code>) é sempre a tabela que ocupa o lado esquerdo do <em>join</em>, enquanto a tabela fonte (ou o argumento <code>y</code>) sempre se trata da tabela que ocupa o lado direito da operação.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-376"></span>
<img src="Figuras/direita_esquerda.png" alt="As tabelas ocupam lados em um join"><p class="caption">
Figure 6.3: As tabelas ocupam lados em um join
</p>
</div>
<p></p>
<p>Logo, a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join()</a></code> busca manter as linhas da tabela destinatária (ou a tabela que você definiu no argumento <code>x</code> da função) intactas no resultado do <em>join</em>. Isso significa, que caso a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join()</a></code> não encontre na tabela fonte, uma linha que corresponde a um certo indivíduo presente na tabela destinatária, essa linha será mantida no resultado final do <em>join</em>. Porém, como está demonstrado abaixo, em todas as situações em que a função não pôde encontrar esse indivíduo na tabela fonte, <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join()</a></code> vai preencher as linhas correspondentes nas colunas que ele transferiu dessa tabela, com valores <code>NA</code>, indicando justamente que não há informações daquele respectivo indivíduo na tabela fonte.</p>
<p></p>
<div class="sourceCode" id="cb646"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join</a></span><span class="op">(</span><span class="va">info</span>, <span class="va">band_instruments</span>, by <span class="op">=</span> <span class="st">"name"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 5 x 5
##   name   band           born       children plays 
##   &lt;chr&gt;  &lt;chr&gt;          &lt;date&gt;     &lt;lgl&gt;    &lt;chr&gt; 
## 1 Mick   Rolling Stones 1943-07-26 TRUE     &lt;NA&gt;  
## 2 John   Beatles        1940-09-10 TRUE     guitar
## 3 Paul   Beatles        1942-06-18 TRUE     bass  
## 4 George Beatles        1943-02-25 TRUE     &lt;NA&gt;  
## 5 Ringo  Beatles        1940-07-07 TRUE     &lt;NA&gt;</code></pre>
<p></p>
<p>Em contrapartida, a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">right_join()</a></code> realiza justamente o processo contrário, ao manter as linhas da tabela fonte (ou a tabela que você forneceu ao argumento <code>y</code>). Por isso, para todas as linhas da tabela fonte que se referem a um indivíduo não encontrado na tabela destinatária, <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">right_join()</a></code> acaba preenchendo os campos provenientes da tabela destinatária, com valores <code>NA</code>, indicando assim que a função não conseguiu encontrar mais dados sobre aquele indivíduo na tabela destinatária. Você pode perceber esse comportamento, pela linha referente ao músico Keith, que está disponível na tabela fonte, mas não na tabela destinatária.</p>
<p></p>
<div class="sourceCode" id="cb648"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">right_join</a></span><span class="op">(</span><span class="va">info</span>, <span class="va">band_instruments</span>, by <span class="op">=</span> <span class="st">"name"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 5
##   name  band    born       children plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;date&gt;     &lt;lgl&gt;    &lt;chr&gt; 
## 1 John  Beatles 1940-09-10 TRUE     guitar
## 2 Paul  Beatles 1942-06-18 TRUE     bass  
## 3 Keith &lt;NA&gt;    NA         NA       guitar</code></pre>
<p></p>
<p>Por fim, a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join()</a></code> executa o processo inverso da função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join()</a></code>. Ou seja, se por um lado, a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">inner_join()</a></code> mantém as linhas de todos os indivíduos que puderam ser localizados em ambas as tabelas, por outro, a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join()</a></code> não depende desses indivíduos aparecem ou não em ambas as tabelas, ela sempre traz todos os indivíduos em seu resultado. Logo, <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join()</a></code> mantém todas as linhas de ambas as tabelas. De certa forma, a função <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join()</a></code> busca encontrar sempre o maior número possível de combinações entre as tabelas, e em todas as ocasiões que <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join()</a></code> não encontra um determinado indivíduo, por exemplo, na tabela B, a função vai preecher os campos dessa tabela B com valores <code>NA</code> para as linhas desse indivíduo. Veja o exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb650"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">full_join</a></span><span class="op">(</span><span class="va">info</span>, <span class="va">band_instruments</span>, by <span class="op">=</span> <span class="st">"name"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 6 x 5
##   name   band           born       children plays 
##   &lt;chr&gt;  &lt;chr&gt;          &lt;date&gt;     &lt;lgl&gt;    &lt;chr&gt; 
## 1 Mick   Rolling Stones 1943-07-26 TRUE     &lt;NA&gt;  
## 2 John   Beatles        1940-09-10 TRUE     guitar
## 3 Paul   Beatles        1942-06-18 TRUE     bass  
## 4 George Beatles        1943-02-25 TRUE     &lt;NA&gt;  
## 5 Ringo  Beatles        1940-07-07 TRUE     &lt;NA&gt;  
## 6 Keith  &lt;NA&gt;           NA         NA       guitar</code></pre>
<p></p>
<p>Como o primeiro <code>data.frame</code> fornecido à função <code>*_join()</code>, será na maioria das situações, a sua principal tabela de trabalho, o ideal é que você adote o <code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join()</a></code> como o seu padrão de <em>join</em> <span class="citation">(<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">Wickham and Grolemund 2017</a>)</span>. Pois dessa maneira, você evita uma possível perda de observações em sua tabela mais importante.</p>
</div>
<div id="relações-entre-keys-primary-keys-são-menos-comuns-do-que-você-pensa" class="section level2" number="6.6">
<h2>
<span class="header-section-number">6.6</span> Relações entre <em>keys</em>: <em>primary</em> keys são menos comuns do que você pensa<a class="anchor" aria-label="anchor" href="#rela%C3%A7%C3%B5es-entre-keys-primary-keys-s%C3%A3o-menos-comuns-do-que-voc%C3%AA-pensa"><i class="fas fa-link"></i></a>
</h2>
<p>Na seção <a href="introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-no-r.html#sec:relational_data_keys">Dados relacionais e o conceito de <em>key</em></a>, nós estabelecemos que variáveis com a capacidade de identificar unicamente cada observação de sua base, podem ser caracterizadas como <em>primary keys</em>. Mas para que essa característica seja verdadeira para uma dada variável, os seus valores não podem se repetir ao longo da base, e isso não acontece com tanta frequência na realidade.</p>
<p>Como exemplo, podemos voltar ao <em>join</em> entre as tabelas <code>flights</code> e <code>weather</code> que mostramos na seção <a href="introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-no-r.html#sec:config_colunas_keys">Configurações sobre as colunas e <em>keys</em> utilizadas no <em>join</em></a>. Para realizarmos o <em>join</em> entre essas tabelas, nós utilizamos as colunas <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> e <code>origin</code> como <em>key</em>. Porém, a forma como descrevemos essas colunas na seção passada, ficou subentendido que a combinação entre elas foi capaz de formar uma <em>primary key</em>. Bem, porque não conferimos se essas colunas assumem de fato esse atributo:</p>
<p></p>
<div class="sourceCode" id="cb652"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">flights</span> <span class="op">%&gt;%</span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/count.html">count</a></span><span class="op">(</span><span class="va">year</span>, <span class="va">month</span>, <span class="va">day</span>, <span class="va">hour</span>, <span class="va">origin</span><span class="op">)</span> <span class="op">%&gt;%</span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">n</span> <span class="op">&gt;</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 18,906 x 6
##     year month   day  hour origin     n
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;
##  1  2013     1     1     5 EWR        2
##  2  2013     1     1     5 JFK        3
##  3  2013     1     1     6 EWR       18
##  4  2013     1     1     6 JFK       17
##  5  2013     1     1     6 LGA       17
##  6  2013     1     1     7 EWR       12
##  7  2013     1     1     7 JFK       16
##  8  2013     1     1     7 LGA       21
##  9  2013     1     1     8 EWR       20
## 10  2013     1     1     8 JFK       23
## # ... with 18,896 more rows</code></pre>
<p></p>
<p>Como podemos ver acima, há diversas combinações entre as cinco colunas que se repetem ao longo da base. Com isso, podemos afirmar que a combinação entre as colunas <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> e <code>origin</code> não formam uma <em>primary key</em>. Perceba abaixo, que o mesmo vale para a tabela <code>weather</code>:</p>
<p></p>
<div class="sourceCode" id="cb654"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">weather</span> <span class="op">%&gt;%</span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/count.html">count</a></span><span class="op">(</span><span class="va">year</span>, <span class="va">month</span>, <span class="va">day</span>, <span class="va">hour</span>, <span class="va">origin</span><span class="op">)</span> <span class="op">%&gt;%</span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">n</span> <span class="op">&gt;</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 6
##    year month   day  hour origin     n
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;int&gt;
## 1  2013    11     3     1 EWR        2
## 2  2013    11     3     1 JFK        2
## 3  2013    11     3     1 LGA        2</code></pre>
<p></p>
<p>Portanto, circunstâncias em que não há uma <em>primary key</em> definida entre duas tabelas, são comuns, inclusive em momentos que você utiliza a combinação de todas as colunas disponíveis em uma das tabelas para formar uma <em>key</em>. Com isso, eu quero destacar principalmente, que não há problema algum em utilizarmos <em>foreign keys</em> em <em>joins</em>.</p>
<p>Logo, você deve definir a <em>key</em> mais apropriada para o seu <em>join</em>, baseado no seu conhecimento sobre esses dados, e não de forma a procurar por colunas de mesmo nome em ambas as colunas <span class="citation">(<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">Wickham and Grolemund 2017</a>)</span>. Durante esse processo, nós não estamos perseguindo <em>primary keys</em> de maneira obsessiva, mas sim, pesquisando por relações verdadeiras e lógicas entre as tabelas.</p>
<p>Por exemplo, no caso das tabelas <code>flights</code> e <code>weather</code>, utilizamos as colunas <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> e <code>origin</code> como <em>key</em>, pelo fato de que eventos climáticos ocorrem um dado momento (<code>hour</code>) de um dia específico (<code>year</code>, <code>month</code> e <code>day</code>), além de geralmente se restringir a uma dada região geográfica (<code>origin</code>). Curiosamente, essas colunas não foram suficientes para produzirmos uma <em>primary key</em>, mas foi o suficiente para representarmos uma conexão lógica entre as tabelas <code>flights</code> e <code>weather</code>.</p>
<p>Assim sendo, qualquer que seja o tipo de <em>key</em> empregado, o processo de <em>join</em> irá ocorrer exatamente da mesma forma. Porém, o tipo que a <em>key</em> assume em cada tabela pode alterar as combinações geradas no resultado do <em>join</em>. Como temos duas tabelas em cada <em>join</em>, temos três possibilidades de relação entre as <em>keys</em> de cada tabela: 1) <em>primary key</em> <span class="math inline">\(\rightarrow\)</span> <em>primary key</em>; 2) <em>primary key</em> <span class="math inline">\(\rightarrow\)</span> <em>foreign key</em>; 3) <em>foreign key</em> <span class="math inline">\(\rightarrow\)</span> <em>foreign key</em>. Ou seja, em cada uma das tabelas envolvidas em um <em>join</em>, as colunas a serem utilizadas como <em>key</em> podem se caracterizar como uma <em>primary key</em> ou como uma <em>foreign key</em>.</p>
<p>Como exemplo, o <em>join</em> formado pelas tabelas <code>info</code> e <code>band_instruments</code>, possui uma relação de <em>primary key</em> <span class="math inline">\(\rightarrow\)</span> <em>primary key</em>. Pois a coluna <code>name</code> é uma <em>primary key</em> em ambas as tabelas. Por outro lado, o <em>join</em> formado pelas tabelas <code>flights</code> e <code>weather</code>, possui uma relação de <em>foreign key</em> <span class="math inline">\(\rightarrow\)</span> <em>foreign key</em>, visto que as cinco colunas utilizadas como <em>key</em> não são capazes de identificar unicamente cada observação nas duas tabelas, como comprovamos acima.</p>
<p>Com isso, temos a opção de compreendermos a relação entre as <em>keys</em>, como uma relação de quantidade de cópias, fazendo referência direta ao fato de que uma <em>primary key</em> não possui valores repetidos ao longo da base, enquanto o mesmo não pode ser dito de uma <em>foreign key</em>. Logo, uma relação <em>primary key</em> <span class="math inline">\(\rightarrow\)</span> <em>primary key</em> pode ser identificada como uma relação de <strong>um para um</strong>, pois sempre vamos contar com uma única chave para cada observação em ambas as tabelas. Para mais, podemos interpretar uma relação <em>primary key</em> <span class="math inline">\(\rightarrow\)</span> <em>foreign key</em>, como uma relação de <strong>um para muitos</strong>, pois para cada chave única presente em uma das tabelas, podemos dispor de múltiplas irmãs gêmeas presentes na outra tabela.</p>
<p>Deste modo, se tivermos uma relação <em>foreign key</em> <span class="math inline">\(\rightarrow\)</span> <em>foreign key</em>, ou uma relação de <strong>muitos para muitos</strong>, para cada conjunto de <em>keys</em> repetidas em ambas as tabelas, todas as possibilidades de combinação são geradas. Em outras palavras, nesse tipo de relação, o resultado do <em>join</em> será uma produto cartesiano como demonstrado pela figura 6.4.</p>
<p>Relações de um para um são raras e, por essa razão, vamos mais comumente possuir uma relação de um para muitos em nossas tabelas, onde nesse caso, as <em>primary keys</em> são replicadas no resultado do <em>join</em>, para cada repetição de sua <em>key</em> correspondente na outra tabela, como pode ser visto na figura 6.4.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-382"></span>
<img src="Figuras/relacoes_keys.png" alt="Resumo das relações possíveis entre keys, inspirado em  Wickham e Grolemund (2017)" width="80%"><p class="caption">
Figure 6.4: Resumo das relações possíveis entre keys, inspirado em Wickham e Grolemund (2017)
</p>
</div>
<p></p>
</div>
<div id="exercícios-4" class="section level2 unnumbered">
<h2>Exercícios<a class="anchor" aria-label="anchor" href="#exerc%C3%ADcios-4"><i class="fas fa-link"></i></a>
</h2>
<p>O primeiro exercício desse capítulo, envolve duas tabelas publicadas na semana 11 do projeto Tidy Tuesday em 2020. Mais especificamente, as tabelas <code>tuition_cost</code> e <code>salary_potential</code>. A tabela <code>tuition_cost</code> descreve os custos de um curso de graduação em diferentes universidades dos EUA. Em contrapartida, a tabela <code>salary_potential</code> fornece uma estimativa do salário pontencial que um diploma de graduação de diversas universidades dos EUA podem fornecer a um profissional.</p>
<p>No Brasil, as faculdades privadas geralmente cobram por uma mensalidade fixa que abrange todos os custos mínimos. Já algumas universidades privadas, tendem a usar um sistema mais complexo, onde uma mensalidade base é cobrada, além de taxas por aulas práticas (para cobrir gastos com o uso de equipamentos) e taxas por matéria matriculada. Em outras palavras, um aluno de uma universidade privada brasileira que se matricula, por exemplo, em 4 matérias num dado semestre, geralmente paga um valor mensal que segue a estrutura: mensalidade base + taxa por aula prática (se houver alguma aula prática) + (4 <span class="math inline">\(\times\)</span> taxa por matrícula).</p>
<p>Por outro lado, as universidades americanas possuem um sistema mais complexo de cobrança. Primeiro, a maior parte dos estudantes americanos optam por morar e se alimentar nos alojamentos da universidade, ao invés de se manterem na casa dos pais. A universidade cobra uma taxa específica para esses estudantes, que busca pagar justamente os custos deste alojamento e de sua alimentação. Tal custo é geralmente denominado de <em>room and board fees</em>. Segundo, universidades americanas cobram principalmente pelo seu “ensino” (e alguns outros serviços) e, por isso, a maior parte de seus preços envolvem o que chamamos de <em>“tuition fees”</em> (ou “taxa de ensino”). Terceiro, os valores divulgados pelas universidades são geralmente anuais, logo, se o <em>tuition fees</em> (ou <em>room and board fees</em>) de uma universidade qualquer é de $25 mil, isso significa que um curso de 4 anos nessa universidade custaria em torno de $100 mil.</p>
<p>Portanto, as universidades americanas cobram, em geral, dois tipos de custos diferentes (<em>room and board fees</em> e <em>tuition fees</em>) e, esses custos são em sua maioria, anuais. Grande parte dos alunos acabam pagando ambos desses custos, logo, esses custos somados representam, para grande parte da população, o custo total por ano de uma universidade nos EUA.</p>
<p>Para mais, as universidades americanas também cobram taxas de ensino (<em>tuition fees</em>) diferentes de acordo com o estado em que o aluno reside. Ou seja, uma universidade que está sediada no estado do Texas vai cobrar uma taxa mais barata para os alunos que moram no estado do Texas. Porém, os alunos que são originalmente de outros estados, e estão vindo para essa universidade vão pagar taxas maiores.</p>
<p><strong>Questão 6.1.</strong> Suponha que você esteja interessado em realizar um curso de graduação em alguma das universidades descritas na tabela <code>tuition_cost</code>. Como você provavelmente não mora nos Estados Unidos, considere os custos referentes a alunos <em>out of state</em> em seus cálculos. Vale também ressaltar que os salários estimados na tabela <code>salary_potential</code>, assim como os custos na tabela <code>tuition_cost</code>, são anuais. Com base nas estimativas de salário presentes na tabela <code>salary_potential</code> e, com base nos custos descritos na tabela <code>tuition_cost</code>, tente calcular (para cada universidade) o tempo de trabalho necessário (após a graduação) para pagar pelo investimento que você aplicou no curso de graduação.</p>
<p></p>
<div class="sourceCode" id="cb656"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span>

<span class="va">github</span> <span class="op">&lt;-</span> <span class="st">"https://raw.githubusercontent.com/rfordatascience/"</span>
<span class="va">pasta</span> <span class="op">&lt;-</span> <span class="st">"tidytuesday/master/data/2020/2020-03-10/"</span>
<span class="va">cost</span> <span class="op">&lt;-</span> <span class="st">"tuition_cost.csv"</span>
<span class="va">salary</span> <span class="op">&lt;-</span> <span class="st">"salary_potential.csv"</span>

<span class="va">tuition_cost</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="va">github</span>, <span class="va">pasta</span>, <span class="va">cost</span><span class="op">)</span><span class="op">)</span>
<span class="va">salary_potential</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="va">github</span>, <span class="va">pasta</span>, <span class="va">salary</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p></p>
<p><strong>Questão 6.2.</strong> Todos os itens abaixo envolvem as tabelas <code>consumidores</code> e <code>vendedores</code>, alguns itens serão teóricos, outros, vão lhe requisitar o cálculo de alguma informação. Como esses cálculos envolvem as informações de ambas as tabelas, você será obrigado a aplicar um <em>join</em> entre elas para realizá-lo:</p>
<p></p>
<div class="sourceCode" id="cb657"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span>

<span class="va">github</span> <span class="op">&lt;-</span> <span class="st">"https://raw.githubusercontent.com/pedropark99/"</span>
<span class="va">pasta</span> <span class="op">&lt;-</span> <span class="st">"Curso-R/master/Dados/"</span>
<span class="va">arquivo1</span> <span class="op">&lt;-</span> <span class="st">"consumidor.csv"</span>
<span class="va">arquivo2</span> <span class="op">&lt;-</span> <span class="st">"vendedores.csv"</span>

<span class="va">consumidores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="va">github</span>, <span class="va">pasta</span>, <span class="va">arquivo1</span><span class="op">)</span><span class="op">)</span>
<span class="va">vendedores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="va">github</span>, <span class="va">pasta</span>, <span class="va">arquivo2</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p></p>
<p>6.2.A) Quais colunas representam as <em>keys</em> em ambas as tabelas?</p>
<p>6.2.B) Na tabela <code>consumidores</code>, quais colunas representam uma <em>primary key</em>, e quais representam uma <em>foreign key</em>?</p>
<p>6.2.C) Descubra o número de cidades nas quais cada vendedor atendeu os seus clientes.</p>
<p><strong>Questão 6.3.</strong> Dado que você tenha importado as tabelas <code>filmes</code> e <code>filmes_receita</code> abaixo para o seu R, e, tendo em mente o que vimos nesse capítulo, explique porque o comando de <em>join</em> abaixo não funciona sobre essas tabelas. Dado que você encontre e explique o que está errado, como você ajustaria esse comando para que ele funcione normalmente?</p>
<p></p>
<div class="sourceCode" id="cb658"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span>

<span class="va">github</span> <span class="op">&lt;-</span> <span class="st">"https://raw.githubusercontent.com/pedropark99/"</span>
<span class="va">pasta</span> <span class="op">&lt;-</span> <span class="st">"Curso-R/master/Dados/"</span>
<span class="va">arquivo1</span> <span class="op">&lt;-</span> <span class="st">"filmes_dados.csv"</span>
<span class="va">arquivo2</span><span class="op">&lt;-</span> <span class="st">"filmes_receita.csv"</span>

<span class="va">filmes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="va">github</span>, <span class="va">pasta</span>, <span class="va">arquivo1</span><span class="op">)</span><span class="op">)</span>
<span class="va">filmes_receita</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="va">github</span>, <span class="va">pasta</span>, <span class="va">arquivo2</span><span class="op">)</span><span class="op">)</span>


<span class="co">### Porque esse comando de join</span>
<span class="co">### abaixo não funciona?</span>
<span class="va">filmes</span> <span class="op">%&gt;%</span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">left_join</a></span><span class="op">(</span>
    <span class="va">filmes_receita</span>
  <span class="op">)</span></code></pre></div>
<p></p>

</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="fun%C3%A7%C3%B5es-e-loops-no-r.html"><span class="header-section-number">5</span> Funções e Loops no R</a></div>
<div class="next"><a href="tidy-data-uma-abordagem-para-organizar-os-seus-dados.html"><span class="header-section-number">7</span> Tidy Data: Uma abordagem para organizar os seus dados</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-no-r"><span class="header-section-number">6</span> Introdução a base de dados relacionais no R</a></li>
<li><a class="nav-link" href="#introdu%C3%A7%C3%A3o-e-pr%C3%A9-requisitos-1"><span class="header-section-number">6.1</span> Introdução e pré-requisitos</a></li>
<li><a class="nav-link" href="#sec:relational_data_keys"><span class="header-section-number">6.2</span> Dados relacionais e o conceito de key</a></li>
<li><a class="nav-link" href="#introduzindo-joins"><span class="header-section-number">6.3</span> Introduzindo joins</a></li>
<li><a class="nav-link" href="#sec:config_colunas_keys"><span class="header-section-number">6.4</span> Configurações sobre as colunas e keys utilizadas no join</a></li>
<li><a class="nav-link" href="#diferentes-tipos-de-join"><span class="header-section-number">6.5</span> Diferentes tipos de join</a></li>
<li><a class="nav-link" href="#rela%C3%A7%C3%B5es-entre-keys-primary-keys-s%C3%A3o-menos-comuns-do-que-voc%C3%AA-pensa"><span class="header-section-number">6.6</span> Relações entre keys: primary keys são menos comuns do que você pensa</a></li>
<li><a class="nav-link" href="#exerc%C3%ADcios-4">Exercícios</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/pedropark99/Introducao_R//blob/master/06-dados-relacionais.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/pedropark99/Introducao_R//edit/master/06-dados-relacionais.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Introdução à Linguagem R: seus fundamentos e sua prática</strong>" was written by Pedro Faria. It was last built on 2021-07-17.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>
</html>
