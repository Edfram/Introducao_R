<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Capítulo 3 Importando e exportando dados com o R | Introdução à Linguagem R: seus fundamentos e sua prática</title>
<meta name="author" content="Pedro Faria">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.2"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.9/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.2.5.1/tabs.js"></script><script src="libs/bs3compat-0.2.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/mark.min.js"></script><!-- CSS -->
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Introdução à Linguagem R: seus fundamentos e sua prática</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Bem vindo!</a></li>
<li><a class="" href="sobre-os-autores.html">Sobre os autores</a></li>
<li><a class="" href="pref%C3%A1cio.html">Prefácio</a></li>
<li><a class="" href="no%C3%A7%C3%B5es-b%C3%A1sicas-do-r.html"><span class="header-section-number">1</span> Noções Básicas do R</a></li>
<li><a class="" href="fundamentos-da-linguagem-r.html"><span class="header-section-number">2</span> Fundamentos da Linguagem R</a></li>
<li><a class="active" href="importando-e-exportando-dados-com-o-r.html"><span class="header-section-number">3</span> Importando e exportando dados com o R</a></li>
<li><a class="" href="transformando-dados-com-dplyr.html"><span class="header-section-number">4</span> Transformando dados com dplyr</a></li>
<li><a class="" href="fun%C3%A7%C3%B5es-e-loops-no-r.html"><span class="header-section-number">5</span> Funções e Loops no R</a></li>
<li><a class="" href="introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-no-r.html"><span class="header-section-number">6</span> Introdução a base de dados relacionais no R</a></li>
<li><a class="" href="tidy-data-uma-abordagem-para-organizar-os-seus-dados.html"><span class="header-section-number">7</span> Tidy Data: Uma abordagem para organizar os seus dados</a></li>
<li><a class="" href="visualiza%C3%A7%C3%A3o-de-dados-com-ggplot2.html"><span class="header-section-number">8</span> Visualização de dados com ggplot2</a></li>
<li><a class="" href="configurando-componentes-est%C3%A9ticos-do-gr%C3%A1fico-no-ggplot2.html"><span class="header-section-number">9</span> Configurando componentes estéticos do gráfico no ggplot2</a></li>
<li><a class="" href="manipula%C3%A7%C3%A3o-e-transforma%C3%A7%C3%A3o-de-strings-com-stringr.html"><span class="header-section-number">10</span> Manipulação e transformação de strings com stringr</a></li>
<li><a class="" href="introduzindo-fatores-factors-com-forcats.html"><span class="header-section-number">11</span> Introduzindo fatores (factor’s) com forcats</a></li>
<li><a class="" href="introdu%C3%A7%C3%A3o-%C3%A0-vari%C3%A1veis-de-tempo-com-lubridate.html"><span class="header-section-number">12</span> Introdução à variáveis de tempo com lubridate</a></li>
<li><a class="" href="respostas-dos-exerc%C3%ADcios-de-cada-cap%C3%ADtulo.html">Respostas dos exercícios de cada capítulo</a></li>
<li class="book-part">Apêndices</li>
<li><a class="" href="pnad-cont%C3%ADnua-arquivo-csv-para-input.html"><span class="header-section-number">A</span> PNAD Contínua: arquivo CSV para input</a></li>
<li><a class="" href="refer%C3%AAncias.html">Referências</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/pedropark99/Introducao_R/">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="importando-e-exportando-dados-com-o-r" class="section level1" number="3">
<h1>
<span class="header-section-number">Capítulo 3</span> Importando e exportando dados com o R<a class="anchor" aria-label="anchor" href="#importando-e-exportando-dados-com-o-r"><i class="fas fa-link"></i></a>
</h1>
<div id="sec:importando_dados" class="section level2" number="3.1">
<h2>
<span class="header-section-number">3.1</span> Introdução e pré-requisitos<a class="anchor" aria-label="anchor" href="#sec:importando_dados"><i class="fas fa-link"></i></a>
</h2>
<p>Em algum ponto, você vai trabalhar com os seus próprios dados no R e, para isso, você precisa obrigatoriamente importar esses dados para dentro do R. Neste capítulo, vamos aprender como utilizar as funções dos pacotes <code>readr</code>, <code>readxl</code> e <code>haven</code>, para ler e importar dados presentes em arquivos de texto (<em>plain text files</em> - <code>.txt</code> ou <code>.csv</code>), em planilhas do Excel (<code>.xlsx</code>) e em arquivos produzidos por programas estatísticos como o Stata (<code>.dta</code>), SPSS (<code>.sav</code>; <code>.zsav</code> e <code>.por</code>) e SAS (<code>.sas</code>).</p>
<p>Para que você tenha acesso as funções e possa acompanhar os exemplos desse capítulo você precisa chamar pelos pacotes <code>readr</code>, <code>readxl</code> e <code>haven</code>, através do comando <code><a href="https://rdrr.io/r/base/library.html">library()</a></code>. O pacote <code>readr</code> especificamente, está incluso dentro do <code>tidyverse</code> e, por isso, você também pode chamar por ele.</p>
<p></p>
<div class="sourceCode" id="cb267"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span>

<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://readr.tidyverse.org">readr</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://readxl.tidyverse.org">readxl</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://haven.tidyverse.org">haven</a></span><span class="op">)</span></code></pre></div>
<p></p>
</div>
<div id="fontes-de-dados" class="section level2" number="3.2">
<h2>
<span class="header-section-number">3.2</span> Fontes de dados<a class="anchor" aria-label="anchor" href="#fontes-de-dados"><i class="fas fa-link"></i></a>
</h2>
<p>Os seus dados podem vir de diferentes tipos de fontes. Com isso, os métodos necessários para acessar e importar esses dados para o R, mudam. Em resumo, os seus dados podem provir de três tipos de fontes diferentes:</p>
<ol style="list-style-type: decimal">
<li><p>Arquivo estático salvo no disco rígido de seu computador.</p></li>
<li><p>Servidor local ou <em>online</em>.</p></li>
<li><p>Página da internet.</p></li>
</ol>
<p>Nós normalmente transportamos os nossos dados através de um arquivo estático, que pode ser salvo em nosso computador. Por isso, ao importar os nossos dados para o R, vamos estar preocupados na grande maioria das vezes, em ler um arquivo que se encontra salvo em nosso computador. Por este motivo, os métodos que serão mostrados nesse capítulo, buscam ler e importar diferentes tipos de arquivos estatícos. Em um processo como esse, a localização desse arquivo no disco rígido é um fator importante. Além disso, diferentes tipos de arquivos são estruturados de maneiras distintas e, por essa razão, você vai precisar de uma função no R que seja capaz de ler esse tipo de arquivo, ou em outras palavras, que seja capaz de reconhecer a estrutura desse arquivo.</p>
<p>Por outro lado, se você está importando os seus dados a partir de um servidor, você muito provavelmente estará extraindo dados de um DBMS (<em>database management system</em>). Os sistemas DBMS mais famosos e mais utilizados no mundo, são os sistemas que utilizam a linguagem SQL (<em>Structured Query Language</em>). Para extrair um conjunto de dados desse tipo de fonte, você em geral necessita de uma chave, ou uma API (<em>Application Programming Interface</em>) que lhe garanta acesso ao servidor e, portanto, acesso aos dados que você deseja importar. Esse processo de importação não será tratado aqui, mas você vai precisar das funções disponíveis em pacotes como <code>jsonlite</code>, <code>odbc</code> e <code>DBI</code> para tal processo.</p>
<p>Além dessas alternativas, você pode estar interessado em coletar dados de uma página da internet. Não estou me referindo a um arquivo estático que esteja disponível para <em>download</em> através dessa página da internet, mas sim, de coletar o conteúdo dessa página, de coletar os dados que formam a própria página da internet em si. Esse tipo de coleta, e os métodos envolvidos nesse processo, são comumente chamados de <em>web scraping</em>, e hoje, representam uma área importante em análise de dados. Esse processo de importação também não será mostrado aqui, mas você pode consultar as funções dos pacotes <code>httr</code>, <code>xml2</code> e <code>rvest</code> para executar tal processo.</p>
</div>
<div id="diretório-de-trabalho" class="section level2" number="3.3">
<h2>
<span class="header-section-number">3.3</span> Diretório de trabalho<a class="anchor" aria-label="anchor" href="#diret%C3%B3rio-de-trabalho"><i class="fas fa-link"></i></a>
</h2>
<p>A linguagem R possui uma forte noção de diretórios de trabalho <span class="citation">(<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">Wickham and Grolemund 2017</a>, p 113)</span>. O diretório de trabalho (<em>working directory</em>) é o local de seu computador onde o R vai procurar pelos arquivos que você demanda, e será onde o R vai guardar todos os arquivos que você pede a ele que salve.</p>
<p>Isso significa que em todas as ocasiões em que você estiver no R, ele estará trabalhando com alguma pasta específica de seu computador. No RStudio, você pode identificar o seu diretório de trabalho atual na parte esquerda e superior do console, logo abaixo do nome de sua guia (<code>Console</code>), como mostrado na figura 3.1. Repare abaixo, que no momento em que a foto presente na figura 3.1 foi tirada, eu estava trabalhando com uma pasta de meu computador chamada <code>Curso-R</code>, que por sua vez, se encontrava dentro de uma pasta chamada <code>Projeto curso R</code>.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-122"></span>
<img src="Figuras/diretorio_console.png" alt="Diretório de trabalho - Console RStudio" width="70%"><p class="caption">
Figure 3.1: Diretório de trabalho - Console RStudio
</p>
</div>
<p></p>
<p>Nós também podemos descobrir o diretório de trabalho atual em nossa sessão do R, através da função <code><a href="https://rdrr.io/r/base/getwd.html">getwd()</a></code>.</p>
<p></p>
<div class="sourceCode" id="cb268"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/getwd.html">getwd</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## [1] "C:/Users/Pedro/Documents/Projeto curso R/Curso-R"</code></pre>
<p>Dessa forma, supondo que o meu diretório de trabalho atual seja a pasta <code>Curso-R</code>, se eu pedir por algum arquivo chamado <code>frase.txt</code>, o R vai procurar por esse arquivo dentro dessa pasta <code>Curso-R</code>. Isso tem duas implicações muito importantes. Primeiro, o arquivo <code>frase.txt</code> deve estar dentro dessa pasta <code>Curso-R</code>, caso contrário o R não poderá encontrar o arquivo. Segundo, temos uma maneira muito simples e poderosa de acessarmos qualquer arquivo que esteja presente na pasta <code>Curso-R</code>, pois precisamos apenas do nome desse arquivo, como no exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb270"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/read_lines.html">read_lines</a></span><span class="op">(</span><span class="st">"frase.txt"</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## [1] "Aristóteles foi um filósofo da Grécia Antiga"</code></pre>
<p></p>
<p>Um ponto muito importante é que a extensão do arquivo (que traduz o seu tipo) também faz parte do nome do arquivo. No exemplo acima, o arquivo se chama <code>frase</code> e possui a extensão <code>.txt</code>, logo, o nome do arquivo a ser fornecido ao R é <code>frase.txt</code>.</p>
</div>
<div id="sec:enderecos_disco_rigido" class="section level2" number="3.4">
<h2>
<span class="header-section-number">3.4</span> Definindo endereços do disco rígido no R<a class="anchor" aria-label="anchor" href="#sec:enderecos_disco_rigido"><i class="fas fa-link"></i></a>
</h2>
<p>Portanto, o mecanismo de diretórios de trabalho apenas limita o escopo de busca do R. Dito de outra forma, ele define onde o R irá procurar pelos seus arquivos e, onde esses arquivos serão salvos através do R. Entretanto, isso não quer dizer que você não possa acessar arquivos que se encontram em outras áreas do seu computador. Porém, para acessarmos qualquer arquivo que esteja fora de seu diretório de trabalho atual, nós precisamos obrigatoriamente fornecer o endereço até esse arquivo para o R.</p>
<div id="cuidados-ao-definir-endereços" class="section level3" number="3.4.1">
<h3>
<span class="header-section-number">3.4.1</span> Cuidados ao definir endereços<a class="anchor" aria-label="anchor" href="#cuidados-ao-definir-endere%C3%A7os"><i class="fas fa-link"></i></a>
</h3>
<p>Alguns cuidados no R são necessários ao definir um endereço até um arquivo. Primeiro, endereços de seu disco rígido devem sempre ser fornecidos como textos (<em>strings</em>), por isso, lembre-se de contornar o seu endereço com aspas duplas ou simples no R. Segundo, o Windows utiliza por padrão a barra inclinada à esquerda (<code>\</code>) para separar cada diretório presente no caminho até um certo arquivo. Todavia, a barra inclinada à esquerda possui um significado especial para o R.</p>
<p>Abordando especificamente o segundo ponto, você tem duas alternativas para contornar as particularidades das barras inclinadas utilizadas nos endereços de seus arquivos: 1) utilizar o estilo dos sistemas Mac e Linux, que utilizam a barra inclinada à direita (<code><a href="https://rdrr.io/r/base/Arithmetic.html">/</a></code>) para separar os diretórios; 2) ou contornar o comportamento especial de uma barra inclinada à esquerda, com duas barras inclinadas à esquerda (<code>\\</code>). Ou seja, é como se essas duas barras <code>\\</code> significassem apenas uma barra <code>\</code> para o R. Eu particularmente prefiro utilizar o estilo dos sistemas Mac e Linux para resolver esse problema, pois ele incorre em um trabalho menor de digitação.</p>
<p>Por exemplo, eu possuo um arquivo chamado <code>livros.txt</code> localizado dentro da pasta <code>Lista de compras</code>, que por sua vez, se encontra dentro da minha pasta de <code>Documentos</code> do Windows. Segundo o padrão do Windows, o endereço até esse arquivo seria: <code>"C:\Users\Pedro\Documents\Lista de compras\livros.txt"</code>. Porém, levando-se em conta os pontos que acabamos de abordar, nós poderíamos fornecer um dos dois endereços abaixo para me referir a este arquivo no R:</p>
<p></p>
<div class="sourceCode" id="cb272"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">livros</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="st">"C:\\Users\\Pedro\\Documents\\Lista de compras\\livros.txt"</span><span class="op">)</span>

<span class="va">livros</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="st">"C:/Users/Pedro/Documents/Lista de compras/livros.txt"</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb273"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">livros</span></code></pre></div>
<pre><code>## # A tibble: 4 x 3
##   Título                               Autor                          Preço
##   &lt;chr&gt;                                &lt;chr&gt;                          &lt;dbl&gt;
## 1 O Hobbit                             J. R. R. Tolkien                40.7
## 2 Matemática para Economistas          Carl P. Simon e Lawrence Blume 140. 
## 3 Microeconomia: uma abordagem moderna Hal R. Varian                  142. 
## 4 A Luneta Âmbar                       Philip Pullman                  42.9</code></pre>
<p></p>
</div>
<div id="endereços-relativos-e-absolutos" class="section level3" number="3.4.2">
<h3>
<span class="header-section-number">3.4.2</span> Endereços relativos e absolutos<a class="anchor" aria-label="anchor" href="#endere%C3%A7os-relativos-e-absolutos"><i class="fas fa-link"></i></a>
</h3>
<p>A depender do seu diretório de trabalho atual, e de onde o seu arquivo de interesse se encontra, você pode utilizar dois estilos diferentes de endereços (relativo e absoluto) para se referir a um dado arquivo. Vamos utilizar como exemplo, o conjunto de arquivos mostrados na figura 3.2 que se encontram dentro de uma pasta chamada <code>Dados</code>.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-129"></span>
<img src="Figuras/arquivos.png" alt="Exemplo de arquivos" width="80%"><p class="caption">
Figure 3.2: Exemplo de arquivos
</p>
</div>
<p></p>
<p>Caso o seu diretório de trabalho atual fosse, por exemplo, a pasta <code>Projeto curso R</code>, você poderia fornecer um endereço relativo para qualquer um desses arquivos presentes na pasta <code>Dados</code>. Pois a pasta <code>Dados</code> se encontra dentro da pasta <code>Projeto curso R</code>. Em outras palavras, a pasta <code>Dados</code> é uma subpasta da pasta <code>Projeto curso R</code>.</p>
<p>Logo, um endereço relativo possui como ponto inicial, o seu diretório de trabalho atual. Por isso, você pode acessar qualquer arquivo que esteja dentro de seu diretório de trabalho, ou dentro de alguma de suas subpastas, através de um endereço relativo. No caso dos arquivos da pasta <code>Dados</code>, nós poderíamos fornecer o endereço <code>"Curso-R/Dados/"</code> para chegarmos a pasta <code>Dados</code>. Em seguida, precisaríamos apenas acrescentar o nome do arquivo de nosso desejo. Por exemplo, se fôssemos ler o arquivo de nome <code>covid.csv</code>, o endereço resultante seria <code>"Curso-R/Dados/covid.csv"</code>.</p>
<p>Por outro lado, se o seu diretório de trabalho atual for uma pasta posterior à pasta <code>Dados</code> (ou seja, uma subpasta da pasta <code>Dados</code>), e você quiser acessar um dos arquivos da pasta <code>Dados</code>, você terá que fornecer um endereço absoluto até o arquivo em questão. Um endereço absoluto é um endereço que parte desde o disco rígido de seu computador até o arquivo de interesse. Por isso, um endereço absoluto sempre aponta para o mesmo local de seu computador, independente de qual seja o seu diretório de trabalho atual.</p>
<p>Para coletarmos o endereço absoluto de um arquivo no Windows, podemos clicar com o botão direito do mouse sobre o arquivo de interesse, e selecionar a opção <code>Propriedades</code>. Uma caixa vai abrir em sua tela, contendo diversas informações sobre o arquivo em questão. Logo a sua frente, temos a seção chamada <code>Local</code> na parte inicial dessa caixa, onde podemos encontrar o endereço absoluto até a pasta onde o seu arquivo de interesse está localizado.</p>
<p>Logo, se eu utilizasse esse recurso sobre um dos arquivos mostrados na figura 3.2, eu encontraria o seguinte endereço nessa seção <code>Local</code>: <code>"C:\Users\Pedro\Documents\Projeto curso R\Curso-R\Dados"</code>. Com esse endereço, precisamos apenas adicionar o nome do arquivo desejado, e ajustar as barras inclinadas à esquerda de acordo com as alternativas apresentadas na seção anterior. Por exemplo, se o nosso arquivo de interesse fosse o <code>covid.csv</code>, o endereço absoluto a ser fornecido ao R seria: <code>"C:/Users/Pedro/Documents/Projeto curso R/Curso-R/Dados/covid.csv"</code>.</p>
<p>Segundo <span class="citation"><a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">Wickham and Grolemund</a> (<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">2017</a>)</span>, é recomendável que você evite endereços absolutos, especialmente se você trabalha em conjunto. Pois é muito provável que os computadores de seus parceiros de trabalho não possuem exatamente a mesma estrutura de diretórios que o seu computador. Por isso, o ideal é que você sempre organize todos os arquivos referentes a um certo projeto ou a uma certa análise, dentro de uma pasta específica de seu computador. Dessa forma, você pode tornar essa pasta específica o seu diretório de trabalho no R, e a partir daí, fornecer endereços relativos até cada arquivo.</p>
</div>
</div>
<div id="plataforma-de-projetos-do-rstudio" class="section level2" number="3.5">
<h2>
<span class="header-section-number">3.5</span> Plataforma de Projetos do RStudio<a class="anchor" aria-label="anchor" href="#plataforma-de-projetos-do-rstudio"><i class="fas fa-link"></i></a>
</h2>
<p>No R, você pode configurar o seu diretório de trabalho atual, através da função <code><a href="https://rdrr.io/r/base/getwd.html">setwd()</a></code>. Basta fornecer o endereço absoluto até a pasta com a qual você deseja trabalhar. Veja o exemplo abaixo, em que eu escolho a pasta de <code>Documentos</code> do Windows como o meu diretório de trabalho:</p>
<p></p>
<div class="sourceCode" id="cb275"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/getwd.html">setwd</a></span><span class="op">(</span><span class="st">"C:/Users/Pedro/Documents"</span><span class="op">)</span></code></pre></div>
<p></p>
<p>Porém, esse não é um método recomendado de se configurar o seu diretório de trabalho, especialmente porque nós precisamos realizar essa configuração toda vez em que acessamos o R, sendo algo contraproducente. Por isso, <span class="citation"><a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">Wickham and Grolemund</a> (<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">2017</a>)</span> caracterizam a plataforma de Projetos do RStudio, como uma forma mais adequada e eficiente de realizarmos essa configuração.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-131"></span>
<img src="Figuras/projetos_menu.png" alt="Plataforma de Projetos do RStudio - Parte 1" width="75%"><p class="caption">
Figure 3.3: Plataforma de Projetos do RStudio - Parte 1
</p>
</div>
<p></p>
<p>Ao criar um projeto no RStudio, você está apenas criando um arquivo com o nome desse projeto e que possui uma extensão <code>.Rproj</code>. Esse arquivo <code>.Rproj</code> funciona como um link até a pasta onde você o guardou. Dessa forma, ao acessarmos esse projeto no RStudio, o seu console já vai estar trabalhando com a pasta onde o arquivo <code>.Rproj</code> foi salvo. Em termos técnicos, toda vez que você acessar esse projeto, o RStudio vai automaticamente configurar essa pasta como o seu diretório de trabalho atual do R.</p>
<p>Para criarmos um projeto no RStudio, você pode acessar um pequeno menu localizado na parte superior e direita de sua tela, mostrado na figura 3.3. Ao selecionar a opção <code>New Project...</code>, o seu RStudio vai abrir uma aba que está exposta na figura 3.4. Nessa aba, você vai selecionar como deseja criar o novo arquivo <code>.Rproj</code>. Caso você já tenha organizado todos os arquivos de seu projeto um pasta específica, você pode selecionar a opção <code>Existing Directory</code> para salvar o arquivo <code>.Rproj</code> nessa pasta já existente. Por outro lado, caso você esteja iniciando a sua análise do zero, você pode selecionar a opção <code>New Directory</code> para criar um novo diretório em seu computador, onde você vai guardar todos os arquivos referentes ao seu projeto.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-132"></span>
<img src="Figuras/projetos_caixa.png" alt="Plataforma de Projetos do RStudio - Parte 2" width="70%"><p class="caption">
Figure 3.4: Plataforma de Projetos do RStudio - Parte 2
</p>
</div>
<p></p>
<p>Ao selecionar uma dessas opções, o RStudio também vai lhe questionar sobre o tipo desse projeto, ou dito de outra maneira, qual o tipo de produto que você busca gerar com esse projeto, através da aba mostrada na figura 3.5. Ou seja, se você está planejando construir um novo pacote para o R, é interessante que você selecione a segunda opção (<code>R Package</code>) dessa aba. Pois assim, o próprio RStudio vai automaticamente criar para você, os principais arquivos que um pacote do R precisa ter. Em geral, você vai selecionar a primeira opção (<code>New Project</code>) para criar um projeto padrão.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-133"></span>
<img src="Figuras/tipo_projeto_mod.png" alt="Plataforma de Projetos do RStudio - Parte 3" width="70%"><p class="caption">
Figure 3.5: Plataforma de Projetos do RStudio - Parte 3
</p>
</div>
<p></p>
<p>No exemplo apresentado pela figura 3.6, eu estou criando um projeto padrão chamado <code>projeto_mortalidade</code> na pasta <code>Desktop</code> (que corresponde a área de trabalho) de meu computador. Com isso, uma nova pasta chamada <code>projeto_mortalidade</code> será criada, e sempre que eu acessar novamente o projeto <code>projeto_mortalidade</code> no RStudio, através do pequeno menu mostrado na figura 3.3, o RStudio vai automaticamente configurar a pasta <code>projeto_mortalidade</code> como o diretório de trabalho atual do R.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-134"></span>
<img src="Figuras/diretorio_projeto.png" alt="Plataforma de Projetos do RStudio - Parte 4" width="70%"><p class="caption">
Figure 3.6: Plataforma de Projetos do RStudio - Parte 4
</p>
</div>
<p></p>
</div>
<div id="importando-arquivos-de-texto-com-readr" class="section level2" number="3.6">
<h2>
<span class="header-section-number">3.6</span> Importando arquivos de texto com <code>readr</code><a class="anchor" aria-label="anchor" href="#importando-arquivos-de-texto-com-readr"><i class="fas fa-link"></i></a>
</h2>
<p>Arquivos de texto, também conhecidos como <em>plain text files</em>, ou <em>flat files</em>, estão entre os formatos de arquivo mais utilizados em todo o mundo para transportar e armazenar dados. Por isso é muito importante que você conheça esses arquivos e saiba reconhecê-los.</p>
<p>Um arquivo de texto, normalmente assume a extensão <code>.txt</code>, e contém apenas cadeias de textos ou cadeias de valores numéricos que são organizados em linhas. Apesar de simples, os dados armazenados podem ser organizados de diferentes formas em cada linha do arquivo. Por essa razão, um arquivo de texto pode assumir diferentes extensões que identificam o tipo de arquivo de texto ao qual ele pertence.</p>
<p>Em outras palavras, nós possuímos diferentes tipos de arquivos de texto, e a diferença básica entre eles, está na forma como os valores são organizados em cada linha do arquivo. Um dos tipos de arquivo de texto mais famosos é o arquivo CSV (<em>comma separated file</em>), que utiliza vírgulas (ou pontos e vírgulas como é o caso brasileiro) para separar os valores de diferentes colunas em cada linha do arquivo. Por isso, não basta que você identifique se o seu arquivo de interesse é um arquivo de texto, pois você também precisa identificar o <strong>tipo</strong> de arquivo de texto no qual ele se encaixa.</p>
<p>Para importarmos os dados presentes nesses arquivos, vamos utilizar as funções do pacote <code>readr</code>, que oferece um conjunto de funções especializadas em arquivos de texto. Logo abaixo, temos uma lista que associa os respectivos tipos de arquivos de texto a cada uma das funções desse pacote.</p>
<ol style="list-style-type: decimal">
<li><p><code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code>: essa é uma função geral, que é capaz de ler qualquer tipo de arquivo de texto em que os valores estão delimitados por algum caractere especial.</p></li>
<li><p><code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code>: lê arquivos CSV (<em>comma separated file</em>) que seguem o padrão adotado por alguns países europeus. Arquivos <code>.txt</code> ou <code>.csv</code>, em que os valores são separados por ponto e vírgula (;).</p></li>
<li><p><code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv()</a></code>: lê arquivos CSV (<em>comma separated file</em>) que seguem o padrão americano. Arquivos <code>.txt</code> ou <code>.csv</code> onde os valores são separados por vírgula (,).</p></li>
<li><p><code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_tsv()</a></code>: lê arquivos TSV (<em>tab separated values</em>). Arquivos <code>.txt</code> ou <code>.tsv</code> onde os valores são separados por tabulação (<code>\t</code>).</p></li>
<li><p><code><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf()</a></code>: lê arquivos FWF (<em>fixed width file</em>). Arquivos <code>.txt</code> ou <code>.fwf</code> onde cada coluna do arquivo possui uma largura fixa de valores.</p></li>
</ol>
<p>Perceba que o nome de todas as funções acima seguem o padrão <code>read_*</code>, onde a palavra presente no ponto <code><a href="https://rdrr.io/r/base/Arithmetic.html">*</a></code> corresponde a extensão que identifica o tipo de arquivo no qual a função é especializada. Nós sempre iniciamos qualquer uma das funções acima, pelo endereço até o arquivo que desejamos ler. Como exemplo inicial, eu possuo um arquivo CSV chamado <code>Censo_2010.csv</code>, que se encontra dentro da pasta <code>6 - Importacao</code>.</p>
<p></p>
<div class="sourceCode" id="cb276"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://readr.tidyverse.org">readr</a></span><span class="op">)</span>

<span class="va">Censo_2010</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2</a></span><span class="op">(</span><span class="st">"Parte 1/6 - Importacao/Censo_2010.csv"</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## ‐‐ Column specification ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
## cols(
## `Região metropolitana` = col_character(),
## `População residente` = col_double(),
## `População em área urbana` = col_double(),
## `População em área não urbanizada` = col_double(),
## `População em área isolada` = col_double(),
## `Área rural` = col_double(),
## `Aglomerado urbano` = col_double(),
## Povoado = col_double(),
## Núcleo = col_double(),
## `Outros aglomerados` = col_double(),
## `Código unidade` = col_double()
## )
</code></pre>
<p>Perceba também no exemplo acima, que eu salvo o resultado da função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code> em um objeto chamado <code>Censo_2010</code>. Isso é muito importante! Lembre-se sempre de salvar o resultado das funções <code>read_*</code> em algum objeto. Pois a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code> busca apenas ler o arquivo <code>Censo_2010.csv</code> e encaixar o seu conteúdo em uma tabela (ou um <code>data.frame</code>) do R. Ou seja, em nenhum momento, a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code> se preocupa em salvar os dados que ela coletou do arquivo <code>Censo_2010.csv</code>, em algum lugar que podemos acessar futuramente. É por essa razão, que eu salvo a tabela gerada pela função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code> em um objeto. Pois dessa forma, eu posso acessar novamente os dados que coletamos do arquivo <code>Censo_2010.csv</code>, através do objeto <code>Censo_2010</code>.</p>
<p></p>
<div class="sourceCode" id="cb278"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">Censo_2010</span></code></pre></div>
<pre><code>## # A tibble: 2,013 x 11
##    `Região metropol~ `População resid~ `População em ár~ `População em áre~
##    &lt;chr&gt;                         &lt;dbl&gt;             &lt;dbl&gt;              &lt;dbl&gt;
##  1 Manaus  AM                  2106322           1972885               3011
##  2 Homens                      1036676            964041               2018
##  3 Mulheres                    1069646           1008844                993
##  4 Careiro da Várzea             23930              1000                 NA
##  5 Homens                        12688               481                 NA
##  6 Mulheres                      11242               519                 NA
##  7 Iranduba                      40781             28979                 NA
##  8 Homens                        20996             14662                 NA
##  9 Mulheres                      19785             14317                 NA
## 10 Itacoatiara                   86839             57863                294
## # ... with 2,003 more rows, and 7 more variables:
## #   População em área isolada &lt;dbl&gt;, Área rural &lt;dbl&gt;,
## #   Aglomerado urbano &lt;dbl&gt;, Povoado &lt;dbl&gt;, Núcleo &lt;dbl&gt;,
## #   Outros aglomerados &lt;dbl&gt;, Código unidade &lt;dbl&gt;</code></pre>
<p></p>
<p>Mesmo que o arquivo <code>Censo_2010.csv</code> seja claramente um arquivo CSV, nós precisamos identificar qual o padrão que ele está adotando. Nos EUA, um arquivo CSV utiliza vírgulas (<code>,</code>) para separar os valores de cada coluna. Porém, pelo fato de nós, brasileiros, usarmos a vírgula para delimitar casas decimais em números reais, nós empregamos o padrão de um arquivo CSV adotado por alguns países europeus, que utilizam o ponto e vírgula (<code>;</code>) como separador. Logo abaixo, temos as linhas iniciais do arquivo <code>Censo_2010.csv</code> e, podemos rapidamente identificar que esse arquivo utiliza o padrão europeu. É por este motivo que eu utilizo a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code>, e não a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv()</a></code> para ler o arquivo.</p>
<pre><code>Manaus  AM;2106322;1972885;3011;;108160;;22266;;;30
Homens;1036676;964041;2018;;59024;;11593;;;30
Mulheres;1069646;1008844;993;;49136;;10673;;;30
Careiro da Várzea;23930;1000;;;21089;;1841;;;1301159
Homens;12688;481;;;11281;;926;;;1301159
Mulheres;11242;519;;;9808;;915;;;1301159</code></pre>
<p>Apesar de ser esse o padrão adotado por nós brasileiros, você enfrentará ocasiões em que o seu arquivo de texto possui separadores diferentes do esperado. Por exemplo, talvez os seus dados sejam separados por cifrões (<code><a href="https://rdrr.io/r/base/Extract.html">$</a></code>).</p>
<p></p>
<div class="sourceCode" id="cb281"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span> <span class="op">&lt;-</span> <span class="st">"Ano$Código$Dia$Valor
2020$P.A22$01$4230.45
2020$B.34$02$1250.28
2020$S.T4$03$3510.90"</span>

<span class="fu"><a href="https://rdrr.io/r/base/writeLines.html">writeLines</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></code></pre></div>
<pre><code>## Ano$Código$Dia$Valor
## 2020$P.A22$01$4230.45
## 2020$B.34$02$1250.28
## 2020$S.T4$03$3510.90</code></pre>
<p></p>
<p>Em casos como esse, você será obrigado a definir explicitamente o separador utilizado no arquivo. Para isso, você pode utilizar a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code>, que possui o argumento <code>delim</code>, onde podemos determinar o caractere que delimita as colunas no arquivo.</p>
<p></p>
<div class="sourceCode" id="cb283"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">t</span>, delim <span class="op">=</span> <span class="st">"$"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 4
##     Ano Código Dia   Valor
##   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;
## 1  2020 P.A22  01    4230.
## 2  2020 B.34   02    1250.
## 3  2020 S.T4   03    3511.</code></pre>
<p></p>
<p>Como um outro exemplo, arquivos TSV são simplificadamente um arquivo CSV que utiliza um caractere especial de tabulação como separador, representado pelos caracteres <code>\t</code>. Ou seja, nós podemos recriar a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_tsv()</a></code> através da função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code>, ao configurarmos o argumento <code>delim</code>, como no exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb285"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span> <span class="op">&lt;-</span> <span class="st">"Ano\tCódigo\tDia\tValor
2020\tP.A22\t01\t4.230,45
2020\tB.34\t02\t1.250,28
2020\tS.T4\t03\t3.510,90"</span>

<span class="fu"><a href="https://rdrr.io/r/base/writeLines.html">writeLines</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></code></pre></div>
<pre><code>## Ano  Código  Dia Valor
## 2020 P.A22   01  4.230,45
## 2020 B.34    02  1.250,28
## 2020 S.T4    03  3.510,90</code></pre>
<div class="sourceCode" id="cb287"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">t</span>, delim <span class="op">=</span> <span class="st">"\t"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 4
##     Ano Código Dia   Valor
##   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;
## 1  2020 P.A22  01     4.23
## 2  2020 B.34   02     1.25
## 3  2020 S.T4   03     3.51</code></pre>
<p></p>
<div id="definindo-os-tipos-de-dados-em-cada-coluna" class="section level3" number="3.6.1">
<h3>
<span class="header-section-number">3.6.1</span> Definindo os tipos de dados em cada coluna<a class="anchor" aria-label="anchor" href="#definindo-os-tipos-de-dados-em-cada-coluna"><i class="fas fa-link"></i></a>
</h3>
<p>Caso nós não informarmos em qualquer uma das funções <code>read_*</code>, qual o tipo de dado contido em cada coluna de nosso arquivo de texto, essas funções vão por padrão, ler as 1000 primeiras linhas de seu arquivo, e com base nessas 1000 linhas, vão tentar adivinhar qual o tipo de dado contido em cada coluna. Após esse processo, a função <code>read_*</code> vai ler as linhas restantes do arquivo, se baseando nos tipos identificados pela função.</p>
<p>Tendo isso em mente, todas as funções <code>read_*</code> sempre nos fornecem uma pequena descrição, contendo a especificação de cada coluna (<code>Column specification</code>). Essa descrição está nos informando justamente qual foi o “chute” da função, ou qual o tipo de dado que a função utilizou em cada coluna. Veja no exemplo abaixo, que a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv()</a></code> interpretou que as colunas <code>Título</code> e <code>Autor</code> continham dados textuais e, por isso, utilizou colunas do tipo <code>character</code> (<code><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_character()</a></code>) para guardar esses dados. Por outro lado, a função percebeu que a coluna <code>Preço</code> continha dados numéricos e, por essa razão, preferiu utilizar uma coluna do tipo <code>double</code> (<code><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_double()</a></code>) para alocar esses dados na tabela.</p>
<p></p>
<div class="sourceCode" id="cb289"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">livros</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="st">"C:/Users/Pedro/Documents/Lista de compras/livros.txt"</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>-- Column specification --------------------------------
cols(
  Título = col_character(),
  Autor = col_character(),
  Preço = col_double()
)</code></pre>
<p>Isso é uma característica importante e útil das funções <code>read_*</code>, pois podemos contar com esse sistema para definir os tipos de cada coluna do arquivo. Porém, esse é um sistema que se torna cada vez mais frágil a medida em que o tamanho de nosso arquivo aumenta. Pois essas 1000 primeiras linhas começam a representar uma parte cada vez menor do arquivo e, portanto, as suas chances de demonstrarem fielmente os tipos de dados presentes em todo arquivo, ficam cada vez menores.</p>
<p>Por isso, é provável que em algum momento, você terá de contornar esse comportamento, e definir explicitamente os tipos de dados contidos em cada coluna por meio do argumento <code>col_types</code> de qualquer função <code>read_*</code>.</p>
<p>Para construirmos essa definição, nós utilizamos a função <code><a href="https://readr.tidyverse.org/reference/cols.html">cols()</a></code> e suas variantes <code>col_*</code>. Dentro da função <code><a href="https://readr.tidyverse.org/reference/cols.html">cols()</a></code>, precisamos igualar o nome da coluna presente no arquivo de texto à função <code>col_*</code> que corresponde ao tipo de dado desejado. No exemplo abaixo, ao igualar as colunas <code>year</code>, <code>month</code> e <code>day</code> à função <code><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_integer()</a></code>, eu estou definindo que essas colunas devem ser interpretadas como colunas do tipo <code>integer</code>. Enquanto isso, ao igualar as colunas <code>carrier</code> e <code>tailnum</code> à função <code><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_character()</a></code>, eu estou requisitando que essas colunas sejam lidas como colunas do tipo <code>character</code>.</p>
<p>Por outro lado, a função <code><a href="https://readr.tidyverse.org/reference/cols.html">cols()</a></code> nos oferece um atalho chamado <code>.default</code>. Mediante esse atalho, podemos nos referir a todas as colunas do arquivo de uma vez. Por isso, no exemplo abaixo, ao igualar esse atalho à função <code><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_double()</a></code>, eu estou dizendo à função <code><a href="https://readr.tidyverse.org/reference/cols.html">cols()</a></code>, que qualquer outra coluna do arquivo que não tenha sido definida explicitamente na função <code><a href="https://readr.tidyverse.org/reference/cols.html">cols()</a></code>, deve ser interpretada como uma coluna do tipo <code>double</code>. Por este motivo, as colunas <code>dep_time</code> e <code>dep_delay</code> (e várias outras), que não foram configuradas explicitamente na função <code><a href="https://readr.tidyverse.org/reference/cols.html">cols()</a></code>, acabaram sendo interpretadas como colunas do tipo <code>double</code>.</p>
<p></p>
<div class="sourceCode" id="cb291"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tipos_col</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/cols.html">cols</a></span><span class="op">(</span>
  .default <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_double</a></span><span class="op">(</span><span class="op">)</span>,
  year <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_integer</a></span><span class="op">(</span><span class="op">)</span>,
  month <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_integer</a></span><span class="op">(</span><span class="op">)</span>,
  day <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_integer</a></span><span class="op">(</span><span class="op">)</span>,
  carrier <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_character</a></span><span class="op">(</span><span class="op">)</span>,
  tailnum <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_character</a></span><span class="op">(</span><span class="op">)</span>,
  origin <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_character</a></span><span class="op">(</span><span class="op">)</span>,
  dest <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_atomic.html">col_character</a></span><span class="op">(</span><span class="op">)</span>,
  time_hour <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/parse_datetime.html">col_datetime</a></span><span class="op">(</span>format <span class="op">=</span> <span class="st">""</span><span class="op">)</span>
<span class="op">)</span>

<span class="va">flights</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2</a></span><span class="op">(</span>
  <span class="st">"flights.csv"</span>,
  col_types <span class="op">=</span> <span class="va">tipos_col</span>
<span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb292"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">flights</span></code></pre></div>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;dbl&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;dbl&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p></p>
</div>
<div id="sec:readr_locale" class="section level3" number="3.6.2">
<h3>
<span class="header-section-number">3.6.2</span> Compreendendo o argumento <code>locale</code><a class="anchor" aria-label="anchor" href="#sec:readr_locale"><i class="fas fa-link"></i></a>
</h3>
<p>O argumento <code>locale</code> está presente em todas as funções <code>read_*</code>, e é responsável por definir as especificações do arquivo de texto que mudam de país para país. No Brasil, por exemplo, datas são definidas no formato “Dia/Mês/Ano,” enquanto nos EUA, datas se encontram no formato “Ano-Mês-Dia.” No Brasil, utilizamos vírgulas para separar a parte decimal de um número, enquanto nos EUA, essa separação é definida por um ponto final. Uma diferença ainda mais importante, se encontra no sistema de <em>encoding</em> adotado, que varia de maneira muito violenta ao longo dos países.</p>
<p>O R, é uma linguagem centrada nos padrões americanos, por isso, sempre que você estiver tentando ler algum arquivo de texto que não se encaixa de alguma forma neste padrão, você terá que ajustar o <code>locale</code> da função <code>read_*</code> que você está utilizando. Algumas funções já preveêm e adotam essas diferenças, um exemplo disso, é a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code>, que é na verdade um atalho para o padrão adotado por nós brasileiros, e por alguns países europeus.</p>
<p>Como exemplo inicial, vamos tentar ler o arquivo <code>pib_per_capita.csv</code>, que novamente se encontra dentro da pasta <code>6 - Importacao</code>. Dessa vez, vamos utilizar a função geral do pacote, a <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code>. Lembre-se que nessa função, você deve sempre indicar qual o caractere separador do arquivo, através do argumento <code>delim</code>.</p>
<p></p>
<div class="sourceCode" id="cb294"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pib</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="st">"Parte 1/6 - Importacao/pib_per_capita.csv"</span>, delim <span class="op">=</span> <span class="st">";"</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb295"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pib</span></code></pre></div>
<pre><code>## # A tibble: 853 x 7
##    IBGE2   IBGE `Munic\xedpio`        `Popula\xe7\xe3o`   Ano PIB          
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                             &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        
##  1    10 310010 "Abadia dos Dourados"              6972  2017 33.389.769,00
##  2    20 310020 "Abaet\xe9"                       23223  2017 96.201.158,00
##  3    30 310030 "Abre Campo"                      13465  2017 29.149.429,00
##  4    40 310040 "Acaiaca"                          3994  2017 2.521.892,00 
##  5    50 310050 "A\xe7ucena"                       9575  2017 15.250.077,00
##  6    60 310060 "\xc1gua Boa"                     13600  2017 29.988.906,00
##  7    70 310070 "\xc1gua Comprida"                 2005  2017 74.771.408,00
##  8    80 310080 "Aguanil"                          4448  2017 15.444.038,00
##  9    90 310090 "\xc1guas Formosas"               19166  2017 11.236.696,00
## 10   100 310100 "\xc1guas Vermelhas"              13477  2017 48.088.397,00
## # ... with 843 more rows, and 1 more variable: PIB per capita &lt;chr&gt;</code></pre>
<p></p>
<p>Algo deu errado durante a importação, pois as colunas <code>PIB</code> e <code>PIB per capita</code> foram importadas como colunas de texto (<code>character</code>), sendo que elas são claramente numéricas. Em momentos como esse, é interessante que você consulte as primeiras linhas do arquivo, para compreender melhor a sua estrutura e identificar o que deu errado. Por isso, temos logo abaixo, as três primeiras linhas do arquivo <code>pib_per_capita.csv</code>. Perceba que os dois últimos valores em cada linha, representam os dados das colunas <code>PIB</code> e <code>PIB per capita</code>. Ao olharmos, por exemplo, para o número 33.389.769,00 nós podemos identificar qual o problema que está ocorrendo em nossa importação.</p>
<pre><code>10;310010;Abadia dos Dourados;6972;2017;33.389.769,00;4.789,12
20;310020;Abaeté;23223;2017;96.201.158,00;4.142,49
30;310030;Abre Campo;13465;2017;29.149.429,00;2.164,83</code></pre>
<p>O motivo para tal conflito, se encontra justamente no uso do ponto final como separador de milhares, e da vírgula para marcar a parte decimal dos números dispostos nas colunas <code>PIB</code> e <code>PIB_per_capita</code>. Ou seja, como não informamos nada sobre as particularidades do arquivo, a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code> está imaginando que o arquivo <code>pib_per_capita.csv</code> se encontra no padrão americano. Por isso, nós precisamos fornecer essas informações à função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code> para que esse problema seja corrigido, através do argumento <code>locale</code>.</p>
<p>Na verdade, tais informações são fornecidas através da função <code><a href="https://readr.tidyverse.org/reference/locale.html">locale()</a></code>, como no exemplo abaixo. No nosso caso, precisamos ajustar o caractere responsável por separar os milhares, que corresponde ao argumento <code>grouping_mark</code>, e o caractere que defini a parte decimal dos nossos números, que corresponde ao argumento <code>decimal_mark</code> da função <code><a href="https://readr.tidyverse.org/reference/locale.html">locale()</a></code>. Perceba no exemplo abaixo, que ao provermos essas informações à função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code> através da função <code><a href="https://readr.tidyverse.org/reference/locale.html">locale()</a></code>, as colunas <code>PIB</code> e <code>PIB per capita</code> foram corretamente interpretadas como colunas numéricas (<code>double</code>).</p>
<p></p>
<div class="sourceCode" id="cb298"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pib</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span>
  <span class="st">"Parte 1/6 - Importacao/pib_per_capita.csv"</span>,
  delim <span class="op">=</span> <span class="st">";"</span>,
  locale <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/locale.html">locale</a></span><span class="op">(</span>decimal_mark <span class="op">=</span> <span class="st">","</span>, grouping_mark <span class="op">=</span> <span class="st">"."</span><span class="op">)</span>
<span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb299"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pib</span></code></pre></div>
<pre><code>## # A tibble: 853 x 7
##    IBGE2   IBGE `Munic\xedpio`        `Popula\xe7\xe3o`   Ano      PIB
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                             &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
##  1    10 310010 "Abadia dos Dourados"              6972  2017 33389769
##  2    20 310020 "Abaet\xe9"                       23223  2017 96201158
##  3    30 310030 "Abre Campo"                      13465  2017 29149429
##  4    40 310040 "Acaiaca"                          3994  2017  2521892
##  5    50 310050 "A\xe7ucena"                       9575  2017 15250077
##  6    60 310060 "\xc1gua Boa"                     13600  2017 29988906
##  7    70 310070 "\xc1gua Comprida"                 2005  2017 74771408
##  8    80 310080 "Aguanil"                          4448  2017 15444038
##  9    90 310090 "\xc1guas Formosas"               19166  2017 11236696
## 10   100 310100 "\xc1guas Vermelhas"              13477  2017 48088397
## # ... with 843 more rows, and 1 more variable: PIB per capita &lt;dbl&gt;</code></pre>
<p></p>
<p>Apesar de resolvermos o problema gerado anteriormente nas colunas <code>PIB</code> e <code>PIB per capita</code>, ainda há algo que precisamos corrigir nessa importação. O problema remanescente, se encontra em colunas textuais e no título de algumas colunas. Perceba que alguns desses textos (especialmente em letras acentuadas) estão esquisitos. Por exemplo, a coluna que deveria se chamar <code>Município</code> está denominada como <code>Munic\xedpio</code>.</p>
<p>Esse é um típico problema de <em>encoding</em>, onde a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code> imagina que o arquivo <code>pib_per_capita.csv</code> se encontra em um sistema de <em>encoding</em> específico, quando na verdade, ele se encontra em um outro sistema. Ou seja, tudo o que precisamos fazer, é informar qual o sistema correto de leitura do arquivo à função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim()</a></code>. Por padrão, todas as funções do pacote <code>readr</code> vão pressupor que os seus arquivos se encontram no sistema UTF-8 de <em>encoding</em>. Porém, a maioria dos computadores brasileiros utilizam um outro sistema, sendo ele, o sistema ISO-8859-1, que também é conhecido por Latin1.</p>
<p>Nas funções do pacote <code>readr</code>, nós podemos definir o <em>encoding</em> de leitura, através do argumento <code>encoding</code> presente na função <code><a href="https://readr.tidyverse.org/reference/locale.html">locale()</a></code>. Nesse argumento, você pode fornecer tanto o nome oficial do sistema (<code>ISO-8859-1</code>) quanto o seu apelido (<code>Latin1</code>). Repare no exemplo abaixo, que ao definirmos o <em>encoding</em> correto de leitura, os problemas em elementos textuais foram resolvidos. Para ter uma melhor compreensão desse problema, por favor leia a seção <a href="importando-e-exportando-dados-com-o-r.html#sec:encoding"><em>Encoding</em> de caracteres</a>.</p>
<p></p>
<div class="sourceCode" id="cb301"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pib</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span>
  <span class="st">"Parte 1/6 - Importacao/pib_per_capita.csv"</span>,
  delim <span class="op">=</span> <span class="st">";"</span>,
  locale <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/locale.html">locale</a></span><span class="op">(</span>
    decimal_mark <span class="op">=</span> <span class="st">","</span>,
    grouping_mark <span class="op">=</span> <span class="st">"."</span>,
    encoding <span class="op">=</span> <span class="st">"Latin1"</span>
  <span class="op">)</span>
<span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb302"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pib</span></code></pre></div>
<pre><code>## # A tibble: 853 x 7
##    IBGE2   IBGE Município          População   Ano     PIB `PIB per capita`
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;            &lt;dbl&gt;
##  1    10 310010 Abadia dos Dourad~      6972  2017  3.34e7            4789.
##  2    20 310020 Abaeté                 23223  2017  9.62e7            4142.
##  3    30 310030 Abre Campo             13465  2017  2.91e7            2165.
##  4    40 310040 Acaiaca                 3994  2017  2.52e6             631.
##  5    50 310050 Açucena                 9575  2017  1.53e7            1593.
##  6    60 310060 Água Boa               13600  2017  3.00e7            2205.
##  7    70 310070 Água Comprida           2005  2017  7.48e7           37292.
##  8    80 310080 Aguanil                 4448  2017  1.54e7            3472.
##  9    90 310090 Águas Formosas         19166  2017  1.12e7             586.
## 10   100 310100 Águas Vermelhas        13477  2017  4.81e7            3568.
## # ... with 843 more rows</code></pre>
<p></p>
</div>
<div id="outras-configurações-envolvendo-linhas-e-colunas" class="section level3" number="3.6.3">
<h3>
<span class="header-section-number">3.6.3</span> Outras configurações envolvendo linhas e colunas<a class="anchor" aria-label="anchor" href="#outras-configura%C3%A7%C3%B5es-envolvendo-linhas-e-colunas"><i class="fas fa-link"></i></a>
</h3>
<p>Nessa seção, vamos utilizar como exemplo base, o arquivo CSV que forma o objeto <code>t</code> abaixo. Perceba que esse arquivo utiliza pontos e vírgulas como separador, e que ele não possui cabeçalho aparente. Ou seja, aparentemente os nomes das colunas não estão definidas no arquivo.</p>
<p></p>
<div class="sourceCode" id="cb304"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span> <span class="op">&lt;-</span> <span class="st">"2020;P.A22;01;4230.45
2020;B.34;02;1250.28
2020;S.T4;03;3510.90
2020;B.35;04;1200.25
2020;F.J4;05;1542.20
2020;A.12;06;9854.09
2020;B.Q2;07;7654.10
2020;G.T4;08;4328.36
2020;E.7A;09;2310.25"</span>

<span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">t</span>, delim <span class="op">=</span> <span class="st">";"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 8 x 4
##   `2020` P.A22 `01`  `4230.45`
##    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;
## 1   2020 B.34  02        1250.
## 2   2020 S.T4  03        3511.
## 3   2020 B.35  04        1200.
## 4   2020 F.J4  05        1542.
## 5   2020 A.12  06        9854.
## 6   2020 B.Q2  07        7654.
## 7   2020 G.T4  08        4328.
## 8   2020 E.7A  09        2310.</code></pre>
<p></p>
<p>Por padrão, as funções <code>read_*</code> utilizam a primeira linha do arquivo para construir o nome de cada coluna presente. Mas se você deseja evitar esse comportamento, você pode configurar o argumento <code>col_names</code> para <code>FALSE</code>. Dessa forma, a função <code>read_*</code> vai gerar nomes genéricos para cada coluna. Uma outra alternativa é fornecer um vetor ao argumento <code>col_names</code>, contendo os nomes de cada coluna na ordem em que elas aparecem no arquivo, como no exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb306"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">col</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ano"</span>, <span class="st">"Código"</span>, <span class="st">"Dia"</span>, <span class="st">"Valor"</span><span class="op">)</span>

<span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">t</span>, delim <span class="op">=</span> <span class="st">";"</span>, col_names <span class="op">=</span> <span class="va">col</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 9 x 4
##     Ano Código Dia   Valor
##   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;
## 1  2020 P.A22  01    4230.
## 2  2020 B.34   02    1250.
## 3  2020 S.T4   03    3511.
## 4  2020 B.35   04    1200.
## 5  2020 F.J4   05    1542.
## 6  2020 A.12   06    9854.
## 7  2020 B.Q2   07    7654.
## 8  2020 G.T4   08    4328.
## 9  2020 E.7A   09    2310.</code></pre>
<p></p>
<p>Além disso, as funções <code>read_*</code> nos permite determinar o número máximo de linhas que desejamos ler de um arquivo, através do argumento <code>n_max</code>. Logo, mesmo que um arquivo de texto qualquer possua 500 mil linhas, nós podemos ler apenas as 10 primeiras linhas desse arquivo, ao configurarmos esse argumento. No exemplo abaixo, eu estou lendo apenas as 5 primeiras linhas do arquivo <code>t</code>.</p>
<p></p>
<div class="sourceCode" id="cb308"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">t</span>, delim <span class="op">=</span> <span class="st">";"</span>, n_max <span class="op">=</span> <span class="fl">5</span>, col_names <span class="op">=</span> <span class="va">col</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 5 x 4
##     Ano Código Dia   Valor
##   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;
## 1  2020 P.A22  01    4230.
## 2  2020 B.34   02    1250.
## 3  2020 S.T4   03    3511.
## 4  2020 B.35   04    1200.
## 5  2020 F.J4   05    1542.</code></pre>
<p></p>
<p>Para mais, também podemos indiretamente definir a linha pela qual a função deve iniciar a leitura, por meio do argumento <code>skip</code>. Nesse argumento, você vai determinar quantas linhas do início do arquivo devem ser desconsideradas pela função. Portanto, no exemplo abaixo, eu estou ignorando as 2 primeiras linhas do arquivo <code>t</code>.</p>
<p></p>
<div class="sourceCode" id="cb310"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">t</span>, delim <span class="op">=</span> <span class="st">";"</span>, skip <span class="op">=</span> <span class="fl">2</span>, col_names <span class="op">=</span> <span class="va">col</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 7 x 4
##     Ano Código Dia   Valor
##   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;
## 1  2020 S.T4   03    3511.
## 2  2020 B.35   04    1200.
## 3  2020 F.J4   05    1542.
## 4  2020 A.12   06    9854.
## 5  2020 B.Q2   07    7654.
## 6  2020 G.T4   08    4328.
## 7  2020 E.7A   09    2310.</code></pre>
<p></p>
</div>
</div>
<div id="sec:estudo_pnad_continua" class="section level2" number="3.7">
<h2>
<span class="header-section-number">3.7</span> Um estudo de caso: lendo os microdados da PNAD Contínua com <code>read_fwf()</code><a class="anchor" aria-label="anchor" href="#sec:estudo_pnad_continua"><i class="fas fa-link"></i></a>
</h2>
<p>A PNAD Contínua é uma pesquisa amostral, e vem sendo realizada desde janeiro de 2012 pelo Instituto Brasileiro de Geografia e Estatística <span class="citation">(<a href="refer%C3%AAncias.html#ref-ibge_pnad" role="doc-biblioref"><em>Pesquisa Nacional Por Amostra de Domicílios Contínua: Notas técnicas</em> 2019</a>)</span>. Os principais indicadores periódicos do mercado de trabalho são extraídos dessa pesquisa, e por isso, ela representa uma das principais fontes de informação econômica e demográfica do país. Nessa seção, vamos utilizar as funções do pacote <code>readr</code> para importarmos os microdados da divulgação trimestral dessa pesquisa para o R.</p>
<p>A PNAD Contínua, é organizada em três pesquisas que possuem periodicidades diferentes, são elas: PNAD Contínua Anual, PNAD Contínua Mensal e PNAD Contínua Trimestral. Em outras palavras, ao longo do ano, existem três pesquisas da PNAD Contínua, sendo construídas ao mesmo tempo. Porém, essas três pesquisas são divulgadas em períodos diferentes do ano, empregam níveis de agregação diferentes, e buscam medir variáveis demográficas diferentes. Nessa seção, vamos focar nos microdados da divulgação trimestral da PNAD Contínua, sendo essa a principal parte da PNAD Contínua, e a mais utilizada. Você pode encontrar os microdados da PNAD Contínua Trimestral, na <a href="https://www.ibge.gov.br/estatisticas/sociais/trabalho/9171-pesquisa-nacional-por-amostra-de-domicilios-continua-mensal.html?=&amp;t=microdados">página oficial da pesquisa</a>, ou no endereço da <a href="ftp://ftp.ibge.gov.br/Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Trimestral/">página do servidor</a>, onde esses microdados estão hospedados.</p>
<p>Para que você possa acompanhar os comandos mostrados nessa seção, lembre-se de chamar pelo pacote <code>readr</code>, ou pelo <code>tidyverse</code> (que contém o pacote <code>readr</code>). Como vamos utilizar o operador <em>pipe</em> (<code><a href="https://forcats.tidyverse.org/reference/pipe.html">%&gt;%</a></code>) ao longo desse capítulo, é possível que você também tenha que chamar pelo pacote <code>magrittr</code>.</p>
<p></p>
<div class="sourceCode" id="cb312"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://readr.tidyverse.org">readr</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://magrittr.tidyverse.org">magrittr</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span></code></pre></div>
<p></p>
<div id="conhecendo-a-estrutura-dos-microdados" class="section level3" number="3.7.1">
<h3>
<span class="header-section-number">3.7.1</span> Conhecendo a estrutura dos microdados<a class="anchor" aria-label="anchor" href="#conhecendo-a-estrutura-dos-microdados"><i class="fas fa-link"></i></a>
</h3>
<p>Antes de importarmos esses dados, precisamos conhecer a estrutura do arquivo que contém esses dados. Ou seja, precisamos saber qual a extensão desse arquivo, e de que maneira os dados estão organizados dentro desse arquivo. Como exemplo, eu fui até a <a href="https://www.ibge.gov.br/estatisticas/sociais/trabalho/9171-pesquisa-nacional-por-amostra-de-domicilios-continua-mensal.html?=&amp;t=microdados">página oficial da pesquisa</a>, e baixei os microdados do primeiro trimestre de 2020. O arquivo veio compactado (<code>.zip</code>), e por isso, eu o descompactei para que tivéssemos acesso ao arquivo bruto que contém os microdados, mostrado na figura 3.7.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-160"></span>
<img src="Figuras/arquivos_PNAD.png" alt="Arquivo contendo os microdados da PNAD Contínua - 1° Trimestre de 2020" width="75%"><p class="caption">
Figure 3.7: Arquivo contendo os microdados da PNAD Contínua - 1° Trimestre de 2020
</p>
</div>
<p></p>
<p>Como podemos ver pela figura 3.7, o arquivo é um simples documento de texto (extensão <code>.txt</code>), e todas as funções de importação do pacote <code>readr</code> são capazes de ler este tipo de arquivo. Porém, ainda temos que identificar o tipo, ou a estrutura desse documento de texto. Em outras palavras, precisamos compreender como esses dados estão organizados dentro desse arquivo. Será que os valores de cada coluna são separados por vírgulas (<code>.csv</code>)? por ponto e vírgula (<code>.csv</code>)? por tabulação (<code>.tsv</code>)? Para descobrirmos, precisamos dar uma olhada no arquivo.</p>
<p>Porém, o tamanho do arquivo é considerável (aproximadamente 222 MB). Isso nos dá a entender que a base de dados contida nesse arquivo, é relativamente grande. Como nós queremos dar apenas uma olhada, talvez seja mais interessante lermos apenas as 5 primeiras linhas do arquivo. As funções de importação do pacote <code>readr</code>, geralmente possuem um argumento <code>n_max</code>, onde podemos configurar o número máximo de linhas a serem lidas do arquivo. Portanto, ao aplicarmos a função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv()</a></code> abaixo, podemos ver as cinco primeiras linhas do arquivo. A primeira coisa que podemos abstrair do resultado, é que o arquivo de texto parece uma muralha de números, e aparentemente não se encaixa em nenhuma das hipóteses anteriores.</p>
<p></p>
<div class="sourceCode" id="cb313"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span>
  <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/PNADC_012020.txt"</span>,
  n_max <span class="op">=</span> <span class="fl">5</span>
<span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## # A tibble: 5 x 1
##   `202011111  11000001611100110107511000098.75663631000139.734222300005349~
##   &lt;chr&gt;                                              
## 1 202011111  11000001611100110107511000098.75663631000139.7342223000053491~
## 2 202011111  11000001611100110107511000098.75663631000139.7342223000053491~
## 3 202011111  11000001611100110107511000098.75663631000139.7342223000053491~
## 4 202011111  11000001611100110307511000098.75663631000139.7342223000053491~
## 5 202011111  11000001611100110307511000098.75663631000139.7342223000053491~</code></pre>
<p>Esse é um exemplo de arquivo chamado de <em>fixed width file</em> (<code>.fwf</code>), ou “arquivo de largura fixa.” Provavelmente, o principal motivo pelo qual o IBGE decidiu adotar esse formato de arquivo na divulgação de seus dados, está no fato de que arquivos desse tipo, são muito mais rápidos de se ler em programas, do que um arquivo CSV tradicional. Pois os valores de cada coluna em um arquivo <em>fixed width file</em>, se encontram sempre nos mesmos lugares ao longo do arquivo. Em contrapartida, esse tipo de arquivo, torna a sua vida mais difícil, pois você precisa especificar a largura, ou o número de caracteres presentes em cada coluna, para a função que será responsável por ler esse arquivo.</p>
<p>Ou seja, nesse tipo arquivo, não há qualquer tipo de valor ou especificação responsável por delimitar as colunas da base de dados. O arquivo simplesmente contém todos os valores, um do lado do outro. Será sua tarefa, dizer ao programa (no nosso caso, o R) quantos caracteres estão presentes em cada coluna, ou em outras palavras, definir em quais caracteres estão as “quebras” de colunas.</p>
<p>Isso significa, que você irá precisar de um dicionário desses dados, contendo as especificações de cada coluna dessa base de dados. No caso da PNAD Contínua, são oferecidos: 1) o dicionário das variáveis (geralmente em uma planilha do Excel, com extensão <code>.xls</code>), que contém uma descrição completa de cada variável (ou coluna) presente na base; 2) e o arquivo de texto <code>input</code>, que contém as especificações para a importação da base. Você pode baixar esses arquivos separadamente, na <a href="ftp://ftp.ibge.gov.br/Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Trimestral/">página do servidor</a> em que os microdados são hospedados, ou então, você pode baixar um ZIP (<code>Dicionario_input.zip</code>) desses arquivos neste <a href="https://www.ibge.gov.br/estatisticas/downloads-estatisticas.html?caminho=Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Trimestral/Microdados/Documentacao">link</a>. Logo abaixo, na figura 3.8, temos uma foto desses arquivos em meu computador.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-162"></span>
<img src="Figuras/arquivos_input_pnad.png" alt="Arquivos input e dicionário da PNAD Contínua" width="75%"><p class="caption">
Figure 3.8: Arquivos input e dicionário da PNAD Contínua
</p>
</div>
<p></p>
<p>Entretanto, para surpresa de muitos, o arquivo de texto <code>input</code> (que geralmente assume o nome de <code>input_PNADC_trimestral.txt</code>), é na verdade, um <em>script</em> de importação utilizado pelo programa estatístico SAS<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;a href="https://www.sas.com/en_us/home.html" class="uri"&gt;https://www.sas.com/en_us/home.html&lt;/a&gt;&lt;/p&gt;'><sup>9</sup></a>. O SAS é um programa estatístico pago, parecido com o seu concorrente SPSS<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;a href="https://www.ibm.com/products/spss-statistics" class="uri"&gt;https://www.ibm.com/products/spss-statistics&lt;/a&gt;&lt;/p&gt;'><sup>10</sup></a>, sendo um programa mais popular no mercado americano. Logo, se você estivesse trabalhando com o programa SAS, você já teria um <em>script</em> pronto para importar os microdados da PNAD Contínua. Como não é o nosso caso, temos que extrair, a partir desse <em>script</em> de SAS, as especificações de cada coluna.</p>
</div>
<div id="extraindo-especificações-de-um-script-sas" class="section level3" number="3.7.2">
<h3>
<span class="header-section-number">3.7.2</span> Extraindo especificações de um <em>script</em> SAS<a class="anchor" aria-label="anchor" href="#extraindo-especifica%C3%A7%C3%B5es-de-um-script-sas"><i class="fas fa-link"></i></a>
</h3>
<p>Como veremos mais a frente, extrair as especificações desse <em>script</em> é uma tarefa simples, e existem hoje, diversas ferramentas que podemos utilizar para rapidamente extraírmos essas informações do <em>script</em>, sem a necessidade de um trabalho manual. Porém, antes de partirmos para a prática, precisamos primeiro, compreender a estrutura do <em>script</em> de SAS, presente nesse arquivo <em>input</em> (<code>input_PNADC_trimestral</code>). Na figura 3.9, temos um resumo que descreve essa estrutura.</p>
<p>O <em>script</em>, ou mais especificamente, os comandos que definem a importação dos dados, se inicia pelo termo <code>input</code>, logo, estamos interessados em todas as configurações feitas após esse termo. As especificações de cada coluna, são compostas por 3 itens principais: 1) a posição inicial dessa coluna (ou a posição do caractere que inicia essa coluna); 2) o nome dessa coluna; e 3) a largura dessa coluna, ou em outras palavras, a quantidade de caracteres presentes em cada linha dessa coluna. Para o nosso objetivo, precisamos extrair os dois últimos componentes (o nome e a largura da coluna), além de definirmos se essa coluna é numérica ou textual, que é determinado pela presença ou não de um cifrão (<code><a href="https://rdrr.io/r/base/Extract.html">$</a></code>) ao lado da largura da coluna, no <em>script</em>.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-163"></span>
<img src="Figuras/estrutura_script_sas.png" alt="Resumo da estrutura de um script de importação do SAS" width="85%"><p class="caption">
Figure 3.9: Resumo da estrutura de um script de importação do SAS
</p>
</div>
<p></p>
<p>A melhor forma de organizarmos essas especificações, é criarmos uma tabela, onde cada linha corresponde a uma coluna dos microdados, e cada coluna dessa tabela contém uma das especificações (nome da coluna, largura da coluna, é numérica ou textual?) de cada coluna dos microdados. Para construir essa tabela, eu costumo utilizar macros de um programa de edição de texto (como o Notepad++<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;a href="https://notepad-plus-plus.org/" class="uri"&gt;https://notepad-plus-plus.org/&lt;/a&gt;&lt;/p&gt;'><sup>11</sup></a>) sobre o arquivo <code>input</code> (<code>input_PNADC_trimestral.txt</code>), de forma a eliminar os textos irrelevantes, e arrumar as especificações na estrutura de um arquivo CSV (<code>.csv</code>). Dessa forma, eu posso importar esse arquivo CSV resultante para o R, e adquirir a tabela que desejo. Como um guia, você pode ter acesso a esse arquivo CSV, através da cópia que deixei no .</p>
<p>Portanto, após extrair as especificações de cada coluna do arquivo <code>input</code>, eu tenho como resultado, um arquivo CSV chamado <code>widths.txt</code>, que eu posso ler através da função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv()</a></code>. Veja pelo resultado abaixo, que eu defini três colunas nesse arquivo CSV. A coluna <code>variavel</code> possui os nomes da colunas, na ordem em que elas aparecem no <em>script</em> do arquivo <code>input</code>, e portanto, nos microdados. A coluna <code>width</code> possui o número de caracteres presentes em cada uma dessas colunas. Já a coluna <code>char</code>, possui um valor lógico, indicando se os dados contidos nessa coluna, devem ser interpretados como texto (<code>TRUE</code>), ou como números (<code>FALSE</code>).</p>
<p></p>
<div class="sourceCode" id="cb315"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">col_width</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span>
  <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/widths.txt"</span>, 
  col_names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"variavel"</span>, <span class="st">"width"</span>, <span class="st">"char"</span><span class="op">)</span>
<span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## -- Column specification --------------------------------
## cols(
##   variavel = col_character(),
##   width = col_double(),
##   char = col_logical()
## )</code></pre>
<p></p>
<div class="sourceCode" id="cb317"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">col_width</span></code></pre></div>
<p></p>
<pre><code>## # A tibble: 217 x 3
##    variavel  width char 
##    &lt;chr&gt;     &lt;dbl&gt; &lt;lgl&gt;
##  1 Ano           4 TRUE 
##  2 Trimestre     1 TRUE 
##  3 UF            2 TRUE 
##  4 Capital       2 TRUE 
##  5 RM_RIDE       2 TRUE 
##  6 UPA           9 TRUE 
##  7 Estrato       7 TRUE 
##  8 V1008         2 TRUE 
##  9 V1014         2 TRUE 
## 10 V1016         1 TRUE 
## # ... with 207 more rows</code></pre>
</div>
<div id="o-pacote-sascii-como-um-atalho-útil" class="section level3" number="3.7.3">
<h3>
<span class="header-section-number">3.7.3</span> O pacote <code>SAScii</code> como um atalho útil<a class="anchor" aria-label="anchor" href="#o-pacote-sascii-como-um-atalho-%C3%BAtil"><i class="fas fa-link"></i></a>
</h3>
<p>O pacote <code>SAScii</code> nos oferece um conjunto de funções voltadas para a importação de arquivos <em>fixed width file</em>. Porém, dentre as suas funcionalidades, o pacote também nos oferece uma função capaz de converter <em>scripts</em> de importação do programa SAS, e extrair as especificações de cada coluna em um <code>data.frame</code>. Ou seja, podemos utilizar a função <code><a href="https://rdrr.io/pkg/SAScii/man/parse.SAScii.html">parse.SAScii()</a></code> para extraírmos as especificações de cada coluna do <em>script</em> presente no arquivo <code>input</code>.</p>
<p>Essa função é bem simples, e possui dois argumentos principais: 1) <code>sas_ri</code>, o endereço até o arquivo contendo o <em>script</em> de SAS a ser convertido; 2) <code>beginline</code>, a linha do arquivo em que o <em>script</em> de importação se inicia, ou em outras palavras, a linha do <em>script</em> onde o termo <code>input</code> aparece. Como podemos ver pela figura 3.10, eu abri o arquivo <code>input</code> em meu Notepad++, que possui na lateral esquerda, a númeração de cada linha. Dessa forma, eu posso rapidamente identificar que o termo <code>input</code> aparece na linha 18 do arquivo.</p>
<p></p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-167"></span>
<img src="Figuras/input_PNAD_linha_mod.png" alt="Início do script de importação" width="70%"><p class="caption">
Figure 3.10: Início do script de importação
</p>
</div>
<p></p>
<p>Com essas informações em mente, eu poderia gerar a tabela <code>col_width</code>, através dos seguintes comandos:</p>
<p></p>
<div class="sourceCode" id="cb319"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/ajdamico/SAScii">SAScii</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tibble.tidyverse.org/">tibble</a></span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb320"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">col_width</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/SAScii/man/parse.SAScii.html">parse.SAScii</a></span><span class="op">(</span>
  <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/input_PNADC_trimestral.txt"</span>,
  beginline <span class="op">=</span> <span class="fl">18</span>
<span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb321"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="va">col_width</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 217 x 4
##    varname   width char  divisor
##    &lt;chr&gt;     &lt;dbl&gt; &lt;lgl&gt;   &lt;dbl&gt;
##  1 ANO           4 TRUE        1
##  2 TRIMESTRE     1 TRUE        1
##  3 UF            2 TRUE        1
##  4 CAPITAL       2 TRUE        1
##  5 RM_RIDE       2 TRUE        1
##  6 UPA           9 TRUE        1
##  7 ESTRATO       7 TRUE        1
##  8 V1008         2 TRUE        1
##  9 V1014         2 TRUE        1
## 10 V1016         1 TRUE        1
## # ... with 207 more rows</code></pre>
<p></p>
</div>
<div id="importando-os-microdados-da-pnad-contínua" class="section level3" number="3.7.4">
<h3>
<span class="header-section-number">3.7.4</span> Importando os microdados da PNAD Contínua<a class="anchor" aria-label="anchor" href="#importando-os-microdados-da-pnad-cont%C3%ADnua"><i class="fas fa-link"></i></a>
</h3>
<p>Agora que possuímos as especificações necessárias de cada coluna, podemos começar o processo de importação dos microdados da PNAD Contínua. Como esses microdados estão estruturados em um arquivo de texto do tipo <em>fixed width file</em> (<code>.fwf</code>), podemos utilizar a função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf()</a></code> para ler o arquivo. Pois como o próprio nome dessa função dá a entender, ela é especializada nesse tipo de arquivo.</p>
<p>O primeiro argumento (<code>file</code>) dessa função, é o caminho até o arquivo a ser importado. Já o segundo argumento (<code>col_positions</code>), será o local onde vamos fornecer as especificações de cada coluna. Entretanto, nós precisamos utilizar uma função como a <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_widths()</a></code>, para definirmos essas especificações no argumento <code>col_positions</code>. Na função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_widths()</a></code> temos apenas dois argumentos, que são <code>widths</code> e <code>col_names</code>. Basta fornecermos ao argumento <code>widths</code>, as larguras de cada coluna, e ao argumento <code>col_names</code>, os nomes de cada coluna, como no exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb323"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pnad_continua</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf</a></span><span class="op">(</span>
  <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/PNADC_012020.txt"</span>,
  col_positions <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_widths</a></span><span class="op">(</span><span class="va">col_width</span><span class="op">$</span><span class="va">width</span>, col_names <span class="op">=</span> <span class="va">col_width</span><span class="op">$</span><span class="va">variavel</span><span class="op">)</span>
<span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## -- Column specification -------------------------------------
## cols(
##   .default = col_double(),
##   RM_RIDE = col_logical(),
##   V1008 = col_character(),
##   V1014 = col_character(),
##   V1027 = col_character(),
##   V1028 = col_character(),
##   V1029 = col_character(),
##   V2001 = col_character(),
##   V2003 = col_character(),
##   V2005 = col_character(),
##   V2008 = col_character(),
##   V20081 = col_character(),
##   V2009 = col_character(),
##   `3003` = col_logical(),
##   V3003A = col_character(),
##   V3004 = col_logical(),
##   V3005 = col_logical(),
##   V3006 = col_character(),
##   V3009 = col_logical(),
##   V3009A = col_character(),
##   V3011 = col_logical()
## # ... with 87 more columns
## )
## i Use `spec()` for the full column specifications.
## Warning: 156486 parsing failures.
## row  col               expected actual   file
## 1670 V40431  1/0/T/F/TRUE/FALSE 2        'C:/Users/Pedro/Downloads/PNADC~'
## 2194 V4057   1/0/T/F/TRUE/FALSE 2        'C:/Users/Pedro/Downloads/PNADC_~'
## 2194 V405811 1/0/T/F/TRUE/FALSE 3        'C:/Users/Pedro/Downloads/PNADC~'
## 2194 V405812 1/0/T/F/TRUE/FALSE 00001200 'C:/Users/Pedro/Downloads/PNADC~'
## 2194 V405912 1/0/T/F/TRUE/FALSE 00000000 'C:/Users/Pedro/Downloads/PNADC~'
## .... ....... .................. ........ .........................
## See problems(...) for more details.</code></pre>
<p>Como podemos ver acima, pela mensagem de <em>parsing failures</em>, obtivemos alguns problemas durante a importação. Isso ocorre, pois a função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf()</a></code> está tendo que adivinhar sozinha, quais são os tipos de dados contidos em cada coluna dos microdados. Lembre-se que por padrão, se não fornecemos uma descrição dos tipos de dados de cada coluna à qualquer função do pacote <code>readr</code>, essas funções vão automaticamente ler as 1000 primeiras linhas de cada coluna, e se basear nesses 1000 valores para determinar o tipo de dado incluso em cada coluna do arquivo.</p>
<p>Esse sistema automático, apesar de útil, se torna frágil a medida em que o tamanho da nossa base cresce. Pois essas 1000 linhas vão representar uma parte cada vez menor da base, e portanto, podem não ser suficientes para determinar com precisão o tipo de dado contido em cada coluna. No nosso exemplo, a base da PNAD possui 487 mil linhas, logo, essas 1000 linhas representam apenas 0,2% da base. Se a função não está sendo capaz de adivinhar corretamente, os tipos de dados de cada coluna, nós precisamos dizer a ela exatamente quais são esses tipos. Para isso, vamos utilizar os dados contidos na coluna <code>char</code>, da nossa tabela <code>col_width</code>.</p>
<p>As funções de importação do pacote <code>readr</code>, possuem o argumento <code>col_types</code>, onde podemos definir os tipos de cada coluna. Essa definição pode ser fornecida, utilizando-se a função <code><a href="https://readr.tidyverse.org/reference/cols.html">cols()</a></code>. Porém, para o nosso caso, creio que será mais prático, utilizarmos um método alternativo que o argumento <code>col_types</code> disponibiliza. Esse método alternativo, conciste em fornecermos um vetor de letras, contendo a primeira letra de cada tipo. Essas letras devem estar na ordem em que as colunas aparecem em seus dados. Logo, se eu fornecer o vetor <code>"ccdlcdd"</code>, a função irá interpretar a primeira e a segunda coluna como dados do tipo <code>character</code>, enquanto a terceira e a quarta coluna serão interpretadas como dados dos tipos <code>double</code> e <code>logical</code>, respectivamente.</p>
<p>Primeiro, precisamos construir esse vetor de letras, que indicam o tipo de cada coluna. Com os dados da nossa tabela <code>col_width</code>, nós já sabemos que todo valor <code>TRUE</code> na coluna <code>char</code>, indica uma coluna de texto, e portanto, essa coluna deve ser interpretada como uma coluna do tipo <code>character</code>. Já os valores <code>FALSE</code> indicam uma coluna numérica, e por isso, essa coluna deve ser interpretada como uma coluna do tipo <code>double</code>. Com isso, podemos utilizar a função <code><a href="https://rdrr.io/r/base/ifelse.html">ifelse()</a></code>, para construírmos um vetor inicial de letras, baseado nos valores da coluna <code>char</code>. Em seguida, podemos juntar todas essas letras em um <em>string</em> só, com a função <code><a href="https://rdrr.io/r/base/paste.html">paste()</a></code>.</p>
<p></p>
<div class="sourceCode" id="cb325"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tipos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">col_width</span><span class="op">$</span><span class="va">char</span> <span class="op">==</span> <span class="cn">TRUE</span>, <span class="st">"c"</span>, <span class="st">"d"</span><span class="op">)</span>

<span class="va">tipos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="va">tipos</span>, collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span>

<span class="va">tipos</span></code></pre></div>
<p></p>
<pre><code>[1] "ccccccccccccdddcdccccccdcccccccccccccccccccccccccccccccccccccccccccc
cccccccccccccccccccccccccccdccdcccccdccdddcdddccccccccccccdccdcccccdccddd
ccccdccdccccccdcddcccccccccccccdddcccccdcccccccccccccccccccddcddccdddddcc"</code></pre>
<p>Agora com o vetor <code>tipos</code>, podemos fornecê-lo ao argumento <code>col_types</code> e realizar novamente o processo de importação, com os tipos das colunas sendo corretamente interpretados. Porém, repare que mesmo definindo os tipos das colunas, obtivemos novamente erros durante o processo de importação. Dessa vez, foram mais de 2 milhões de erros. Isso não significa necessariamente que o nosso processo de importação esteja incorretamente especificado. Porém, nós deveríamos pelo menos compreender o porque esses erros ocorrem.</p>
<p></p>
<div class="sourceCode" id="cb327"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pnad_continua</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf</a></span><span class="op">(</span>
  <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/PNADC_012020.txt"</span>,
  col_positions <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_widths</a></span><span class="op">(</span><span class="va">col_width</span><span class="op">$</span><span class="va">width</span>, col_names <span class="op">=</span> <span class="va">col_width</span><span class="op">$</span><span class="va">variavel</span><span class="op">)</span>, 
  col_types <span class="op">=</span> <span class="va">tipos</span>
<span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## Warning: 2032039 parsing failures.
## row    col expected actual                                              file
##   1 VD4032 a double      . 'C:/Users/Pedro/Downloads/PNADC_012020/PNADC_01~'
##   1 VD4033 a double      . 'C:/Users/Pedro/Downloads/PNADC_012020/PNADC_01~'
##   1 VD4034 a double      . 'C:/Users/Pedro/Downloads/PNADC_012020/PNADC_01~'
##   2 VD4031 a double      . 'C:/Users/Pedro/Downloads/PNADC_012020/PNADC_01~'
##   2 VD4032 a double      . 'C:/Users/Pedro/Downloads/PNADC_012020/PNADC_01~'
## ... ...... ........ ...... ................................................
## See problems(...) for more details.</code></pre>
</div>
<div id="analisando-erros-de-importação" class="section level3" number="3.7.5">
<h3>
<span class="header-section-number">3.7.5</span> Analisando erros de importação<a class="anchor" aria-label="anchor" href="#analisando-erros-de-importa%C3%A7%C3%A3o"><i class="fas fa-link"></i></a>
</h3>
<p>Nós podemos obter através da função <code><a href="https://readr.tidyverse.org/reference/problems.html">problems()</a></code>, uma tabela contendo todos os erros que ocorreram durante esse processo de importação. Precisamos apenas fornecer a essa função, os comandos que geraram esses problemas, como no exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb329"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">problemas</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/problems.html">problems</a></span><span class="op">(</span>
  <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf</a></span><span class="op">(</span>
    <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/PNADC_012020.txt"</span>,
    col_positions <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_widths</a></span><span class="op">(</span><span class="va">col_width</span><span class="op">$</span><span class="va">width</span>, col_names <span class="op">=</span> <span class="va">col_width</span><span class="op">$</span><span class="va">variavel</span><span class="op">)</span>, 
    col_types <span class="op">=</span> <span class="va">tipos</span>
  <span class="op">)</span>
<span class="op">)</span>

<span class="va">problemas</span></code></pre></div>
<p></p>
<pre><code>## # A tibble: 2,032,039 x 5
##      row col    expected   actual file
##    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;  &lt;chr&gt;        
##  1     1 VD4032 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  2     1 VD4033 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  3     1 VD4034 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  4     2 VD4031 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  5     2 VD4032 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  6     2 VD4033 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  7     2 VD4034 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  8     2 VD4035 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
##  9     3 VD4031 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
## 10     3 VD4032 a double   .      'C:/Users/Pedro/Downloads/PNADC_012020/PNAD~
## # ... with 2,032,029 more rows</code></pre>
<p>Pelo que podemos ver da coluna <code>actual</code>, parece que os erros estão ocorrendo, pela presença de um ponto final (“.”), nos locais em que deveriam estar números (<code>double</code>). Podemos utilizar a função <code><a href="https://rdrr.io/r/base/unique.html">unique()</a></code> sobre a coluna <code>actual</code> para identificarmos se há algum outro problema que precisamos analisar. Pelo resultado abaixo, percebemos que todos os mais de 2 milhões de erros gerados, estão sendo causados por essa presença de pontos finais na base. Também podemos utilizar a função <code><a href="https://rdrr.io/r/base/unique.html">unique()</a></code> sobre a coluna <code>col</code>, para descobrirmos em quais colunas esse erro ocorre. Vemos abaixo, que esses erros estão concentrados em cinco das últimas colunas de toda a base (a última coluna da base é VD4037).</p>
<p></p>
<div class="sourceCode" id="cb331"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="va">problemas</span><span class="op">$</span><span class="va">actual</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## [1] "."</code></pre>
<p></p>
<div class="sourceCode" id="cb333"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="va">problemas</span><span class="op">$</span><span class="va">col</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## [1] "VD4032" "VD4033" "VD4034" "VD4031" "VD4035"</code></pre>
<p>Seria uma boa ideia, olharmos mais de perto como essas colunas aparecem no arquivo de microdaddos. Para determinarmos a parte do arquivo que diz respeito a essas colunas, precisamos descobrir o intervalo de caracteres que cobrem essas colunas, através dos dados da tabela <code>col_width</code>. Para isso, vamos precisar descobrir o número total de caracteres em cada linha (ou em outras palavras, a largura total da base), ao somarmos a largura de todas as colunas na tabela <code>col_width</code>. Ao longo do caminho, teremos que subtrair uma faixa desse total, para descobrirmos o caractere que inicia o intervalo de colunas que estamos interessados.</p>
<p></p>
<div class="sourceCode" id="cb335"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">total_caracteres</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">col_width</span><span class="op">$</span><span class="va">width</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 464</code></pre>
<p></p>
<p>Em seguida, podemos aplicar a função <code><a href="https://rdrr.io/r/utils/head.html">tail()</a></code> sobre a tabela <code>col_width</code>, para extraírmos as últimas linhas dessa tabela, e verificarmos as especificações das colunas que cobrem essa faixa. Pois nós sabemos que as variáveis que geraram problemas na importação, estão entre as útimas colunas dos microdados, logo, as especificações dessas colunas vão se encontrar nas últimas linhas da tabela <code>col_width</code>. Vemos abaixo, que as duas últimas colunas da base (VD4036 e VD4037), das quais não estamos interessados, possuem juntas, 2 caracteres de largura. Portanto, o intervalo que cobre as colunas que geraram os problemas na importação (VD4031-VD4035), termina no 462° caractere, como vemos abaixo. Pelo resultado de <code><a href="https://rdrr.io/r/utils/head.html">tail()</a></code>, vemos que as colunas das quais estamos interessados (VD4031-VD4035), somam 15 caracteres de largura. Tendo isso em mente, o intervalo que cobre essas colunas, se inicia no 448° caractere.</p>
<p></p>
<div class="sourceCode" id="cb337"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">col_width</span>, <span class="fl">7</span><span class="op">)</span></code></pre></div>
<pre><code>##     varname width  char divisor
## 211  VD4031     3 FALSE       1
## 212  VD4032     3 FALSE       1
## 213  VD4033     3 FALSE       1
## 214  VD4034     3 FALSE       1
## 215  VD4035     3 FALSE       1
## 216  VD4036     1  TRUE       1
## 217  VD4037     1  TRUE       1</code></pre>
<div class="sourceCode" id="cb339"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">fim_intervalo</span> <span class="op">&lt;-</span> <span class="va">total_caracteres</span> <span class="op">-</span> <span class="fl">2</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 462</code></pre>
<div class="sourceCode" id="cb341"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">inicio_intervalo</span> <span class="op">&lt;-</span> <span class="va">fim_intervalo</span> <span class="op">-</span> <span class="fl">15</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 448</code></pre>
<p></p>
<p>Portanto, nós temos agora a posição dos caracteres que iniciam e terminam o intervalo de caracteres que dizem respeito as colunas que estamos interessados. Porém, ainda precisamos calcular os caracteres de início e de fim de cada uma das cinco colunas (VD4031-VD4035), que cobrem esse intervalor. Para esse trabalho, podemos aplicar uma simples aritmética, como a aplicada pelo código abaixo.</p>
<p></p>
<div class="sourceCode" id="cb343"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">inicio</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">4</span> <span class="op">*</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span> <span class="va">inicio_intervalo</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 448 451 454 457 460</code></pre>
<div class="sourceCode" id="cb345"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">fim</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span> <span class="op">*</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span> <span class="va">inicio_intervalo</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 450 453 456 459 462</code></pre>
<p></p>
<p>Agora que nós temos as posições dos caracteres que iniciam e que terminam cada uma das cinco colunas, podemos importar apenas essas cinco colunas ao R. Para isso, podemos usar novamente a função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf()</a></code>, aliada à função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_positions()</a></code>. Ou seja, utilizamos anteriormente a função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_widths()</a></code> para determinarmos as especificações de todas as colunas da base. Porém, como nós queremos importar apenas uma parte dessa base, vamos utilizar a função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_positions()</a></code> para determinarmos as especificações dessas colunas desejadas.</p>
<p>Na função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_positions()</a></code>, temos três argumentos principais: 1) <code>start</code>, um vetor contendo as posições dos caracteres que iniciam cada coluna; 2) <code>end</code>, um vetor contendo as posições dos caracteres que terminam cada coluna; 3) <code>col_names</code>, um vetor contendo os nomes dessas colunas selecionadas. Tendo esses argumentos em mente, podemos importar as cinco colunas da seguinte maneira:</p>
<p></p>
<div class="sourceCode" id="cb347"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">colunas</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"VD4031"</span>,<span class="st">"VD4032"</span>,<span class="st">"VD4033"</span>,<span class="st">"VD4034"</span>,<span class="st">"VD4035"</span><span class="op">)</span>

<span class="va">conferir</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf</a></span><span class="op">(</span>
  <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/PNADC_012020.txt"</span>,
  col_positions <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_positions</a></span><span class="op">(</span>
    start <span class="op">=</span> <span class="va">inicio</span>,
    end <span class="op">=</span> <span class="va">fim</span>,
    col_names <span class="op">=</span> <span class="va">colunas</span>
  <span class="op">)</span>
<span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## -- Column specification ------------------------------------
## cols(
##   VD4031 = col_character(),
##   VD4032 = col_character(),
##   VD4033 = col_character(),
##   VD4034 = col_character(),
##   VD4035 = col_character()
## )</code></pre>
<p>Logo abaixo, temos o resultado do intervalo que selecionamos do arquivo, em que podemos ver o grupo de pontos finais que estão causando o problema. Agora, temos que identificar o motivo desses pontos estarem aí. Se nós retornarmos às especificações dessas colunas apresentadas na tabela <code>col_width</code>, nós sabemos que essas colunas são colunas numéricas. Será que esses pontos estão aí, para marcar as casas decimais dos números dessa coluna?</p>
<p>Talvez não seja esse o caso. Pois se esses pontos estivessem de fato, marcando as casas decimais, porque eles não aparecem na primeira linha das colunas VD4031 e VD4035? Isto é, por que o valor 040 que aparece nessas colunas, não se apresenta como 0.40, ou 04.0, ou 40.0 na tabela <code>conferir</code>? Lembre-se que os valores da tabela <code>conferir</code>, são apresentados exatamente da forma como eles se apresentam no arquivo dos microdados, pois todas essas colunas estão sendo interpretadas como <code>character</code>. Ou seja, esses valores que eram meros textos no arquivo dos microdados, continuam sendo textos no R, de forma que não houve nenhuma conversão desses valores.</p>
<p></p>
<div class="sourceCode" id="cb349"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">conferir</span></code></pre></div>
<p></p>
<pre><code>## # A tibble: 487,937 x 5
##    VD4031 VD4032 VD4033 VD4034 VD4035
##    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; 
##  1 040    .      .      .      040   
##  2 .      .      .      .      .     
##  3 .      .      .      .      .     
##  4 .      .      .      .      .     
##  5 .      .      .      .      .     
##  6 040    .      .      .      040   
##  7 .      .      .      .      .     
##  8 .      .      .      .      .     
##  9 .      .      .      .      .     
## 10 040    .      .      .      040   
## # ... with 487,927 more rows</code></pre>
<p>Pela visão que temos até o momento, parece que as colunas VD4032, VD4033 e VD4034, estão vazias, de forma que elas possuem apenas pontos finais em toda a sua extensão. Talvez seja o momento de verificarmos essa hipótese. Podemos fazer isso, novamente por meio da função <code><a href="https://rdrr.io/r/base/unique.html">unique()</a></code>. Pelos resultados abaixo, as colunas VD4032, VD4033 e VD4034 estão de fato vazias. Com isso, temos a seguinte questão: por que uma coluna numérica está preenchida com pontos? Se esses pontos não estão marcando as casas decimais em cada linha, é mais provável que esses pontos estejam ali simplesmente para marcar um valor vazio, ou uma observação que não pôde ser mensurada.</p>
<p></p>
<div class="sourceCode" id="cb351"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="va">conferir</span><span class="op">$</span><span class="va">VD4032</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## [1] "."</code></pre>
<p></p>
<div class="sourceCode" id="cb353"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="va">conferir</span><span class="op">$</span><span class="va">VD4033</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## [1] "."</code></pre>
<p></p>
<div class="sourceCode" id="cb355"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="va">conferir</span><span class="op">$</span><span class="va">VD4034</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>## [1] "."</code></pre>
<p>Em resumo, nós sabemos pelas especificações das colunas presentes no arquivo <code>input</code>, que as colunas VD4032, VD4033 e VD4034 devem ser interpretadas como colunas numéricas. Ao que tudo indica, esses pontos não possuem o propósito de delimitar as casas decimais. Seria apropriado encontrarmos alguma documentação que nos pudesse guiar sobre esses questionamentos. Porém, até onde pesquisei, não há qualquer menção a esses pontos ao longo da documentação do IBGE sobre esses microdados. Com as informações que possuímos, só podemos inferir que esses valores estão servindo para marcar valores não-disponíveis (em outras palavras, estão cumprindo o papel de um valor <code>NA</code>) nessas colunas.</p>
<p>Tendo essas considerações em mente, todos esses pontos presentes nessas colunas, devido ao erro que eles incorrem durante o processo de importação, serão convertidos para valores <code>NA</code> ao importarmos a base, e portanto, vão representar observações não-disponíveis na base. Ou seja, se a função <code><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf()</a></code> não consegue interpretar corretamente um valor, ele acaba sendo convertido para um valor <code>NA</code>.</p>
<p></p>
<div class="sourceCode" id="cb357"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pnad_continua</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">read_fwf</a></span><span class="op">(</span>
  <span class="st">"C:/Users/Pedro/Downloads/PNADC_012020/PNADC_012020.txt"</span>,
  col_positions <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_fwf.html">fwf_widths</a></span><span class="op">(</span><span class="va">col_width</span><span class="op">$</span><span class="va">width</span>, col_names <span class="op">=</span> <span class="va">col_width</span><span class="op">$</span><span class="va">variavel</span><span class="op">)</span>, 
  col_types <span class="op">=</span> <span class="va">tipos</span>
<span class="op">)</span></code></pre></div>
<p></p>
</div>
</div>
<div id="exportando-os-seus-dados-com-o-pacote-readr" class="section level2" number="3.8">
<h2>
<span class="header-section-number">3.8</span> Exportando os seus dados com o pacote <code>readr</code><a class="anchor" aria-label="anchor" href="#exportando-os-seus-dados-com-o-pacote-readr"><i class="fas fa-link"></i></a>
</h2>
<p>Mais do que importar os seus dados para dentro do R, haverá um momento em que você deseja exportar os seus resultados para fora do R, de forma que você possa enviá-los para os seus colegas de trabalho ou para utilizá-los em outros programas. Em um momento como esse, você deseja escrever um arquivo estático em seu computador, contendo esses resultados. O pacote <code>readr</code> oferece funções que permitem a escrita de um conjunto de arquivos de texto. Logo abaixo, temos uma lista relacionando os tipos de arquivos de texto às respectivas funções do pacote:</p>
<ol style="list-style-type: decimal">
<li><p><code><a href="https://readr.tidyverse.org/reference/write_delim.html">write_csv2()</a></code>: constrói um arquivo CSV, segundo o padrão adotado por alguns países europeus; utilizando pontos e vírgulas (<code>;</code>) como separador.</p></li>
<li><p><code><a href="https://readr.tidyverse.org/reference/write_delim.html">write_csv()</a></code>: constrói um arquivo CSV, segundo o padrão americano; utilizando vírgulas (<code>,</code>) como separador.</p></li>
<li><p><code><a href="https://readr.tidyverse.org/reference/write_delim.html">write_tsv()</a></code>: constrói um arquivo TSV.</p></li>
<li><p><code><a href="https://readr.tidyverse.org/reference/write_delim.html">write_delim()</a></code>: função geral onde você pode definir o caractere a ser utilizado como separador no arquivo de texto construído.</p></li>
</ol>
<p>Um fator muito importante sobre o pacote <code>readr</code> em geral, é que todas as suas funções utilizam o <em>encoding</em> UTF-8 o tempo todo. Logo, ao utilizar essas funções para exportar os seus dados, lembre-se sempre que os arquivos construídos por essas funções vão estar utilizando o <em>encoding</em> UTF-8. Isso significa que ao utilizar esses arquivos em outros programas como o Excel, você precisa informar ao programa para utilizar o <em>encoding</em> UTF-8 ao ler o arquivo.</p>
<p>Para além disso, você não terá nenhum outro problema com esses arquivos. Porém, caso você se sinta incomodado com esse comportamento, você pode utilizar as variantes dessas funções presentes nos pacotes básicos do R (<code><a href="https://rdrr.io/r/utils/write.table.html">write.csv2()</a></code>, <code><a href="https://rdrr.io/r/utils/write.table.html">write.csv()</a></code>, <code><a href="https://rdrr.io/r/utils/write.table.html">write.table()</a></code>). Pois essas funções variantes vão escrever o arquivo definido, de acordo com o <em>encoding</em> padrão de seu sistema.</p>
<p>O primeiro argumento (<code>x</code>) dessas funções, se trata do nome do objeto em sua sessão que contém os dados que você deseja exportar. Já no segundo argumento (<code>file</code>) dessas funções, você deve definir o nome do novo arquivo estatíco que será construído. Por exemplo, se eu possuo uma tabela chamada, e desejo salvá-la em um arquivo chamado <code>transf.csv</code>, eu preciso construir os seguintes comandos:</p>
<p></p>
<div class="sourceCode" id="cb358"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/write_delim.html">write_csv2</a></span><span class="op">(</span><span class="va">transf</span>, file <span class="op">=</span> <span class="st">"transf.csv"</span><span class="op">)</span></code></pre></div>
<p></p>
<p>Após executar os comandos acima, você irá encontrar na pasta que representa o seu diretório de trabalho atual no R, um novo arquivo chamado <code>transf.csv</code> que contém os seus dados. Vale destacar, que você pode salvar esse novo arquivo em diferentes áreas de seu computador. Basta que você forneça um endereço (absoluto ou relativo) até a pasta desejada, em conjunto com o nome do novo arquivo. Como exemplo, eu posso salvar a tabela <code>Censo_2010</code> dentro da minha área de trabalho da seguinte forma:</p>
<p></p>
<div class="sourceCode" id="cb359"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readr.tidyverse.org/reference/write_delim.html">write_csv2</a></span><span class="op">(</span><span class="va">Censo_2010</span>, file <span class="op">=</span> <span class="st">"C:/Users/Pedro/Desktop/Censo_2010.csv"</span><span class="op">)</span></code></pre></div>
<p></p>
</div>
<div id="sec:read_excel" class="section level2" number="3.9">
<h2>
<span class="header-section-number">3.9</span> Importando planilhas do Excel com <code>readxl</code><a class="anchor" aria-label="anchor" href="#sec:read_excel"><i class="fas fa-link"></i></a>
</h2>
<p>O Excel continua sendo um dos programas mais populares no mundo e, por essa razão, muitas pessoas ainda o utilizam para analisar dados e gerar gráficos. Tendo isso em vista, nessa seção, vamos aprender como podemos importar para o R, dados que se encontram em planilhas do Excel (<code>.xlsx</code>), através da função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> que pertence ao pacote <code>readxl</code>.</p>
<p>O principal argumento da função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> corresponde novamente ao endereço até o arquivo que você deseja ler, ou apenas o seu nome caso esse arquivo se encontre em seu diretório de trabalho atual.</p>
<p></p>
<div class="sourceCode" id="cb360"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://readxl.tidyverse.org">readxl</a></span><span class="op">)</span>

<span class="va">codigos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"codigos.xlsx"</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb361"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">codigos</span></code></pre></div>
<pre><code>## # A tibble: 853 x 4
##     IBGE1 IBGE2   SEF Municípios         
##     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;              
##  1 310010    10     1 ABADIA DOS DOURADOS
##  2 310020    20     2 ABAETÉ             
##  3 310030    30     3 ABRE CAMPO         
##  4 310040    40     4 ACAIACA            
##  5 310050    50     5 AÇUCENA            
##  6 310060    60     6 ÁGUA BOA           
##  7 310070    70     7 ÁGUA COMPRIDA      
##  8 310080    80     8 AGUANIL            
##  9 310090    90     9 ÁGUAS FORMOSAS     
## 10 310100   100    10 ÁGUAS VERMELHAS    
## # ... with 843 more rows</code></pre>
<p></p>
<div id="delimitando-a-parte-de-seu-arquivo-.xlsx" class="section level3" number="3.9.1">
<h3>
<span class="header-section-number">3.9.1</span> Delimitando a parte de seu arquivo <code>.xlsx</code><a class="anchor" aria-label="anchor" href="#delimitando-a-parte-de-seu-arquivo-.xlsx"><i class="fas fa-link"></i></a>
</h3>
<p>Um único arquivo <code>.xlsx</code> pode conter várias planilhas, ou várias abas (<em>sheet</em>’s) diferentes. Por padrão, a função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> sempre lê a primeira planilha de seu arquivo <code>.xlsx</code>. Porém, você pode ler diferentes planilhas de seu arquivo por meio do argumento <code>sheet</code>. Somos capazes de selecionar a planilha desejada de acordo com a sua ordem (1, 2, 3, …), ou de acordo com o nome dado à aba que a contém.</p>
<p></p>
<div class="sourceCode" id="cb363"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Lê a terceira planilha do arquivo</span>
<span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, sheet <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 71 x 2
##    weight feed     
##     &lt;dbl&gt; &lt;chr&gt;    
##  1    179 horsebean
##  2    160 horsebean
##  3    136 horsebean
##  4    227 horsebean
##  5    217 horsebean
##  6    168 horsebean
##  7    108 horsebean
##  8    124 horsebean
##  9    143 horsebean
## 10    140 horsebean
## # ... with 61 more rows</code></pre>
<p></p>
<p></p>
<div class="sourceCode" id="cb365"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Lê a planilha presente na aba denominada mtcars</span>
<span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, sheet <span class="op">=</span> <span class="st">"mtcars"</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 32 x 11
##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
##  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
##  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
##  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
##  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
##  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
##  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
## 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
## # ... with 22 more rows</code></pre>
<p></p>
<p>Além dessas configurações, conseguimos delimitar o intervalo de células a serem lidas pela função, através do argumento <code>range</code>. Podemos fornecer esse intervalo em dois estilos diferentes. Nós podemos utilizar o sistema tradicional do Excel (CL:CL), como no exemplo abaixo, em que estamos lendo da célula A1 à célula C150 através da notação <code>A1:C150</code>.</p>
<p></p>
<div class="sourceCode" id="cb367"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, range <span class="op">=</span> <span class="st">"A1:C150"</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 149 x 3
##    Sepal.Length Sepal.Width Petal.Length
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;
##  1          5.1         3.5          1.4
##  2          4.9         3            1.4
##  3          4.7         3.2          1.3
##  4          4.6         3.1          1.5
##  5          5           3.6          1.4
##  6          5.4         3.9          1.7
##  7          4.6         3.4          1.4
##  8          5           3.4          1.5
##  9          4.4         2.9          1.4
## 10          4.9         3.1          1.5
## # ... with 139 more rows</code></pre>
<p></p>
<p>Uma outra possibilidade é utilizarmos as funções <code><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_cols()</a></code> e <code><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_rows()</a></code> que limitam o intervalo para apenas uma das dimensões da planilha. Ou seja, nós empregamos a função <code><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_cols()</a></code>, quando desejamos ler todas as linhas, e, apenas algumas colunas da planilha. Enquanto com a função <code><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_rows()</a></code>, desejamos ler todas as colunas da tabela, porém, queremos extrair apenas uma parte das linhas.</p>
<p>As colunas de uma planilha do Excel, são identificadas por uma letra ou por um conjunto de letras (ex: A; E; F; BC). Por isso, ao utilizar a função <code><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_cols()</a></code> você pode delimitar as colunas a serem lidas de duas formas: 1) utilizando a notação do Excel (C:C), com as letras que representam as colunas desejadas; 2) ou através de um vetor numérico que representa a ordem das colunas, e contém o intervalo desejado.</p>
<p></p>
<div class="sourceCode" id="cb369"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Da coluna A até a coluna C</span>
<span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, range <span class="op">=</span> <span class="fu"><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_cols</a></span><span class="op">(</span><span class="st">"A:C"</span><span class="op">)</span><span class="op">)</span>

<span class="co">## Da 1° até a 3° coluna</span>
<span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, range <span class="op">=</span> <span class="fu"><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_cols</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p></p>
<p>Por outro lado, para delimitarmos o intervalo de linhas em <code><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_rows()</a></code> precisamos apenas fornecer um vetor de dois elementos, contendo os limites superior e inferior do intervalo, ou então, uma sequência que cobre esses limites.</p>
<p></p>
<div class="sourceCode" id="cb370"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Da 1° até a 140° linha</span>
<span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, range <span class="op">=</span> <span class="fu"><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_rows</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">140</span><span class="op">)</span><span class="op">)</span>

<span class="co">## Da 10° até a 400° linha</span>
<span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, range <span class="op">=</span> <span class="fu"><a href="https://readxl.tidyverse.org/reference/cell-specification.html">cell_rows</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">400</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p></p>
<p>O argumento <code>range</code> é tão flexível que nós podemos utilizá-lo para executar o trabalho do argumento <code>sheet</code>. Isto é, além do intervalo de células, nós também podemos selecionar a aba do arquivo <code>.xlsx</code> a ser lida pela função, através do argumento <code>range</code>. No Excel, quando você está utilizando em sua planilha, algum valor que é proveniente de uma outra planilha do mesmo arquivo <code>.xlsx</code>, o Excel cria uma referência até esse valor. Essa referência possui o nome da planilha em conjunto com a referência da célula onde o valor se encontra, separados por um ponto de exclamação (<code><a href="https://rdrr.io/r/base/Logic.html">!</a></code>). Logo, se eu quisesse ler da célula A1 até a célula C150, da planilha denominada <code>mtcars</code>, do arquivo <code>datasets.xlsx</code>, eu precisaria criar a seguinte referência no argumento <code>range</code>:</p>
<p></p>
<div class="sourceCode" id="cb371"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, range <span class="op">=</span> <span class="st">"mtcars!A1:C150"</span><span class="op">)</span> </code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 149 x 3
##      mpg   cyl  disp
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  21       6  160 
##  2  21       6  160 
##  3  22.8     4  108 
##  4  21.4     6  258 
##  5  18.7     8  360 
##  6  18.1     6  225 
##  7  14.3     8  360 
##  8  24.4     4  147.
##  9  22.8     4  141.
## 10  19.2     6  168.
## # ... with 139 more rows</code></pre>
<p></p>
<p>Apesar de sua flexibilidade, o argumento <code>range</code> pressupõe que você conheça exatamente as células que compõe os limites de sua tabela, ou então, que você pelo menos tenha uma boa compreensão de onde eles se encontram. Por isso, você também possui na função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> os argumentos <code>skip</code> e <code>n_max</code>, que funcionam exatamente da mesma forma empregada pelas funções do pacote <code>readr</code>. Logo, esses argumentos representam uma alternativa menos flexível, mas, talvez sejam mais ideais para as suas necessidades, especialmente se você deseja apenas pular algumas linhas de metadados que se encontram no início de sua planilha.</p>
<p></p>
<div class="sourceCode" id="cb373"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="st">"datasets.xlsx"</span>, sheet <span class="op">=</span> <span class="fl">2</span>, n_max <span class="op">=</span> <span class="fl">50</span>, skip <span class="op">=</span> <span class="fl">10</span>, col_names <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> </code></pre></div>
<p></p>
<pre><code>## # A tibble: 23 x 11
##     ...1  ...2  ...3  ...4  ...5  ...6  ...7  ...8  ...9 ...10 ...11
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  19.2     6 168.    123  3.92  3.44  18.3     1     0     4     4
##  2  17.8     6 168.    123  3.92  3.44  18.9     1     0     4     4
##  3  16.4     8 276.    180  3.07  4.07  17.4     0     0     3     3
##  4  17.3     8 276.    180  3.07  3.73  17.6     0     0     3     3
##  5  15.2     8 276.    180  3.07  3.78  18       0     0     3     3
##  6  10.4     8 472     205  2.93  5.25  18.0     0     0     3     4
##  7  10.4     8 460     215  3     5.42  17.8     0     0     3     4
##  8  14.7     8 440     230  3.23  5.34  17.4     0     0     3     4
##  9  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1
## 10  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2
## # ... with 13 more rows</code></pre>
</div>
<div id="definindo-os-tipos-de-dados-contidos-em-cada-coluna" class="section level3" number="3.9.2">
<h3>
<span class="header-section-number">3.9.2</span> Definindo os tipos de dados contidos em cada coluna<a class="anchor" aria-label="anchor" href="#definindo-os-tipos-de-dados-contidos-em-cada-coluna"><i class="fas fa-link"></i></a>
</h3>
<p>Por padrão, a função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> vai automaticamente decifrar os tipos de dados contidos em cada coluna. Porém, diferentemente das funções do pacote <code>readr</code>, que constroem essa suposição com base nos dados em si do arquivo, a função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> adivinha os dados contidos em cada coluna, com base nos tipos associados a cada célula da planilha. Ou seja, se as células de uma coluna estão associadas ao tipo <code>Texto</code>, essa coluna será transformada no R em uma coluna do tipo <code>character</code>.</p>
<p>Pelo fato do Excel tratar cada célula de forma individual, você possui uma liberdade muito grande no programa. Por exemplo, você pode misturar dados de diferentes tipos em uma mesma coluna, ou em uma mesma linha de uma planilha do Excel. Porém, essa liberdade tem o seu preço. Um programa que trata as suas células dessa maneira, gera uma estrutura incosistente em seus dados. Esse fato é importante, pois você tem um trabalho muito maior ao replicar cálculos em sua tabela. Com uma estrutura inconsistente, você precisa pensar não apenas em quais tipos estão associados a cada coluna de sua tabela, mas também, em quais tipos estão associados a cada célula de cada coluna. As chances de erros serem gerados durante o processo, são bem maiores.</p>
<p>Portanto, o sistema que a função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> adota, está de acordo com essa característica. Pois se diversas células em uma mesma coluna possuírem tipos diferentes associados a elas, a função será capaz de reconhecer essa incosistência, e agir adequadamente. Nós sabemos que o R leva muito a sério a concistência de seus dados, especialmente se tratando de vetores com suas regras de coerção e, por isso, tal liberdade presente em programas como o Excel, representam um desafio para a importação de dados provenientes dessa plataforma.</p>
<p>No R, há duas maneiras principais de lidarmos com essa possível incosistência de uma planilha do Excel. Uma está no uso do tipo <code>character</code>, pois esse é o tipo de dado mais flexível de todos e, portanto, consegue guardar qualquer outro tipo de dado. Outra está na adoção de listas para qualquer coluna que apresente essa inconstância.</p>
<p>Portanto, em toda coluna que possui dados de diferentes tipos em suas células, a função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> vai geralmente transformar essa coluna, em uma coluna do tipo <code>character</code>. Veja no exemplo abaixo, mais especificamente, na coluna <code>value</code> que contém ao menos três tipos de dados diferentes.</p>
<p></p>
<div class="sourceCode" id="cb375"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="fu"><a href="https://readxl.tidyverse.org/reference/readxl_example.html">readxl_example</a></span><span class="op">(</span><span class="st">"clippy.xlsx"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 4 x 2
##   name                 value    
##   &lt;chr&gt;                &lt;chr&gt;    
## 1 Name                 Clippy   
## 2 Species              paperclip
## 3 Approx date of death 39083    
## 4 Weight in grams      0.9</code></pre>
<p></p>
<p>Como destacamos, uma outra alternativa, seria transformarmos essa coluna em uma lista. Dessa forma, nós podemos incluir qualquer tipo de dado em cada elemento dessa lista (ou em cada “célula” dessa coluna). Porém, teremos que pedir explicitamente a função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> que realize esse tipo de transformação, através do argumento <code>col_types</code>.</p>
<p>Portanto, em todas as ocasiões que você precisar evitar que a função <code><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel()</a></code> decifre os tipos os tipos de cada coluna, você pode definir de forma explícita esses tipos no argumento <code>col_types</code>. Você precisa apenas fornecer um vetor a esse argumento, contendo rótulos que representam os tipos de cada coluna na ordem em que elas aparecem na planilha. Os rótulos possíveis nesse argumento são : <code>"skip"</code>, <code>"guess"</code>, <code>"logical"</code>, <code>"numeric"</code>, <code>"date"</code>, <code>"text"</code> e <code>"list"</code>.</p>
<p></p>
<div class="sourceCode" id="cb377"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span><span class="fu"><a href="https://readxl.tidyverse.org/reference/readxl_example.html">readxl_example</a></span><span class="op">(</span><span class="st">"clippy.xlsx"</span><span class="op">)</span>, col_types <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"text"</span>, <span class="st">"list"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 4 x 2
##   name                 value     
##   &lt;chr&gt;                &lt;list&gt;    
## 1 Name                 &lt;chr [1]&gt; 
## 2 Species              &lt;chr [1]&gt; 
## 3 Approx date of death &lt;dttm [1]&gt;
## 4 Weight in grams      &lt;dbl [1]&gt;</code></pre>
<p></p>
</div>
</div>
<div id="importando-arquivos-do-spss-stata-e-sas-com-o-pacote-haven" class="section level2" number="3.10">
<h2>
<span class="header-section-number">3.10</span> Importando arquivos do SPSS, Stata e SAS com o pacote <code>haven</code><a class="anchor" aria-label="anchor" href="#importando-arquivos-do-spss-stata-e-sas-com-o-pacote-haven"><i class="fas fa-link"></i></a>
</h2>
<p>Apesar de serem programas mais populares em mercados específicos, especialmente o mercado americano, algumas pessoas no Brasil ainda utilizam programas como o Stata para produzirem as suas pesquisas. Por isso, nessa seção, vamos utilizar as funções do pacote <code>haven</code>, com o objetivo de importarmos dados que estejam presentes em arquivos produzidos por um desses três programas: SPSS (<code>.sav</code>, <code>.zsav</code>, <code>.por</code>), Stata (<code>.dta</code>) e SAS (<code>.sas7bdat</code>, <code>.sas7bcat</code>). Logo abaixo, temos uma lista relacionando as funções do pacote com os respectivos formatos de arquivo.</p>
<ol style="list-style-type: decimal">
<li><p><code><a href="https://haven.tidyverse.org/reference/read_dta.html">read_dta()</a></code> - Stata (<code>.dta</code>).</p></li>
<li><p><code><a href="https://haven.tidyverse.org/reference/read_spss.html">read_spss()</a></code> - SPSS (<code>.sav</code>, <code>.zsav</code>, <code>.por</code>).</p></li>
<li><p><code><a href="https://haven.tidyverse.org/reference/read_sas.html">read_sas()</a></code> - SAS (<code>.sas7bdat</code>, <code>.sas7bcat</code>).</p></li>
</ol>
<p>Assim como as funções de importações vistas até o momento, o primeiro argumento das três funções acima, se trata do endereço ou do nome do arquivo (caso ele se encontre em seu diretório de trabalho atual) que você deseja ler.</p>
<p></p>
<div class="sourceCode" id="cb379"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://haven.tidyverse.org/reference/read_spss.html">read_spss</a></span><span class="op">(</span><span class="st">"survey.sav"</span><span class="op">)</span>

<span class="fu"><a href="https://haven.tidyverse.org/reference/read_sas.html">read_sas</a></span><span class="op">(</span><span class="st">"survey.sas7bdat"</span><span class="op">)</span>

<span class="fu"><a href="https://haven.tidyverse.org/reference/read_dta.html">read_dta</a></span><span class="op">(</span><span class="st">"pnad_2015.dta"</span><span class="op">)</span></code></pre></div>
<p></p>
<div id="tratando-variáveis-rotuladas" class="section level3" number="3.10.1">
<h3>
<span class="header-section-number">3.10.1</span> Tratando variáveis rotuladas<a class="anchor" aria-label="anchor" href="#tratando-vari%C3%A1veis-rotuladas"><i class="fas fa-link"></i></a>
</h3>
<p>Os programas SPSS, SAS e Stata permitem, e muitas vezes utilizam, um sistema de rótulos sobre seus valores. O uso desses rótulos é especialmente comum em colunas que representam variáveis qualitativas (cor, sexo, faixa etária, etc.). Nessas colunas, os dados são representados por valores numéricos, porém, esses valores são rotulados com um valor textual que corresponde a faixa, ou a categoria a qual aquele valor numérico corresponde.</p>
<p>Como exemplo, veja a tabela abaixo, ou mais especificamente, as colunas <code>sex</code>, <code>marital</code> e <code>child</code>. Perceba que essas três colunas, estão sendo tratadas como colunas do tipo <code>double + labelled</code> (<code>dbl + lbl</code>). Ou seja, os dados presentes nessas colunas, são dados numéricos (<code>double</code>). Porém, certos rótulos (<code>labelled</code>) estão associados a cada um desses valores. Por exemplo, todo valor igual a 1 na coluna <code>child</code>, indica que a pessoa entrevistada naquela linha é responsável por alguma criança (<code>YES</code>), enquanto todo valor igual a 2, representa uma pessoa que não possui uma criança sobre a sua tutela (<code>NO</code>).</p>
<p></p>
<div class="sourceCode" id="cb380"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pesquisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://haven.tidyverse.org/reference/read_spss.html">read_spss</a></span><span class="op">(</span><span class="st">"survey.sav"</span><span class="op">)</span>

<span class="va">pesquisa</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 439 x 9
##       id      sex   age  marital   child     educ   source   smoke smokenum
##    &lt;dbl&gt; &lt;dbl+lb&gt; &lt;dbl&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt;    &lt;dbl&gt;
##  1   415 2 [FEMA~    24 4 [MARR~ 1 [YES] 5 [COMP~  7 [LIF~ 2 [NO]        NA
##  2     9 1 [MALE~    39 3 [LIVI~ 1 [YES] 5 [COMP~  1 [WOR~ 1 [YES]        2
##  3   425 2 [FEMA~    48 4 [MARR~ 1 [YES] 2 [SOME~  4 [CHI~ 2 [NO]        NA
##  4   307 1 [MALE~    41 5 [REMA~ 1 [YES] 2 [SOME~  1 [WOR~ 2 [NO]         0
##  5   440 1 [MALE~    23 1 [SING~ 2 [NO]  5 [COMP~  1 [WOR~ 2 [NO]         0
##  6   484 2 [FEMA~    31 4 [MARR~ 1 [YES] 5 [COMP~  7 [LIF~ 2 [NO]        NA
##  7   341 2 [FEMA~    30 6 [SEPA~ 2 [NO]  4 [SOME~  8 [MON~ 2 [NO]         0
##  8   300 1 [MALE~    23 2 [STEA~ 2 [NO]  5 [COMP~  1 [WOR~ 1 [YES]      100
##  9    61 2 [FEMA~    18 2 [STEA~ 2 [NO]  2 [SOME~  2 [SPO~ 1 [YES]       40
## 10    24 1 [MALE~    23 1 [SING~ 2 [NO]  6 [POST~ NA       2 [NO]         0
## # ... with 429 more rows</code></pre>
<p></p>
<p>Toda coluna que estiver rotulada no arquivo, será importada dessa maneira para o R, criando um tipo misto. Porém, após a importação dos dados, o ideal é que você sempre transforme essas colunas “mistas” para o tipo <code>factor</code>, pois esse tipo de dado apresenta um suporte muito melhor ao longo da linguagem R. Tal transformação pode ser facilmente gerada através da função <code><a href="https://forcats.tidyverse.org/reference/as_factor.html">as_factor()</a></code>, que provêm do pacote <code>forcats</code>.</p>
<p></p>
<div class="sourceCode" id="cb382"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://forcats.tidyverse.org">forcats</a></span><span class="op">)</span>

<span class="va">pesquisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://forcats.tidyverse.org/reference/as_factor.html">as_factor</a></span><span class="op">(</span><span class="va">pesquisa</span><span class="op">)</span>

<span class="va">pesquisa</span></code></pre></div>
<pre><code>## # A tibble: 439 x 9
##       id sex      age marital     child educ       source    smoke smokenum
##    &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt; &lt;fct&gt;      &lt;fct&gt;     &lt;fct&gt;    &lt;dbl&gt;
##  1   415 FEMAL~    24 MARRIED FI~ YES   COMPLETED~ LIFE IN ~ NO          NA
##  2     9 MALES     39 LIVING WIT~ YES   COMPLETED~ WORK      YES          2
##  3   425 FEMAL~    48 MARRIED FI~ YES   SOME SECO~ CHILDREN  NO          NA
##  4   307 MALES     41 REMARRIED   YES   SOME SECO~ WORK      NO           0
##  5   440 MALES     23 SINGLE      NO    COMPLETED~ WORK      NO           0
##  6   484 FEMAL~    31 MARRIED FI~ YES   COMPLETED~ LIFE IN ~ NO          NA
##  7   341 FEMAL~    30 SEPARATED   NO    SOME ADDI~ MONEY/FI~ NO           0
##  8   300 MALES     23 STEADY REL~ NO    COMPLETED~ WORK      YES        100
##  9    61 FEMAL~    18 STEADY REL~ NO    SOME SECO~ SPOUSE O~ YES         40
## 10    24 MALES     23 SINGLE      NO    POSTGRADU~ &lt;NA&gt;      NO           0
## # ... with 429 more rows</code></pre>
<p></p>
</div>
<div id="delimitando-partes-do-arquivo" class="section level3" number="3.10.2">
<h3>
<span class="header-section-number">3.10.2</span> Delimitando partes do arquivo<a class="anchor" aria-label="anchor" href="#delimitando-partes-do-arquivo"><i class="fas fa-link"></i></a>
</h3>
<p>Todas as três funções do pacote <code>haven</code> possuem os argumentos <code>skip</code> e <code>n_max</code>, que novamente, funcionam da mesma forma que é empregado pelas funções do pacote <code>readr</code>. Portanto, o argumento <code>skip</code> e <code>n_max</code> definem o número de linhas a serem ignoradas no início do arquivo, e o número máximo de linhas do arquivo a serem lidas, respectivamente.</p>
<p></p>
<div class="sourceCode" id="cb384"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://haven.tidyverse.org/reference/read_spss.html">read_spss</a></span><span class="op">(</span><span class="st">"survey.sav"</span>, skip <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 434 x 9
##       id      sex   age  marital   child     educ   source   smoke smokenum
##    &lt;dbl&gt; &lt;dbl+lb&gt; &lt;dbl&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt;    &lt;dbl&gt;
##  1   484 2 [FEMA~    31 4 [MARR~ 1 [YES] 5 [COMP~  7 [LIF~ 2 [NO]        NA
##  2   341 2 [FEMA~    30 6 [SEPA~ 2 [NO]  4 [SOME~  8 [MON~ 2 [NO]         0
##  3   300 1 [MALE~    23 2 [STEA~ 2 [NO]  5 [COMP~  1 [WOR~ 1 [YES]      100
##  4    61 2 [FEMA~    18 2 [STEA~ 2 [NO]  2 [SOME~  2 [SPO~ 1 [YES]       40
##  5    24 1 [MALE~    23 1 [SING~ 2 [NO]  6 [POST~ NA       2 [NO]         0
##  6   138 1 [MALE~    27 1 [SING~ 2 [NO]  3 [COMP~  1 [WOR~ 1 [YES]      100
##  7   184 2 [FEMA~    34 4 [MARR~ 1 [YES] 5 [COMP~  5 [FAM~ 2 [NO]         0
##  8   183 1 [MALE~    35 1 [SING~ 2 [NO]  4 [SOME~  7 [LIF~ 2 [NO]         0
##  9   144 2 [FEMA~    43 4 [MARR~ 1 [YES] 2 [SOME~  2 [SPO~ 2 [NO]        NA
## 10    57 1 [MALE~    50 4 [MARR~ 1 [YES] 4 [SOME~  1 [WOR~ 2 [NO]         0
## # ... with 424 more rows</code></pre>
<p></p>
<p></p>
<div class="sourceCode" id="cb386"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://haven.tidyverse.org/reference/read_spss.html">read_spss</a></span><span class="op">(</span><span class="st">"survey.sav"</span>, n_max <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 434 x 9
##       id      sex   age  marital   child     educ   source   smoke smokenum
##    &lt;dbl&gt; &lt;dbl+lb&gt; &lt;dbl&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt;    &lt;dbl&gt;
##  1   484 2 [FEMA~    31 4 [MARR~ 1 [YES] 5 [COMP~  7 [LIF~ 2 [NO]        NA
##  2   341 2 [FEMA~    30 6 [SEPA~ 2 [NO]  4 [SOME~  8 [MON~ 2 [NO]         0
##  3   300 1 [MALE~    23 2 [STEA~ 2 [NO]  5 [COMP~  1 [WOR~ 1 [YES]      100
##  4    61 2 [FEMA~    18 2 [STEA~ 2 [NO]  2 [SOME~  2 [SPO~ 1 [YES]       40
##  5    24 1 [MALE~    23 1 [SING~ 2 [NO]  6 [POST~ NA       2 [NO]         0
##  6   138 1 [MALE~    27 1 [SING~ 2 [NO]  3 [COMP~  1 [WOR~ 1 [YES]      100
##  7   184 2 [FEMA~    34 4 [MARR~ 1 [YES] 5 [COMP~  5 [FAM~ 2 [NO]         0
##  8   183 1 [MALE~    35 1 [SING~ 2 [NO]  4 [SOME~  7 [LIF~ 2 [NO]         0
##  9   144 2 [FEMA~    43 4 [MARR~ 1 [YES] 2 [SOME~  2 [SPO~ 2 [NO]        NA
## 10    57 1 [MALE~    50 4 [MARR~ 1 [YES] 4 [SOME~  1 [WOR~ 2 [NO]         0
## # ... with 424 more rows</code></pre>
<p></p>
<p>Além dessas opções, as funções também oferecem o argumento <code>col_select</code>, pelo qual você pode definir quais colunas do arquivo devem ser importadas. Esse recurso é particularmente interessante quando você possui um arquivo muito grande, como os microdados da PNAD contínua, e você deseja utilizar apenas algumas colunas, ou apenas algumas variáveis da pesquisa. Para selecionar colunas no argumento <code>col_select</code>, você pode fornecer um vetor contendo os nomes das colunas desejadas, porém, uma outra alternativa mais útil é utilizar um vetor de índices que representam a ordem das colunas desejadas.</p>
<p></p>
<div class="sourceCode" id="cb388"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://haven.tidyverse.org/reference/read_spss.html">read_spss</a></span><span class="op">(</span><span class="st">"survey_complete.sav"</span>, col_select <span class="op">=</span> <span class="fl">45</span><span class="op">:</span><span class="fl">52</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 439 x 8
##    lifsat3 lifsat4 lifsat5  pss1  pss2  pss3  pss4  pss5
##      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1       5       4       3     3     3     4     3     4
##  2       5       7       5     2     2     3     5     4
##  3       7       6       6     1     2     2     4     4
##  4       7       7       6     4     3     5     5     4
##  5       4       3       3     2     2     3     2     3
##  6       2       2       2     1     1     3     4     3
##  7       1       1       1     4     4     4     2     2
##  8       5       4       6     3     3     5     3     2
##  9       2       1       1     4     4     5     2     1
## 10       1       1       1     4     5     5     1     1
## # ... with 429 more rows</code></pre>
<p></p>
<p></p>
<div class="sourceCode" id="cb390"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://haven.tidyverse.org/reference/read_dta.html">read_dta</a></span><span class="op">(</span><span class="st">"pnad_2015.dta"</span>, col_select <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"uf"</span>, <span class="st">"v0102"</span>, <span class="st">"v0103"</span>, <span class="st">"cor"</span>, <span class="st">"sexo"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p></p>
<p></p>
<pre><code>## # A tibble: 164,204 x 5
##       uf    v0102 v0103        cor          sexo
##    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl+lbl&gt;     &lt;dbl+lbl&gt;
##  1    31 31001718    14 8 [parda]  1 [masculino]
##  2    15 15003760     1 8 [parda]  1 [masculino]
##  3    35 35002425     8 2 [branca] 1 [masculino]
##  4    43 43000126    15 4 [preta]  0 [feminino] 
##  5    33 33001812    18 8 [parda]  1 [masculino]
##  6    17 17000440     3 8 [parda]  1 [masculino]
##  7    15 15002683     3 8 [parda]  1 [masculino]
##  8    15 15003639     6 2 [branca] 1 [masculino]
##  9    22 22000194     7 8 [parda]  0 [feminino] 
## 10    26 26005808     4 8 [parda]  1 [masculino]
## # ... with 164,194 more rows</code></pre>
<p></p>
</div>
</div>
<div id="sec:encoding" class="section level2" number="3.11">
<h2>
<span class="header-section-number">3.11</span> <em>Encoding</em> de caracteres<a class="anchor" aria-label="anchor" href="#sec:encoding"><i class="fas fa-link"></i></a>
</h2>
<p>Quando nós estamos trabalhando com dados em um computador, estamos lidando com registros digitalizados de informação, e esses registros quase sempre contêm letras e palavras, ou simplesmente, variáveis textuais (<em>strings</em> ou caracteres). Dados geográficos, por exemplo, usualmente vem acompanhado de certas informações textuais, como partes de um endereço (cidade, região, rua, etc.), que dão suporte à identificação e localização de certa informação. Como um outro exemplo, dados de uma pesquisa amostral comumente possuem variáveis qualitativas que funcionam como rótulos, e que categorizam cada pessoa entrevistada em um certo grupo (homem ou mulher; branco, pardo, preto, amarelo ou indígena; etc.).</p>
<p>Em uma escala microscópica, as informações presentes em um computador são armazenadas como <em>bytes</em> de informação, que por sua vez são formados por <em>bits</em> de informação, que nada mais são do que combinações específicas de 0’s e 1’s. Com esse fato, eu quero destacar que os nossos computadores não são capazes de guardar diretamente letras, palavras e outros valores textuais. Na verdade, o que os nossos computadores são capazes de guardar, são os códigos binários que em conjunto formam os <em>bytes</em> de informação que representam cada uma das letras, ou cada um dos caracteres que formam a sua palavra, o seu parágrafo ou o seu capítulo. Como exemplo, o nome “Belo Horizonte,” é representado em meu computador através da seguinte sequência de <em>bytes</em>:</p>
<p></p>
<div class="sourceCode" id="cb392"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">"Belo Horizonte"</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 42 65 6c 6f 20 48 6f 72 69 7a 6f 6e 74 65</code></pre>
<p></p>
<p>Cada um dos <em>bytes</em> acima, representam uma letra, e para que o seu computador seja capaz de relacionar cada um desses <em>bytes</em> às respectivas letras que eles representam, ele utiliza um sistema que nós chamamos de <em>encoding</em>. É possível que o sistema operacional de seu computador utilize um sistema de <em>encoding</em> diferente do meu. Com isso, os <em>bytes</em> que representam o nome “Belo Horizonte” em seu computador, podem ser diferentes dos <em>bytes</em> acima.</p>
<div id="sec:fontes_encoding_tipografia" class="section level3" number="3.11.1">
<h3>
<span class="header-section-number">3.11.1</span> Um pouco sobre fontes, <em>encoding</em> e tipografia<a class="anchor" aria-label="anchor" href="#sec:fontes_encoding_tipografia"><i class="fas fa-link"></i></a>
</h3>
<p>Para apresentar visualmente em sua tela, uma palavra ou um texto, o seu computador precisa relacionar caracteres (<em>characters</em>) com os seus respectivos <em>glyphs</em> <span class="citation">(<a href="refer%C3%AAncias.html#ref-haralambous2007" role="doc-biblioref">Haralambous 2007</a>)</span>. Uma fonte que se encontra em seu computador, representa um conjunto de <em>glyphs</em>. Um <em>glyph</em> é uma imagem ou um desenho de cada letra que está definida dentro dessa fonte. Quando você está, por exemplo, escrevendo um novo documento no Word, e você aperta a tecla “A,” um caractere (que corresponde a letra A) é enviado para o seu computador. Após o seu computador descobrir o <em>glyph</em> da fonte que você está utilizando, que corresponde ao caractere A, o Word vai desenhar a palavra A em seu documento, através do <em>glyph</em> que corresponde a esse caractere <span class="citation">(<a href="refer%C3%AAncias.html#ref-haralambous2007" role="doc-biblioref">Haralambous 2007</a>)</span>.</p>
<p>Ou seja, quando as letras A e <code>A</code> aparecem em sua tela, elas representam o mesmo caractere, mas utilizam diferentes <em>glyphs</em> para serem desenhadas na tela de seu computador, pois ambos os caracteres utilizam fontes diferentes. Por um outro ângulo, nós podemos escrever uma frase de mesmo significado em diferentes línguas, porém, muito provavelmente vamos utilizar diferentes caracteres em cada língua. Por exemplo, ao escrevermos “Olá,” “Hello,” “Bonjour” ou “你好,” estamos dizendo a mesma coisa, porém, estamos utilizando caracteres ou letras bem diferentes para tal ato.</p>
<p>Portanto, quando importamos os nossos dados para dentro do R, qualquer informação ou variável textual que esteja presente nesses dados, são guardadas em nosso computador como <em>bytes</em> de informação; e o sistema que o nosso computador utiliza, para traduzir esses <em>bytes</em> de informação, em caracteres, que futuramente serão renderizados em nossa tela, através dos <em>glyphs</em> que os representa, é chamado de <em>encoding</em> <span class="citation">(<a href="refer%C3%AAncias.html#ref-haralambous2007" role="doc-biblioref">Haralambous 2007</a>)</span>.</p>
<p>Os primeiros sistemas de <em>encoding</em> eram capazes de representar apenas as letras de línguas anglo-saxônicas. Porém, a medida em que os chineses precisavam escrever um relatório em sua língua, ou a partir do momento em que o povo nórdico precisava representar em seus computadores os diferentes acentos presentes em seu alfabeto, diversos outros sistemas de <em>encoding</em> foram sendo desenvolvidos ao longo do tempo. Por isso, nós temos hoje uma miscelânia muito grande de sistemas em uso no mundo. Sendo essa confusão, a principal motivação por trás do desenvolvimento do sistema Unicode, que busca universalizar todos esses sistemas em um só <span class="citation">(<a href="refer%C3%AAncias.html#ref-haralambous2007" role="doc-biblioref">Haralambous 2007</a>)</span>.</p>
</div>
<div id="problemas-que-emergem-do-encoding" class="section level3" number="3.11.2">
<h3>
<span class="header-section-number">3.11.2</span> Problemas que emergem do <em>encoding</em><a class="anchor" aria-label="anchor" href="#problemas-que-emergem-do-encoding"><i class="fas fa-link"></i></a>
</h3>
<p>Por que esse assunto é importante dentro da leitura e escrita de arquivos? Porque diferentes arquivos podem utilizar diferentes sistemas de <em>encoding</em>, e se quisermos trabalhar corretamente com os dados textuais presentes nesses arquivos, nós devemos interpretá-los através do sistema de <em>encoding</em> correto.</p>
<p>Quando você lê um arquivo de acordo com um sistema de <em>encoding</em> diferente do sistema que o arquivo de fato utiliza, uma troca de caracteres (ou de letras) ocorre. Com isso, os textos presentes em seu arquivo, ou no nosso caso, em nossos dados, podem ficar bem estapafúrdios. Devido a essa troca de caracteres, há grandes chances de que uma simples pesquisa por algum caractere específico, fique prejudicada.</p>
<p>Como exemplo, eu possuo abaixo um vetor <code>t</code> contendo algumas palavras. Ao utilizar a função <code><a href="https://rdrr.io/r/base/grep.html">grep()</a></code> para pesquisar por qualquer palavra que contenha a letra “Á.” Como resultado, a função nos retorna o número 1, indicando que o primeiro elemento do vetor (a palavra “Árabe”) possui essa letra.</p>
<p></p>
<div class="sourceCode" id="cb394"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Árabe"</span>, <span class="st">"Francês"</span> ,<span class="st">"Japonês"</span>, <span class="st">"Chinês"</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/base/grep.html">grep</a></span><span class="op">(</span><span class="st">"Á"</span>, x <span class="op">=</span> <span class="va">t</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p></p>
<p>Agora, se eu pedir ao R, que interprete o vetor <code>t</code> segundo um <em>encoding</em> diferente, perceba que a função <code><a href="https://rdrr.io/r/base/grep.html">grep()</a></code> não é mais capaz de encontrar uma palavra que contenha a letra “Á.”</p>
<p></p>
<div class="sourceCode" id="cb396"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Encoding.html">Encoding</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="st">"UTF-8"</span>

<span class="va">t</span></code></pre></div>
<pre><code>## [1] "&lt;c1&gt;rabe"   "Franc&lt;ea&gt;s" "Japon&lt;ea&gt;s" "Chin&lt;ea&gt;s"</code></pre>
<div class="sourceCode" id="cb398"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/grep.html">grep</a></span><span class="op">(</span><span class="st">"Á"</span>, x <span class="op">=</span> <span class="va">t</span><span class="op">)</span></code></pre></div>
<pre><code>## integer(0)</code></pre>
<p></p>
<p>Na hipótese de você abrir um arquivo e estar utilizando o <em>encoding</em> incorreto, desde de que você não salve esse arquivo enquanto ele estiver dessa forma, você nãi irá corromper o seu arquivo. Em resumo, se algum caractere de seu texto não estiver da forma como você esperava, não salve o seu arquivo! Antes, você precisa ajustar o <em>encoding</em> de leitura do arquivo, até o momento em que a leitura dos textos presentes em seu arquivo esteja correta.</p>
<p>Apenas para que esse problema fique claro, vamos pegar como exemplo, o arquivo <code>livros.txt</code>, que utiliza o sistema de <em>encoding</em> UTF-8.</p>
<p></p>
<div class="sourceCode" id="cb400"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">livros</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="st">"livros.txt"</span><span class="op">)</span>

<span class="va">livros</span></code></pre></div>
<p></p>
<pre><code># A tibble: 4 x 3
  Titulo                             Autor                       Preco
  &lt;chr&gt;                              &lt;chr&gt;                       &lt;dbl&gt;
1 O Hobbit                           J. R. R. Tolkien             40.7
2 Matemática para Economistas        Carl P. Simon e Lawrence B~ 140. 
3 Microeconomia: uma Abordagem Mode~ Hal R. Varian               141. 
4 A Luneta Âmbar                     Philip Pullman               42.9</code></pre>
<p>Agora, veja abaixo o que acontece se utilizarmos o <em>encoding</em> errado na leitura do arquivo. Alguns sistemas de <em>encoding</em> são relativamente próximos e, por isso, menos trocas tendem a ocorrer em seus textos quando utilizamos o <em>encoding</em> errado. Porém, alguns sistemas são muito divergentes e, portanto, os seus textos podem ficar bem bizarros. Perceba abaixo, que ao utilizarmos o <em>encoding</em> Latin1, apenas as letras acentuadas foram trocadas.</p>
<p></p>
<div class="sourceCode" id="cb402"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">livros</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="st">"livros.txt"</span>, locale <span class="op">=</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/locale.html">locale</a></span><span class="op">(</span>encoding <span class="op">=</span> <span class="st">"Latin1"</span><span class="op">)</span><span class="op">)</span>

<span class="va">livros</span></code></pre></div>
<p></p>
<pre><code># A tibble: 4 x 3
  Titulo                              Autor                      Preco
  &lt;chr&gt;                               &lt;chr&gt;                      &lt;dbl&gt;
1 "O Hobbit"                          J. R. R. Tolkien            40.7
2 "MatemÃ¡tica para Economistas"      Carl P. Simon e Lawrence ~ 140. 
3 "Microeconomia: uma Abordagem Mode~ Hal R. Varian              141. 
4 "A Luneta Ã\u0082mbar"              Philip Pullman              42.9</code></pre>
<p>Portanto, tudo o que precisamos fazer aqui, é voltar para o <em>encoding</em> correto de leitura, ao ajustar o valor utilizado no argumento <code>encoding</code> de <code><a href="https://readr.tidyverse.org/reference/locale.html">locale()</a></code>, como vimos na seção <a href="importando-e-exportando-dados-com-o-r.html#sec:readr_locale">Compreendendo o argumento locale</a>. Em geral, no Brasil se utiliza o sistema ISO-8859-1, ou simplesmente Latin1. Já as funções do pacote <code>readr</code> utilizam por padrão, o sistema UTF-8, por isso, você terá de ajustar o <em>encoding</em> de leitura com certa frequência.</p>
</div>
<div id="a-função-guess_encoding-como-um-possível-guia" class="section level3" number="3.11.3">
<h3>
<span class="header-section-number">3.11.3</span> A função <code>guess_encoding()</code> como um possível guia<a class="anchor" aria-label="anchor" href="#a-fun%C3%A7%C3%A3o-guess_encoding-como-um-poss%C3%ADvel-guia"><i class="fas fa-link"></i></a>
</h3>
<p>Nem sempre temos a sorte de sabermos o <em>encoding</em> utilizado por um certo arquivo. Por isso, o pacote <code>readr</code> oferece a função <code><a href="https://readr.tidyverse.org/reference/encoding.html">guess_encoding()</a></code>, que pode descobrir o <em>encoding</em> utilizado por certo arquivo. Como foi destacado por <span class="citation"><a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">Wickham and Grolemund</a> (<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">2017</a>, p 133)</span>, essa função funciona melhor quando você possui uma quantidade grande de texto no qual ela pode se basear. Além disso, ela não é certeira 100% do tempo, porém, ela lhe oferece um início razoável caso você esteja perdido.</p>
<p>Para utilizar essa função, você precisa fornecer o seu texto como <em>bytes</em>. Ou seja, antes de utilizar essa função, você muito provavelmente terá de converter o seu texto para <em>bytes</em><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Vetores contendo &lt;em&gt;bytes&lt;/em&gt; de informação são comumente chamados de &lt;em&gt;raw vectors&lt;/em&gt; pela comunidade de R.&lt;/p&gt;"><sup>12</sup></a>. Para isso, você pode utilizar a função <code><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw()</a></code>, entretanto, essa função busca transformar um vetor de comprimento 1, logo, para utilizarmos essa função, temos de inserir todos os nossos valores textuais em um único <em>string</em>.</p>
<p>Como exemplo, vamos utilizar a coluna <code>Municípios</code> do arquivo <code>Cod_IBGE.txt</code>, que possui os nomes dos municípios do estado de Minas Gerais. Perceba abaixo, que o arquivo utiliza um <em>encoding</em> diferente do padrão utilizado pela função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2()</a></code>, pois a quarta coluna que deveria se chamar <code>Municípios</code>, foi interpretada como <code>Munic&lt;U+653C&gt;&lt;U+3E64&gt;pios</code>.</p>
<p></p>
<div class="sourceCode" id="cb404"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv2</a></span><span class="op">(</span><span class="st">"Cod_IBGE.txt"</span><span class="op">)</span></code></pre></div>
<p></p>
<pre><code>-- Column specification -----------------------------------
cols(
  IBGE = col_double(),
  IBGE2 = col_double(),
  SEF = col_double(),
  `Munic&lt;U+653C&gt;&lt;U+3E64&gt;pios` = col_character()
)</code></pre>
<p>Para unir todos os nomes de municípios, presentes na coluna <code>Munic&lt;U+653C&gt;&lt;U+3E64&gt;pios</code>, nós podemos utilizar a função <code><a href="https://rdrr.io/r/base/paste.html">paste()</a></code>, de acordo com as especificações abaixo. Em seguida, podemos transformar o resultado de <code><a href="https://rdrr.io/r/base/paste.html">paste()</a></code> em um vetor de <em>bytes</em>, e fornecê-lo para a função <code><a href="https://readr.tidyverse.org/reference/encoding.html">guess_encoding()</a></code>.</p>
<p></p>
<div class="sourceCode" id="cb406"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="va">df</span><span class="op">[[</span><span class="fl">4</span><span class="op">]</span><span class="op">]</span>, collapse <span class="op">=</span> <span class="st">" "</span><span class="op">)</span>

<span class="va">raw</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span>

<span class="fu"><a href="https://readr.tidyverse.org/reference/encoding.html">guess_encoding</a></span><span class="op">(</span><span class="va">raw</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   encoding   confidence
##   &lt;chr&gt;           &lt;dbl&gt;
## 1 ISO-8859-1       0.57
## 2 ISO-8859-2       0.27</code></pre>
<p></p>
<p>Repare que a função nos deu 57% de chance do arquivo <code>Cod_IBGE.txt</code> estar utilizando o <em>encoding</em> ISO-8859-1, que é de fato o <em>encoding</em> utilizado pelo arquivo.</p>
</div>
</div>
<div id="exercícios-2" class="section level2 unnumbered">
<h2>Exercícios<a class="anchor" aria-label="anchor" href="#exerc%C3%ADcios-2"><i class="fas fa-link"></i></a>
</h2>
<blockquote>
<p>Lembre-se que, um arquivo de texto, nada mais é do que um arquivo simples contendo um conjunto de textos. Esses textos são organizados em linhas (onde cada linha representa uma observação diferente), e em cada linha desse arquivo, esses textos são separados em diferentes colunas, através de algum caractere especial, como vírgulas (<code>,</code>), ou pontos e vírgulas (<code>;</code>).</p>
</blockquote>
<p><strong>Questão 3.1.</strong> Como descrevemos ao longo desse capítulo, arquivos de texto são talvez o principal formato de arquivo utilizado hoje para o compartilhamento de dados. Por isso, os próximos exercícios buscam reforçar os conhecimentos a respeito desses arquivos.</p>
<p>3.1.A) Considerando o arquivo de texto contido no objeto <code>t</code> abaixo, qual é o caractere especial que define as colunas desse arquivo? Dado que você tenha identificado esse caractere especial, quais comandos você utilizaria para ler esse arquivo?</p>
<p></p>
<div class="sourceCode" id="cb408"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span> <span class="op">&lt;-</span> <span class="st">"
ID~Valor/Grupo~Unidade
1~2,5488/Marketing~Kg
2~4,0101/Análise~Kg
3~1097/Vendas~g
4~12,76/Logísitica~Kg"</span></code></pre></div>
<p></p>
<p>3.1.B) Perceba abaixo, que os objetos <code>pac1</code> e <code>pac2</code> são praticamente iguais. Perceba também, que estamos utilizando os mesmos comandos de importação para ambos os objetos. Porém, os resultados gerados pela função são diferentes em cada objeto. Tente identificar o que está causando essa diferença. Dado que você tenha identificado a fonte de tal diferença, como você ajustaria os comandos aplicados sobre cada objeto, de forma que os seus resultados sejam exatamente iguais?</p>
<p></p>
<div class="sourceCode" id="cb409"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pac1</span> <span class="op">&lt;-</span> <span class="st">"Setor;Produção;Receita;Gasto em P&amp;D
Produtos alimentícios;10828,37;199907,55;3358,36
Bebidas;759,53;28093,21;
Produtos do fumo;69,99;8863,5;121,35
Produtos têxteis;4153,97;25804,16;746,83
Produtos de madeira;5088,78;15320,69;279,54
Celulose e outras pastas;26,95;4245,19;216,7
Refino de petróleo;75,48;114316,31;1550,73
Produtos químicos;3179,52;133582,8;2914,09
Produtos farmacêuticos;621,82;24972,07;1038,73"</span>


<span class="va">pac2</span> <span class="op">&lt;-</span> <span class="st">"Setor;Produção;Receita;Gasto em P&amp;D
Produtos alimentícios;10.828,37;199907,55;3358,36
Bebidas;759,53;28093,21;x
Produtos do fumo;69,99;8863,5;121,35
Produtos têxteis;4.153,97;25804,16;746,83
Produtos de madeira;5.088,78;15320,69;279,54
Celulose e outras pastas;26,95;4245,19;216,7
Refino de petróleo;75,48;114316,31;1550,73
Produtos químicos;3.179,52;133582,8;2914,09
Produtos farmacêuticos;621,82;24972,07;1038,73"</span>

<span class="fu">readr</span><span class="fu">::</span><span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">pac1</span>, delim <span class="op">=</span> <span class="st">";"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 9 x 4
##   Setor                    Produção  Receita `Gasto em P&amp;D`
##   &lt;chr&gt;                       &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;
## 1 Produtos alimentícios     1082837 19990755         335836
## 2 Bebidas                     75953  2809321             NA
## 3 Produtos do fumo             6999    88635          12135
## 4 Produtos têxteis           415397  2580416          74683
## 5 Produtos de madeira        508878  1532069          27954
## 6 Celulose e outras pastas     2695   424519           2167
## 7 Refino de petróleo           7548 11431631         155073
## 8 Produtos químicos          317952  1335828         291409
## 9 Produtos farmacêuticos      62182  2497207         103873</code></pre>
<div class="sourceCode" id="cb411"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">readr</span><span class="fu">::</span><span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_delim</a></span><span class="op">(</span><span class="va">pac2</span>, delim <span class="op">=</span> <span class="st">";"</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 9 x 4
##   Setor                    Produção  Receita `Gasto em P&amp;D`
##   &lt;chr&gt;                       &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;         
## 1 Produtos alimentícios       10.8  19990755 3358,36       
## 2 Bebidas                  75953     2809321 x             
## 3 Produtos do fumo          6999       88635 121,35        
## 4 Produtos têxteis             4.15  2580416 746,83        
## 5 Produtos de madeira          5.09  1532069 279,54        
## 6 Celulose e outras pastas  2695      424519 216,7         
## 7 Refino de petróleo        7548    11431631 1550,73       
## 8 Produtos químicos            3.18  1335828 2914,09       
## 9 Produtos farmacêuticos   62182     2497207 1038,73</code></pre>
<p></p>
<p>3.1.C) Considerando que você tenha chamado com sucesso pelo pacote <code>readr</code>, com o comando <code><a href="https://rdrr.io/r/base/library.html">library()</a></code>, você será capaz de executar os comandos mostrados abaixo sem problemas. Tais comandos buscam importar para o R, um arquivo chamado <code>challenge.csv</code> (a função <code><a href="https://readr.tidyverse.org/reference/readr_example.html">readr_example()</a></code> nos traz a localização desse arquivo <code>challenge.csv</code> em seu computador). Porém, perceba pelo resultado abaixo, que erros de importação ocorreram em 1000 linhas do arquivo.</p>
<p></p>
<div class="sourceCode" id="cb413"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">import</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span><span class="fu"><a href="https://readr.tidyverse.org/reference/readr_example.html">readr_example</a></span><span class="op">(</span><span class="st">"challenge.csv"</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>Ao navegar por todo o conteúdo desse arquivo <code>challenge.csv</code>, você pode perceber que os dados contidos nesse arquivo foram incorretamente interpretados pela função <code><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv()</a></code>. Com isso, o seu trabalho será descobrir o que deu errado nesse processo, e ajustar os comandos de importação desse arquivo para que esse erro não ocorra.</p>
<p>Como uma dica, abra o arquivo <code><a href="https://readr.tidyverse.org/reference/readr_example.html">readr_example("challenge.csv")</a></code> e veja o seu conteúdo com cuidado. Com os comandos abaixo, você pode navegar por esse arquivo em uma janela de seu próprio RStudio. Portanto, tente descobrir o que está acontecendo de errado, e crie um comando que possa corrigir esse problema de importação.</p>
<p></p>
<div class="sourceCode" id="cb414"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/file.edit.html">file.edit</a></span><span class="op">(</span><span class="fu"><a href="https://readr.tidyverse.org/reference/readr_example.html">readr_example</a></span><span class="op">(</span><span class="st">"challenge.csv"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p></p>
<p>3.1.D) Considerando o objeto <code>t</code> abaixo, como você faria para importar corretamente esse arquivo? Vale ressaltar, que temos uma coluna contendo datas dentro do objeto <code>t</code>, e, até o momento, nós ainda não discutimos como o R interpreta ou lida com esse tipo de varíavel. Tal discussão é feita no capítulo 12 (<a href="introdu%C3%A7%C3%A3o-%C3%A0-vari%C3%A1veis-de-tempo-com-lubridate.html#sec:lubridate_var_tempo">Introdução à variáveis de tempo com <code>lubridate</code></a>). Portanto, não se preocupe caso você não consiga importar especificamente essa coluna da maneira correta. De qualquer maneira, ao final desse livro, nós fornecemos todo o código necessário para interpretar corretamente essa coluna.</p>
<p></p>
<div class="sourceCode" id="cb415"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span> <span class="op">&lt;-</span> <span class="st">"Data_execução*Unidades*Valor_compra
20/01/2020*21*R$ 3049,50
23/01/2020*502*R$ 1289,03
25/01/2020*90*R$ 678,00
02/02/2020*123*R$ 5401
05/02/2020*45*R$ 1450,10
07/02/2020*67*R$ 2320,97
09/02/2020*187*R$ 6231,76"</span></code></pre></div>
<p></p>
<p><strong>Questão 3.2.</strong> Copie e cole o endereço URL abaixo em seu navegador de preferência. Com esse link, uma planilha em Excel será baixada. Nessa planilha, temos alguns dados referentes aos municípios de Minas Gerais, ou, mais especificamente, a como esses municípios se encaixam no critério de Produção de Alimentos no âmbito da lei estadual 18.030/2009. Tente criar um comando que possa importar corretamente os dados dessa planilha para o R.</p>
<p>(<a href="https://github.com/pedropark99/Curso-R/blob/master/Dados/emater_icms_solidario.xlsx?raw=true" class="uri">https://github.com/pedropark99/Curso-R/blob/master/Dados/emater_icms_solidario.xlsx?raw=true</a>)</p>

</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="fundamentos-da-linguagem-r.html"><span class="header-section-number">2</span> Fundamentos da Linguagem R</a></div>
<div class="next"><a href="transformando-dados-com-dplyr.html"><span class="header-section-number">4</span> Transformando dados com dplyr</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#importando-e-exportando-dados-com-o-r"><span class="header-section-number">3</span> Importando e exportando dados com o R</a></li>
<li><a class="nav-link" href="#sec:importando_dados"><span class="header-section-number">3.1</span> Introdução e pré-requisitos</a></li>
<li><a class="nav-link" href="#fontes-de-dados"><span class="header-section-number">3.2</span> Fontes de dados</a></li>
<li><a class="nav-link" href="#diret%C3%B3rio-de-trabalho"><span class="header-section-number">3.3</span> Diretório de trabalho</a></li>
<li>
<a class="nav-link" href="#sec:enderecos_disco_rigido"><span class="header-section-number">3.4</span> Definindo endereços do disco rígido no R</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#cuidados-ao-definir-endere%C3%A7os"><span class="header-section-number">3.4.1</span> Cuidados ao definir endereços</a></li>
<li><a class="nav-link" href="#endere%C3%A7os-relativos-e-absolutos"><span class="header-section-number">3.4.2</span> Endereços relativos e absolutos</a></li>
</ul>
</li>
<li><a class="nav-link" href="#plataforma-de-projetos-do-rstudio"><span class="header-section-number">3.5</span> Plataforma de Projetos do RStudio</a></li>
<li>
<a class="nav-link" href="#importando-arquivos-de-texto-com-readr"><span class="header-section-number">3.6</span> Importando arquivos de texto com readr</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#definindo-os-tipos-de-dados-em-cada-coluna"><span class="header-section-number">3.6.1</span> Definindo os tipos de dados em cada coluna</a></li>
<li><a class="nav-link" href="#sec:readr_locale"><span class="header-section-number">3.6.2</span> Compreendendo o argumento locale</a></li>
<li><a class="nav-link" href="#outras-configura%C3%A7%C3%B5es-envolvendo-linhas-e-colunas"><span class="header-section-number">3.6.3</span> Outras configurações envolvendo linhas e colunas</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#sec:estudo_pnad_continua"><span class="header-section-number">3.7</span> Um estudo de caso: lendo os microdados da PNAD Contínua com read_fwf()</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#conhecendo-a-estrutura-dos-microdados"><span class="header-section-number">3.7.1</span> Conhecendo a estrutura dos microdados</a></li>
<li><a class="nav-link" href="#extraindo-especifica%C3%A7%C3%B5es-de-um-script-sas"><span class="header-section-number">3.7.2</span> Extraindo especificações de um script SAS</a></li>
<li><a class="nav-link" href="#o-pacote-sascii-como-um-atalho-%C3%BAtil"><span class="header-section-number">3.7.3</span> O pacote SAScii como um atalho útil</a></li>
<li><a class="nav-link" href="#importando-os-microdados-da-pnad-cont%C3%ADnua"><span class="header-section-number">3.7.4</span> Importando os microdados da PNAD Contínua</a></li>
<li><a class="nav-link" href="#analisando-erros-de-importa%C3%A7%C3%A3o"><span class="header-section-number">3.7.5</span> Analisando erros de importação</a></li>
</ul>
</li>
<li><a class="nav-link" href="#exportando-os-seus-dados-com-o-pacote-readr"><span class="header-section-number">3.8</span> Exportando os seus dados com o pacote readr</a></li>
<li>
<a class="nav-link" href="#sec:read_excel"><span class="header-section-number">3.9</span> Importando planilhas do Excel com readxl</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#delimitando-a-parte-de-seu-arquivo-.xlsx"><span class="header-section-number">3.9.1</span> Delimitando a parte de seu arquivo .xlsx</a></li>
<li><a class="nav-link" href="#definindo-os-tipos-de-dados-contidos-em-cada-coluna"><span class="header-section-number">3.9.2</span> Definindo os tipos de dados contidos em cada coluna</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#importando-arquivos-do-spss-stata-e-sas-com-o-pacote-haven"><span class="header-section-number">3.10</span> Importando arquivos do SPSS, Stata e SAS com o pacote haven</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#tratando-vari%C3%A1veis-rotuladas"><span class="header-section-number">3.10.1</span> Tratando variáveis rotuladas</a></li>
<li><a class="nav-link" href="#delimitando-partes-do-arquivo"><span class="header-section-number">3.10.2</span> Delimitando partes do arquivo</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#sec:encoding"><span class="header-section-number">3.11</span> Encoding de caracteres</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#sec:fontes_encoding_tipografia"><span class="header-section-number">3.11.1</span> Um pouco sobre fontes, encoding e tipografia</a></li>
<li><a class="nav-link" href="#problemas-que-emergem-do-encoding"><span class="header-section-number">3.11.2</span> Problemas que emergem do encoding</a></li>
<li><a class="nav-link" href="#a-fun%C3%A7%C3%A3o-guess_encoding-como-um-poss%C3%ADvel-guia"><span class="header-section-number">3.11.3</span> A função guess_encoding() como um possível guia</a></li>
</ul>
</li>
<li><a class="nav-link" href="#exerc%C3%ADcios-2">Exercícios</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/pedropark99/Introducao_R//blob/master/03-importacao.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/pedropark99/Introducao_R//edit/master/03-importacao.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Introdução à Linguagem R: seus fundamentos e sua prática</strong>" was written by Pedro Faria. It was last built on 2021-08-14.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>
</html>
