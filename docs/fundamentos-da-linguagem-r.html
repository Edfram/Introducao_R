<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Capítulo 2 Fundamentos da Linguagem R | Introdução à Linguagem R: seus fundamentos e sua prática</title>
<meta name="author" content="Pedro Faria">
<meta name="description" content="2.1 Introdução Nas próximas seções vou abordar os fundamentos da linguagem: os básicos de sua sintaxe, quais são as estruturas e tipos de dados que a linguagem oferece, e como as suas regras de...">
<meta name="generator" content="bookdown 0.34 with bs4_book()">
<meta property="og:title" content="Capítulo 2 Fundamentos da Linguagem R | Introdução à Linguagem R: seus fundamentos e sua prática">
<meta property="og:type" content="book">
<meta property="og:url" content="bem-vindo.html/fundamentos-da-linguagem-r.html">
<meta property="og:image" content="bem-vindo.html/capa.png">
<meta property="og:description" content="2.1 Introdução Nas próximas seções vou abordar os fundamentos da linguagem: os básicos de sua sintaxe, quais são as estruturas e tipos de dados que a linguagem oferece, e como as suas regras de...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Capítulo 2 Fundamentos da Linguagem R | Introdução à Linguagem R: seus fundamentos e sua prática">
<meta name="twitter:description" content="2.1 Introdução Nas próximas seções vou abordar os fundamentos da linguagem: os básicos de sua sintaxe, quais são as estruturas e tipos de dados que a linguagem oferece, e como as suas regras de...">
<meta name="twitter:image" content="bem-vindo.html/capa.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.5.0/transition.js"></script><script src="libs/bs3compat-0.5.0/tabs.js"></script><script src="libs/bs3compat-0.5.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
          margin-bottom: 1em;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Introdução à Linguagem R: seus fundamentos e sua prática</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Bem vindo!</a></li>
<li><a class="" href="como-citar-a-obra.html">Como citar a obra</a></li>
<li><a class="" href="sobre-o-autor.html">Sobre o autor</a></li>
<li><a class="" href="pref%C3%A1cio.html">Prefácio</a></li>
<li class="book-part">Introduzindo a Linguagem R</li>
<li><a class="" href="no%C3%A7%C3%B5es-b%C3%A1sicas-do-r.html"><span class="header-section-number">1</span> Noções Básicas do R</a></li>
<li><a class="active" href="fundamentos-da-linguagem-r.html"><span class="header-section-number">2</span> Fundamentos da Linguagem R</a></li>
<li class="book-part">Importando, organizando e transformando dados</li>
<li><a class="" href="introduzindo-o-universo-do-tidyverse.html"><span class="header-section-number">3</span> Introduzindo o universo do tidyverse</a></li>
<li><a class="" href="importando-e-exportando-dados-com-readr-readxl-e-haven.html"><span class="header-section-number">4</span> Importando e exportando dados com readr, readxl e haven</a></li>
<li><a class="" href="transformando-dados-com-dplyr.html"><span class="header-section-number">5</span> Transformando dados com dplyr</a></li>
<li><a class="" href="introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-com-dplyr.html"><span class="header-section-number">6</span> Introdução a base de dados relacionais com dplyr</a></li>
<li><a class="" href="tidy-data-uma-abordagem-para-organizar-os-seus-dados-com-tidyr.html"><span class="header-section-number">7</span> Tidy Data: uma abordagem para organizar os seus dados com tidyr</a></li>
<li class="book-part">Visualizando seus dados</li>
<li><a class="" href="visualiza%C3%A7%C3%A3o-de-dados-com-ggplot2.html"><span class="header-section-number">8</span> Visualização de dados com ggplot2</a></li>
<li><a class="" href="configurando-componentes-est%C3%A9ticos-do-gr%C3%A1fico-no-ggplot2.html"><span class="header-section-number">9</span> Configurando componentes estéticos do gráfico no ggplot2</a></li>
<li class="book-part">Ferramentas para tipos específicos de dados</li>
<li><a class="" href="manipula%C3%A7%C3%A3o-e-transforma%C3%A7%C3%A3o-de-strings-com-stringr.html"><span class="header-section-number">10</span> Manipulação e transformação de strings com stringr</a></li>
<li><a class="" href="introduzindo-fatores-factors-com-forcats.html"><span class="header-section-number">11</span> Introduzindo fatores (factor’s) com forcats</a></li>
<li><a class="" href="introdu%C3%A7%C3%A3o-%C3%A0-vari%C3%A1veis-de-tempo-com-lubridate.html"><span class="header-section-number">12</span> Introdução à variáveis de tempo com lubridate</a></li>
<li class="book-part">Funções e Loops: construindo os seus próprios programas e automatizando tarefas</li>
<li><a class="" href="controle-condicional-de-fluxo.html"><span class="header-section-number">13</span> Controle condicional de fluxo</a></li>
<li><a class="" href="fun%C3%A7%C3%B5es.html"><span class="header-section-number">14</span> Funções</a></li>
<li><a class="" href="loops.html"><span class="header-section-number">15</span> Loops</a></li>
<li><a class="" href="functional-programming-com-purrr.html"><span class="header-section-number">16</span> Functional programming com purrr</a></li>
<li><a class="" href="debugging---resolvendo-bugs-em-suas-fun%C3%A7%C3%B5es.html"><span class="header-section-number">17</span> Debugging - Resolvendo bugs em suas funções</a></li>
<li><a class="" href="environments-ou-ambientes-no-r.html"><span class="header-section-number">18</span> Environments ou ambientes no R</a></li>
<li class="book-part">Respostas dos exercícios de cada capítulo</li>
<li><a class="" href="respostas.html">Respostas</a></li>
<li class="book-part">Apêndices</li>
<li><a class="" href="pnad-cont%C3%ADnua-arquivo-csv-para-input.html"><span class="header-section-number">A</span> PNAD Contínua: arquivo CSV para input</a></li>
<li><a class="" href="refer%C3%AAncias.html">Referências</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/pedropark99/Introducao_R/">View book source <i class="fas fa-book-open"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="fundamentos-da-linguagem-r" class="section level1" number="2">
<h1>
<span class="header-section-number">Capítulo 2</span> Fundamentos da Linguagem R<a class="anchor" aria-label="anchor" href="#fundamentos-da-linguagem-r"><i class="fas fa-link"></i></a>
</h1>
<div id="sec:fundamentos_R" class="section level2" number="2.1">
<h2>
<span class="header-section-number">2.1</span> Introdução<a class="anchor" aria-label="anchor" href="#sec:fundamentos_R"><i class="fas fa-link"></i></a>
</h2>
<p>Nas próximas seções vou abordar os fundamentos da linguagem: os básicos de sua sintaxe, quais são as estruturas e tipos de dados que a linguagem oferece, e como as suas regras de <em>coercion</em> funcionam.</p>
<p>Na maior parte de sua análise, você não vai estar interessado em como o R está estruturando ou interpretando os seus dados em um dado momento. Porém, várias das funções ou ações que você deseja aplicar, exigem que os seus dados estejam estruturados em uma forma específica. Logo, ter familiaridade com os fundamentos do R, com as suas estruturas e suas propriedades, e principalmente, poder reconhecê-las, vai te salvar muito tempo. Com esse conhecimento, será mais fácil de você evitar erros, e será mais fácil de identificar e transformar a estrutura de seus dados para qualquer que seja a sua necessidade em um dado momento de sua análise.</p>
<p>Tendo isso em mente, além de introduzir a linguagem, as próximas seções também tem como objetivo, lhe fornecer uma base sólida desses fundamentos, para que você possa identificar e transitar entre essas diversas estruturas e tipos de dados, de forma fluida.</p>
</div>
<div id="mais-detalhes-sobre-objetos" class="section level2" number="2.2">
<h2>
<span class="header-section-number">2.2</span> Mais detalhes sobre objetos<a class="anchor" aria-label="anchor" href="#mais-detalhes-sobre-objetos"><i class="fas fa-link"></i></a>
</h2>
<p>Uma das principais características do R, é que ele é uma linguagem orientada a objetos (<em>object oriented</em>). Isto significa, que quando você estiver trabalhando com seus dados no R, você estará aplicando operações e transformações sobre os objetos onde seus dados estão guardados.</p>
<p>Os objetos no R, são como as caixas que você utiliza na sua mudança. Você guarda algo dentro dessa caixa, e coloca um adesivo com um nome para essa caixa, para que você se lembre do que está dentro dela. No dia seguinte à mudança, quando você precisar do conteúdo que está guardado naquela caixa, você procura essa caixa pelo nome que você deu a ela.</p>
<p>No exemplo abaixo, eu estou criando um objeto, que dou o nome de <code>data_aniversario</code>, e estou utilizando o símbolo <code>&lt;-</code> para definir o valor deste objeto para a data de aniversário de um amigo importante (20 de maio). O símbolo <code>&lt;-</code> é comumente chamado de <em>assignment</em>, e significa que estamos atribuindo um valor a um objeto (no caso abaixo, <code>data_aniversario</code>). Em outras palavras, os comandos abaixo, podem ser lidos como: eu atribuo ao objeto de nome <code>data_aniversario</code>, o valor de <code>"20 de maio"</code>. Após isso, sempre que eu chamar por esse nome, o R irá procurar por uma caixa (ou um objeto) que possui um adesivo com um nome de <code>data_aniversario</code>. Quando ele encontrar essa caixa, ele irá me retornar no console o que tem dentro dessa caixa (ou desse objeto).</p>
<p></p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_aniversario</span> <span class="op">&lt;-</span> <span class="st">"20 de maio"</span></span>
<span></span>
<span><span class="co">### Quando eu chamo pelo nome deste objeto</span></span>
<span><span class="co">### no console, o R me retorna o que tem dentro dele.</span></span>
<span><span class="va">data_aniversario</span></span></code></pre></div>
<pre><code>## [1] "20 de maio"</code></pre>
<p></p>
<p>O conceito de objeto é uma metáfora, ou uma forma útil de enxergarmos este sistema. Pois para o R, o nome <code>data_aniversario</code> se trata apenas uma conexão até o valor (<code>"20 de maio"</code>). Para demonstrarmos essa ideia, vamos utilizar os endereços desses objetos. Isto é, todos os valores contidos nos objetos que você cria em sua sessão do R, vão obrigatoriamente ocupar um espaço, ou um endereço da memória RAM de seu computador. Enquanto este objeto estiver “vivo”, ou seja, enquanto esta conexão entre o nome <code>x</code> e os seus valores permanecer acessível em sua sessão, esses valores vão estar ocupando um endereço específico de sua memória RAM. Para descobrirmos esse endereço, nós podemos utilizar a função <code><a href="https://lobstr.r-lib.org/reference/ref.html">ref()</a></code> do pacote <code>lobstr</code>. Vamos supor por exemplo, que nós criamos um vetor chamado <code>x</code>, que contém três números. Perceba abaixo pelo resultado da função <code><a href="https://lobstr.r-lib.org/reference/ref.html">ref()</a></code>, que ao criar este objeto <code>x</code>, os seus valores foram alocados no endereço <code>0x1ca169c03d8</code> da minha memória RAM.</p>
<p></p>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://lobstr.r-lib.org/">lobstr</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">6</span>, <span class="fl">7</span>, <span class="fl">8</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://lobstr.r-lib.org/reference/ref.html">ref</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span></code></pre></div>
<p></p>
<pre><code>## [1:0x1ca169c03d8] &lt;dbl&gt; </code></pre>
<p>Portanto, um objeto no R, nada mais é do que uma conexão entre um nome e valores que estão guardados em um endereço da memória RAM de seu computador. Os únicos momentos em que este endereço muda, serão todas as vezes em que você reiniciar a sua sessão no R, ou todas vezes em que você executar novamente os códigos necessários para criar os seus objetos. Tendo isso em mente, em uma representação visual, um objeto no R pode ser representado pela figura 2.1.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-55"></span>
<img src="Figuras/objetos_1.png" alt="Representação de um objeto" width="60%"><p class="caption">
Figura 2.1: Representação de um objeto
</p>
</div>
<p></p>
<p>Para desenvolvermos essa ideia, pense o que ocorreria, se atribuíssemos os valores do objeto <code>x</code>, a um novo objeto. Segundo essa perspectiva, nós estaríamos apenas conectando o vetor com os valores 6, 7 e 8, a um novo nome, no exemplo abaixo, ao nome <code>y</code>. Nós poderíamos utilizar novamente a função <code><a href="https://lobstr.r-lib.org/reference/ref.html">ref()</a></code> para conferirmos o endereço onde os valores do objeto <code>y</code>, se encontram, e perceba que eles estão no mesmo local que os valores do objeto <code>x</code>.</p>
<p></p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">x</span></span>
<span></span>
<span><span class="fu"><a href="https://lobstr.r-lib.org/reference/ref.html">ref</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span></code></pre></div>
<p></p>
<pre><code>## [1:0x1ca169c03d8] &lt;dbl&gt; </code></pre>
<p>Logo, se atualizarmos a nossa representação visual, temos o seguinte resultado:</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-57"></span>
<img src="Figuras/objetos_2.png" alt="Conectando mais nomes a um mesmo conjunto de valores" width="60%"><p class="caption">
Figura 2.2: Conectando mais nomes a um mesmo conjunto de valores
</p>
</div>
<p></p>
<p>Em outras palavras, o R em nenhum momento criou uma cópia do vetor contendo os valores 6, 7 e 8, e alocou essa cópia no objeto <code>y</code>. Ele apenas conectou um novo nome (<code>y</code>) a esse vetor de valores. Por isso, quando você possui um objeto, e atribui um novo valor a este objeto, você está na verdade eliminando a conexão que o nome deste objeto possuía com o valor que estava guardado anteriormente naquele objeto. Ou seja, se você retornar ao vetor <code>x</code>, e definir um novo valor para ele, você estaria eliminando a sua conexão com o vetor que contém os números 6, 7 e 8, e atribuindo essa conexão a um outro conjunto de valores. Por exemplo, caso eu executasse o comando <code>x &lt;- "Hello World"</code>, o resultado seria uma nova conexão como você pode ver pela figura 2.3.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-58"></span>
<img src="Figuras/objetos_3.png" alt="Atribuindo novos valores a seus objetos" width="60%"><p class="caption">
Figura 2.3: Atribuindo novos valores a seus objetos
</p>
</div>
<p></p>
<p>O R vai jogar fora, qualquer valor que não esteja conectado a um nome, ou a um objeto em sua sessão. Logo, tendo em mente a figura 2.3, caso eu atribuísse um novo valor ao objeto <code>y</code>, a última conexão até o vetor que contém os números 6, 7 e 8, seria eliminada. Com isso, este vetor não possuiria mais nenhuma conexão até um nome e, por isso, seria descartado pelo R. Portanto, se você precisa atribuir um novo valor para um determinado objeto, mas deseja manter o valor que você deu a ele anteriormente, basta que você crie uma nova conexão até o valor antigo. Em outras palavras, se você quer manter este valor, basta conectá-lo a um novo objeto.</p>
<p>No exemplo abaixo, eu crio um objeto (<code>economista_1</code>) contendo o nome de um economista famoso, e em seguida conecto este nome a um novo objeto (<code>economista_anterior</code>). Portanto, o nome de Keynes está agora conectado a dois nomes, ou está contido em dois objetos diferentes em sua sessão no R. Por último, eu sobreponho o nome de Keynes que guardei no primeiro objeto (<code>economista_1</code>), pelo nome de outro economista famoso. Quando faço isso, estou efetivamente eliminando uma das conexões até o nome de Keynes, e atribuindo essa conexão ao nome de Schumpeter. Porém, como o nome de Keynes ainda possui uma conexão existente (<code>economista_anterior</code>), o nome continua “vivo” e presente em nossa sessão, e se quisermos acessar novamente esse nome, basta chamarmos pelo objeto onde o salvamos.</p>
<p></p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Primeiro valor</span></span>
<span><span class="va">economista_1</span> <span class="op">&lt;-</span> <span class="st">"John Maynard Keynes"</span></span>
<span></span>
<span><span class="co"># Atribuindo o primeiro valor a um novo</span></span>
<span><span class="co"># objeto</span></span>
<span><span class="va">economista_anterior</span> <span class="op">&lt;-</span> <span class="va">economista_1</span></span>
<span></span>
<span><span class="co"># Sobrepondo o primeiro valor no</span></span>
<span><span class="co"># primeiro objeto com um novo nome</span></span>
<span><span class="va">economista_1</span> <span class="op">&lt;-</span> <span class="st">"Joseph Alois Schumpeter"</span></span>
<span></span>
<span><span class="va">economista_1</span></span></code></pre></div>
<pre><code>## [1] "Joseph Alois Schumpeter"</code></pre>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">economista_anterior</span></span></code></pre></div>
<pre><code>## [1] "John Maynard Keynes"</code></pre>
<p></p>
</div>
<div id="como-o-r-organiza-e-interpreta-os-seus-dados" class="section level2" number="2.3">
<h2>
<span class="header-section-number">2.3</span> Como o R organiza e interpreta os seus dados<a class="anchor" aria-label="anchor" href="#como-o-r-organiza-e-interpreta-os-seus-dados"><i class="fas fa-link"></i></a>
</h2>
<p>Em resumo, o R possui diferentes formas de estruturar (ou de organizar) os dados que você fornece a ele. Essas formas são o que estou chamando de estruturas de dados. Quando estamos decidindo em qual estrutura devemos armazenar os nossos dados, estamos basicamente fazendo o processo mental descrito na figura 2.4:</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-60"></span>
<img src="Figuras/talvez_um_vetor.png" alt="Estruturas de dados" width="80%"><p class="caption">
Figura 2.4: Estruturas de dados
</p>
</div>
<p></p>
<p>Além da forma como os nossos dados estão organizados dentro de uma estrutura do R, nós também podemos estar interessados em como o R está interpretando esses dados, em um dado momento. Isso é uma questão extremamente relevante, na medida em que diferentes funções esperam como <em>input</em>, um tipo de dado específico, ou também, pelo fato do R aplicar (em alguns casos) diferentes “versões” de uma mesma função, a depender do tipo associado aos seus dados.</p>
<p>Portanto, estamos nos perguntando qual o tipo de dado que o R está associando a um certo conjunto de valores, e em muitas ocasiões podemos nos surpreender com as escolhas da linguagem. Uma surpresa, que está representada na figura 2.5. Como exemplo, quando eu vejo o valor <code>"20/05/2020"</code>, eu rapidamente o associo à data 20 de maio de 2020, mas será que o R compreende que este valor se trata de uma data? A resposta curta é, não.</p>
<p>Pelo fato das datas não estarem entre os tipos de dados básicos do R, valores como <code>"20/05/2020"</code> são tratados inicialmente como simples textos (isto é, valores do tipo <code>character</code>), enquanto não dissermos explicitamente para o R, que esses valores se tratam de datas. Isso é um ponto importante, pois várias funções ou ações que queremos executar no R, exigem que os seus dados estejam no tipo adequado. Por isso, você vai enfrentar diversas situações onde o console lhe retorna um erro confuso, e depois de alguns minutos, você busca conferir a estrutura de seus dados, e supreendentemente descobre que o R estava o tempo todo interpretando os seus números como textos!</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-61"></span>
<img src="Figuras/tipos_dados.png" alt="Tipos de dados" width="80%"><p class="caption">
Figura 2.5: Tipos de dados
</p>
</div>
<p></p>
<p>Portanto, vamos começar descrevendo nas próximas seções as estruturas de dados presentes na linguagem e, em seguida, os tipos de dados básicos do R. Nessas seções, não vamos incluir uma estrutura do R em específico, que é o <code>array</code>. Nós veremos mais a frente, as matrizes (<code>matrix</code>), que no fundo são um caso especial de <code>array</code>. Enquanto matrizes são vetores com duas dimensões (uma dimensão para as linhas e outra para as colunas), os <code>array</code> são vetores com “n” dimensões. Em outras palavras, com um <code>array</code> você pode criar um objeto tridimensional (3 dimensões), ou se quiser ir longe, um objeto com 4, 5, ou infinitas dimensões.</p>
</div>
<div id="sec:estruturas_dados" class="section level2" number="2.4">
<h2>
<span class="header-section-number">2.4</span> Estruturas de dados<a class="anchor" aria-label="anchor" href="#sec:estruturas_dados"><i class="fas fa-link"></i></a>
</h2>
<div id="sec:vetores_estrutura" class="section level3" number="2.4.1">
<h3>
<span class="header-section-number">2.4.1</span> Vetores<a class="anchor" aria-label="anchor" href="#sec:vetores_estrutura"><i class="fas fa-link"></i></a>
</h3>
<p>Os vetores são a estrutura básica da linguagem R, pois todas as outras estruturas, são construídas a partir desses vetores. Um vetor é simplesmente uma sequência de valores. Valores que podem ser datas, números, textos, índices, ou qualquer outro tipo que você imaginar. Pelo fato de ser uma simples sequência de valores, o vetor é uma estrutura unidimensional. É como se esse vetor fosse composto por apenas uma coluna, que você preenche com quantas linhas você precisar. Ou então, você também pode imaginá-lo como uma corda, que amarra e mantém os seus valores conectados um atrás do outro.</p>
<p>A forma mais simples de se criar um vetor, é através da função <code><a href="https://rdrr.io/r/base/c.html">c()</a></code> (abreviação para <em>combine</em>, ou combinar), em que você fornece os valores que quer incluir neste vetor, separando-os por vírgulas. A outra forma (indireta) de se criar um vetor, é através de funções que retornam por padrão este tipo de estrutura. Um exemplo simples, é a função <code>:</code> que serve para criar sequências numéricas no R, no exemplo abaixo, uso essa função para criar uma sequência de 1 a 10. Outro exemplo, seria a função <code><a href="https://rdrr.io/r/base/rep.html">rep()</a></code> que serve para repetir um conjunto de valores, por quantas vezes você quiser.</p>
<p></p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">48</span>, <span class="fl">24</span>, <span class="fl">12</span>, <span class="fl">6</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 48 24 12  6</code></pre>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "a" "b" "c" "d"</code></pre>
<div class="sourceCode" id="cb86"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span></span></code></pre></div>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Eduardo"</span><span class="op">)</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<pre><code>##  [1] "Ana"     "Eduardo" "Ana"     "Eduardo" "Ana"     "Eduardo" "Ana"    
##  [8] "Eduardo" "Ana"     "Eduardo"</code></pre>
<p></p>
<p>Como o vetor é uma estrutura unidimensional, eu posso acessar um único valor dentro desse vetor, utilizando apenas um índice. Por exemplo, se eu quero extrair o quarto valor dessa sequência, eu utilizo o número 4, se eu quero o terceiro valor, o número 3, e assim por diante. Para acessar “partes”, ou um único valor de uma estrutura no R, nós utilizamos a função <code>[</code>, e para utilizá-la, basta abrir colchetes após o nome do objeto onde você salvou este vetor, ou após a função que está gerando este vetor.</p>
<p></p>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10</span></span>
<span></span>
<span><span class="va">vetor</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span><span class="op">)</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] "c"</code></pre>
<p></p>
<p>Para acessar mais de um valor dentro deste vetor, você terá que fornecer um novo vetor de índices à função <code>[</code>. Um jeito prático de criar este novo vetor de índices, é criando uma sequência com a função <code>:</code> que vimos anteriormente. Um detalhe, é que o R irá extrair os valores na ordem em que você os dá a <code>[</code>. Logo, se eu dentro de <code>[</code> incluir o vetor <code>c(2,4,6,1)</code>, o R irá lhe retornar um novo vetor, que contém o segundo, quarto, sexto e primeiro item do vetor anterior, respectivamente. Caso você repita algum índice, o R irá repetir o valor dentro do vetor resultante, e não te avisará sobre isso.</p>
<p></p>
<div class="sourceCode" id="cb94"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">25</span></span>
<span></span>
<span><span class="va">vetor</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 1 2 3 4</code></pre>
<div class="sourceCode" id="cb96"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span><span class="op">[</span><span class="fl">8</span><span class="op">:</span><span class="fl">13</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1]  8  9 10 11 12 13</code></pre>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">4</span>,<span class="fl">4</span>,<span class="fl">1</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 2 4 4 1</code></pre>
<p></p>
<p>Os vetores que estamos criando com essas funções são comumente chamados de vetores atômicos (<em>atomic vector</em>). Esses vetores possuem uma propriedade simples e importante: <strong>vetores atômicos possuem apenas um único tipo de dado dentro deles</strong>. Você não consegue guardar dentro de um mesmo vetor, valores de dois tipos de dados diferentes (por exemplo, textos e números) sem que alguma transformação ocorra. Caso você tente burlar essa regra, o R irá automaticamente converter os valores para um único tipo de dado, e pode ser que parte desses dados não possam ser convertidos de forma lógica para este único tipo, e acabam sendo “perdidos” neste processo. Falaremos mais sobre esse processo de conversão, quando chegarmos em tipos de dados.</p>
</div>
<div id="matrizes" class="section level3" number="2.4.2">
<h3>
<span class="header-section-number">2.4.2</span> Matrizes<a class="anchor" aria-label="anchor" href="#matrizes"><i class="fas fa-link"></i></a>
</h3>
<p>Matrizes nada mais são do que vetores com duas dimensões. Se você possui dados atualmente alocados em um vetor, e deseja organizá-los em colunas e linhas, você pode rapidamente criar uma matriz com este vetor, ao adicionar dimensões a ele, através da função <code><a href="https://rdrr.io/r/base/dim.html">dim()</a></code>. Você usa a função sobre o vetor desejado à esquerda do símbolo de <em>assignment</em> (<code>&lt;-</code>), e atribui um valor ao resultado dessa função. No caso de matrizes, esse valor será um vetor com dois elementos, o primeiro definindo o número de linhas, e o segundo, o número de colunas.</p>
<p></p>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">6</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">vetor</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vetor</span></span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6</code></pre>
<p></p>
<p>Uma outra forma de criar uma matriz, é através da função <code><a href="https://rdrr.io/r/base/matrix.html">matrix()</a></code>. Você primeiro fornece um vetor à função, e define quantas colunas você deseja em <code>ncol</code>, e quantas linhas em <code>nrow</code>. Um detalhe que fica claro no exemplo abaixo, é que ao criar uma matriz, ela por padrão será preenchida por coluna, e não por linha. Caso você queira que ela seja preenchida por linha, você deve adicionar o valor <code>TRUE</code>, ao argumento <code>byrow</code> na função.</p>
<p></p>
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Para preencher a matriz, por linha, adicione</span></span>
<span><span class="co"># byrow = TRUE à função</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>, nrow <span class="op">=</span> <span class="fl">5</span>, ncol <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20</code></pre>
<p></p>
<p>Os vetores são estruturas unidimensionais, e com apenas um índice poderíamos acessar um valor contido nele. Porém, as matrizes possuem duas dimensões, logo, temos que fornecer dois índices à função <code>[</code> para acessarmos um único elemento dessa matriz. Basta você separar esses dois índices por uma vírgula, onde o primeiro valor corresponde a linha, e o segundo, a coluna desejada. No exemplo abaixo, estou extraindo o elemento que se encontra na terceira linha da quarta coluna.</p>
<p></p>
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">matriz</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>, nrow <span class="op">=</span> <span class="fl">5</span>, ncol <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="va">matriz</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">4</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 18</code></pre>
<p></p>
<p>Eu posso também extrair uma parte dessa matriz, ao fornecer mais valores dentro de um vetor, para cada um dos dois índices. No primeiro exemplo abaixo, eu extraio todos os valores da primeira a terceira linha da segunda coluna da matriz. Agora, caso eu queira extrair todos os valores de uma dimensão (todas as linhas, ou todas as colunas), basta que eu deixe em “branco” ao lado de cada índice. No segundo exemplo abaixo, estou extraindo todos os valores da segunda coluna.</p>
<p></p>
<div class="sourceCode" id="cb106"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">matriz</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span> <span class="co"># É o mesmo que: matriz[c(1,2,3), 2]</span></span></code></pre></div>
<pre><code>## [1] 6 7 8</code></pre>
<div class="sourceCode" id="cb108"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">matriz</span><span class="op">[</span> , <span class="fl">2</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1]  6  7  8  9 10</code></pre>
<p></p>
<p>Pelo fato de matrizes serem vetores com duas dimensões, elas herdam a propriedade do vetor, e, portanto: <strong>matrizes podem conter dados de apenas um único tipo</strong>. Por essa característica, você provavelmente utilizará essa estrutura poucas vezes. De qualquer forma é útil conhecê-la.</p>
</div>
<div id="sec:estrutura_listas" class="section level3" number="2.4.3">
<h3>
<span class="header-section-number">2.4.3</span> Listas<a class="anchor" aria-label="anchor" href="#sec:estrutura_listas"><i class="fas fa-link"></i></a>
</h3>
<p>A lista é uma estrutura especial e muito importante do R, pois ela é a exceção da propriedade dos vetores (que podem conter apenas um tipo de dado). <strong>Portanto, uma lista é um vetor, onde cada elemento deste vetor pode ser não apenas de um tipo de dado diferente, mas também de tamanho e estrutura diferentes.</strong> Dito de outra forma, você pode incluir o que você quiser em cada elemento de uma lista.</p>
<p>Uma lista é criada pela função <code><a href="https://rdrr.io/r/base/list.html">list()</a></code>, e para utilizá-la, basta fornecer os valores que deseja inserir em cada elemento desta lista, separados por vírgulas. No exemplo abaixo, estou inserindo no primeiro elemento desta lista a data que vimos anteriormente (“20/05/2020”), no segundo, estou incluindo uma matriz, no terceiro, um vetor com nomes, e no quarto, um <code>data.frame</code> (falaremos sobre eles após essa seção).</p>
<p></p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Lista nomeada</span></span>
<span><span class="co"># nome = valor</span></span>
<span><span class="va">lista</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>  data <span class="op">=</span> <span class="st">"20/05/2020"</span>,</span>
<span>  matriz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>, ncol <span class="op">=</span> <span class="fl">4</span>, nrow <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>,</span>
<span>  vetor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Belo Horizonte"</span>, <span class="st">"Londrina"</span>, <span class="st">"Macapá"</span><span class="op">)</span>,</span>
<span>  tabela <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">21</span><span class="op">:</span><span class="fl">30</span>, y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">lista</span></span></code></pre></div>
<pre><code>## $data
## [1] "20/05/2020"
## 
## $matriz
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
## 
## $vetor
## [1] "Belo Horizonte" "Londrina"       "Macapá"        
## 
## $tabela
##     x           y
## 1  21  2.30797840
## 2  22  0.10580237
## 3  23  0.45699881
## 4  24 -0.07715294
## 5  25 -0.33400084
## 6  26 -0.03472603
## 7  27  0.78763961
## 8  28  2.07524501
## 9  29  1.02739244
## 10 30  1.20790840</code></pre>
<p></p>
<p>Perceba que nós nomeamos cada elemento dessa lista. Isso abre novas possibilidades, pois agora podemos utilizar um sistema diferente da função <code>[</code> para acessarmos os valores específicos de uma lista, utilizando o operador <code>$</code>. Através deste operador, podemos acessar os elementos dessa lista, através do nome que demos para cada um deles. O problema deste sistema, é que ele lhe permite acessar todos os valores contidos em um elemento de sua lista, mas não lhe permite extrair valores específicos contidos em cada um destes elementos da lista.</p>
<p></p>
<div class="sourceCode" id="cb112"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span><span class="op">$</span><span class="va">matriz</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20</code></pre>
<div class="sourceCode" id="cb114"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span><span class="op">$</span><span class="va">vetor</span></span></code></pre></div>
<pre><code>## [1] "Belo Horizonte" "Londrina"       "Macapá"</code></pre>
<p></p>
<p>Você não precisa nomear cada um dos elementos dessa lista como fizemos acima. Eu nomeie apenas para dar um exemplo do operador <code>$</code>. Porém, neste caso em que você não atribui um nome a esses elementos, você não pode acessá-los mais pelo operador <code>$</code>, e terá que retornar à funçaõ <code>[</code> para tal serviço. Em outras palavras, se você deseja criar uma lista, mas não está muito preocupado em nomear cada um dos elementos que vão estar nessa lista, basta separar esses valores por vírgulas como no exemplo abaixo:</p>
<p></p>
<div class="sourceCode" id="cb116"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">6</span>, <span class="fl">7</span>, <span class="fl">8</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">T</span>, <span class="cn">F</span>, <span class="cn">T</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">lista</span></span></code></pre></div>
<pre><code>## [[1]]
## [1] 6 7 8
## 
## [[2]]
## [1] "a" "b" "c"
## 
## [[3]]
## [1]  TRUE FALSE  TRUE</code></pre>
<p></p>
<p>Antes de prosseguirmos, darei uma nova descrição (dessa vez, uma descrição visual) de uma lista, para que você fixe na sua cabeça o que ela é. Eu espero que eu tenha desejado bem o suficiente, para que você seja capaz de identificar um trem carregando quatro vagões na figura 2.6. Podemos pensar esse trem como uma lista, e os seus vagões como os elementos dessa lista. Tendo isso em mente, temos na figura 2.6 uma representação de uma lista com quatro elementos.</p>
<p>Como disse anteriormente, podemos incluir o que quisermos dentro de cada elemento dessa lista, ou dentro de cada vagão desse trem. Pois cada vagão é capaz de comportar elementos de qualquer dimensão e em qualquer estrutura, e como esses vagões estão separados uns dos outros, esses elementos não precisam compartilhar das mesmas características. Dito de outra forma, eu posso carregar 15 toneladas de ouro no primeiro vagão, 100 Kg de carvão no segundo vagão, e 1 Kg de ferro no terceiro vagão.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-72"></span>
<img src="Figuras/lista.png" alt="Representação de uma lista" width="70%"><p class="caption">
Figura 2.6: Representação de uma lista
</p>
</div>
<p></p>
<p>Portanto, a lista é uma estrutura que lhe permite transportar todos esses diferentes elementos, em um mesmo objeto no R (ou todos esses diferentes componentes em um mesmo trem). Quando chegarmos em interação, você verá que essa característica torna a lista, uma estrutura extremamente útil.</p>
<p>Agora como eu posso extrair valores dessa lista através da função <code>[</code> ? Bem, a lista é a exceção da propriedade dos vetores, mas ela continua sendo um vetor em sua essência, ou uma estrutura unidimensional. Por isso, você pode acessar um item de uma lista com apenas um índice dentro de <code>[</code>.</p>
<p>Porém, caso você usar apenas um colchete para selecionar o primeiro elemento de sua lista, você percebe que uma pequena descrição (<code>"[[1]]"</code>), ou o nome que você deu aquele elemento, aparece em cima dos valores contidos neste elemento da lista. Por isso, se você deseja extrair apenas os valores desse elemento, sem essa descrição, você deve utilizar o índice dentro de dois colchetes.</p>
<p></p>
<div class="sourceCode" id="cb118"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>  <span class="fl">1</span><span class="op">:</span><span class="fl">20</span>,</span>
<span>  <span class="st">"O ano tem 365 dias"</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>, ncol <span class="op">=</span> <span class="fl">4</span>, nrow <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">lista</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [[1]]
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</code></pre>
<div class="sourceCode" id="cb120"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</code></pre>
<div class="sourceCode" id="cb122"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] "O ano tem 365 dias"</code></pre>
<div class="sourceCode" id="cb124"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20</code></pre>
<p></p>
<p>Isso ocorre, porque quando você utiliza apenas um colchete para selecionar o primeiro elemento, o R acaba lhe retornando uma nova lista contendo um elemento, e não apenas o que está dentro deste elemento em si. Dizendo em termos da representação visual que utilizamos na figura 2.6, se eu possuo um trem com quatro vagões, e utilizo um colchete para selecionar o primeiro vagão, o R me retorna um novo trem que contém o primeiro vagão. Mas se eu utilizo dois colchetes, o R me retorna apenas o primeiro vagão, e nada mais.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-74"></span>
<img src="Figuras/colchetes.png" alt="Diferença entre um e dois colchetes em listas" width="70%"><p class="caption">
Figura 2.7: Diferença entre um e dois colchetes em listas
</p>
</div>
<p></p>
<p>Mas como eu faço para extrair um valor específico de um elemento de uma lista? Para isso você deve abrir um novo colchete após os colchetes duplos que você criou para selecionar o elemento da lista. A partir daí, basta replicar o que vimos anteriormente com os índices. No exemplo abaixo, estou primeiro selecionando o terceiro elemento da nossa lista (que é uma matriz), e selecionando o item da terceira linha da primeira coluna desta matriz.</p>
<p></p>
<div class="sourceCode" id="cb126"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p></p>
</div>
<div id="sec:estrutura_data_frames" class="section level3" number="2.4.4">
<h3>
<span class="header-section-number">2.4.4</span> Tabelas no R: <code>data.frame</code><a class="anchor" aria-label="anchor" href="#sec:estrutura_data_frames"><i class="fas fa-link"></i></a>
</h3>
<p>O <code>data.frame</code> é a principal estrutura utilizada para guardar tabelas e bases de dados no R. Na grande maioria das vezes que você importar os seus dados para o R, eles serão alocados dentro de um <code>data.frame</code>. Essa estrutura é no fundo, uma lista com algumas propriedades a mais. Por isso, o <code>data.frame</code> herda uma de suas principais propriedades: <strong>cada uma das colunas da tabela formada por um <code>data.frame</code>, pode conter um tipo de dado diferente das demais colunas deste <code>data.frame</code>.</strong></p>
<p>Esta é uma das principais características que tornam o <code>data.frame</code>, uma estrutura adequada para guardar a grande maioria das bases de dados. Pois é muito comum, que você possua em sua base, diversas colunas contendo dados de diferentes tipos. Por exemplo, você pode ter uma base que possui uma coluna contendo datas, outras duas contendo valores numéricos, e uma última coluna contendo textos, ou rótulos indicando a qual indicador ou grupo, os valores numéricos da linha se referem. E ao importar uma base como essa para o R, é de seu desejo que o R interprete essas colunas corretamente e mantenha os tipos desses dados intactos.</p>
<p>Os <code>data.frame</code>’s são criados pela função <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code>. Você deve preencher essa função com os valores que você deseja alocar em cada coluna separados por vírgulas. Você pode escolher não dar um nome a cada coluna, neste caso a função se ocupará de dar um nome genérico para elas. Caso opte por definir esses nomes, você deve fornecê-los antes dos valores da coluna, seguindo a seguinte estrutura:</p>
<p></p>
<div class="sourceCode" id="cb128"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Estrutura Básica:</span></span>
<span><span class="co"># data.frame(</span></span>
<span><span class="co">#   &lt;nome_coluna&gt; = &lt;valor_coluna&gt; </span></span>
<span><span class="co"># )</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  nomes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Eduardo"</span><span class="op">)</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>,</span>
<span>  numeros <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>  constante <span class="op">=</span> <span class="fl">25</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>##      nomes    numeros constante
## 1      Ana -1.2313234        25
## 2  Eduardo  0.9838956        25
## 3      Ana  0.2199248        25
## 4  Eduardo -1.4672500        25
## 5      Ana  0.5210227        25
## 6  Eduardo -0.1587546        25
## 7      Ana  1.4645873        25
## 8  Eduardo -0.7660820        25
## 9      Ana -0.4302118        25
## 10 Eduardo -0.9261095        25</code></pre>
<p></p>
<p>Caso você esteja em dúvida, tudo o que a função <code><a href="https://rdrr.io/r/stats/Normal.html">rnorm()</a></code> faz é gerar valores aleatórios seguindo uma distribuição normal. Vemos que no exemplo acima, geramos uma tabela com 3 colunas e 10 linhas, e aqui chego a segunda principal propriedade de um <code>data.frame</code>, que é: <strong>todas as colunas de um <code>data.frame</code> devem possuir o mesmo número de linhas</strong>. O motivo dessa propriedade é um pouco óbvio, pois se estamos tentando formar uma tabela de dados, é natural pensarmos que ela deve formar um retângulo uniforme.</p>
<p>Isso significa, que se eu pedisse para a função <code><a href="https://rdrr.io/r/base/rep.html">rep()</a></code> repetir os valores 6 vezes (ao invés de 5), gerando assim um vetor de 12 elementos (ou 12 linhas), a função <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code> me retornaria um erro, indicando que o número de linhas criadas pelos diferentes vetores não possuem o mesmo número de linhas.</p>
<p>Caso não tivéssemos essa propriedade, estaríamos permitindo que alguma dessas colunas deste <code>data.frame</code>, fosse mais longa do que as outras. Neste caso, como você lidaria com as observações “sobressalentes” da tabela ? Você possui um valor na coluna x que não possui um valor correspondente na coluna y, será que você considera o valor da coluna y como vazio ? Não disponível ? Não existente ? Enfim, uma confusão que é desnecessária.</p>
<p>Essa propriedade nos garante que para cada observação (ou linha) da nossa tabela, deve <strong>sempre</strong> existir um valor na coluna y correspondente ao valor da coluna x, mesmo que o valor da coluna y seja um valor <code>NA</code> (não disponível), ou algo indicando que não foi possível coletar esse valor no plano físico de nossa atividade.</p>
<p>Ao voltar para o exemplo acima, você pode perceber que na terceira coluna que definimos em <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code>, demos uma simples constante (25) à função. Como resultado, a função acaba preenchendo toda a coluna por essa constante. Isso ocorre sempre que você fornece um único valor a uma coluna de seu <code>data.frame</code>, seja este valor, uma data, um texto, um número ou qualquer outro tipo que imaginar.</p>
<p>A partir daqui, é interessante criarmos um modelo visual em nossa cabeça, sobre o que um <code>data.frame</code> representa. Como disse anteriormente, um <code>data.frame</code>, é basicamente uma lista, com algumas propriedades a mais, em especial a propriedade de que todos os seus elementos devem possuir o mesmo número de linhas. Portanto, se você quer imaginar um <code>data.frame</code> em sua mente, você pode imaginar uma lista, onde cada um de seus elementos, representa uma coluna desse <code>data.frame</code>. Em conjunto, essas colunas (ou os elementos dessa lista) formam uma tabela, sendo essa tabela, comumente referida como um <code>data.frame</code>.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-77"></span>
<img src="Figuras/data_frame_representacao.png" alt="Representação de um `data.frame` a partir de uma lista" width="80%"><p class="caption">
Figura 2.8: Representação de um <code>data.frame</code> a partir de uma lista
</p>
</div>
<p></p>
<p>Vale destacar um outro comportamento da função <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code>. Ela transforma por padrão, todos os textos em fatores (<em>factor</em>), ou em outras palavras, valores de uma variável categórica que possui um conjunto limitado de valores possíveis. Vamos aprender mais sobre este tipo de dados nas próximas seções. Inicialmente, isso não tem grandes implicações sobre os seus dados. Eles vão continuar sendo apresentados como textos, e a única grande mudança será sobre a forma como o R irá ordenar esses valores caso você peça isso a ele. Mas é importante saber deste detalhe, pois você vai querer suprimir esse comportamento na maioria das vezes. Para isso, basta adicionar o valor <code>FALSE</code> para o argumento <code>stringsAsFactors</code>.</p>
<p></p>
<div class="sourceCode" id="cb130"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tabela</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  cidade <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Belo Horizonte"</span>, <span class="st">"Londrina"</span>, <span class="st">"Macapá"</span><span class="op">)</span>, times <span class="op">=</span> <span class="fl">4</span><span class="op">)</span>,</span>
<span>  valor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">12</span><span class="op">)</span>,</span>
<span>  stringsAsFactors <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Estou utilizando a função is.character()</span></span>
<span><span class="co"># para confirmar que data.frame() manteve</span></span>
<span><span class="co"># a coluna de cidades como texto (characters)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/character.html">is.character</a></span><span class="op">(</span><span class="va">tabela</span><span class="op">$</span><span class="va">cidade</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p></p>
<p>No exemplo acima, você também percebe que eu utilizei dentro da função <code><a href="https://rdrr.io/r/base/character.html">is.character()</a></code>, o operador <code>$</code> para acessar os valores da coluna <code>cidade</code> da nossa tabela. Em <code>data.frame</code>’s você sempre pode utilizar este mecanismo para acessar os valores de uma das colunas de sua tabela, pois <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code> irá sempre se preocupar em nomear as colunas caso você não o faça. Portanto, mesmo que <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code> invente um nome completamente esquisito para as suas colunas, elas sempre terão um nome para o qual você pode se referir com <code>$</code>.</p>
<p>Isso não significa que você deixará de utilizar o sistema <code>[</code>, pois essa função é muito mais flexível do que você imagina. Uma de suas principais e mais poderosas ferramentas, é um sistema que é comumente chamado de <em>logical subsetting</em>. Com ele, podemos usar a função <code>[</code> para extrair valores de um objeto, de acordo com o resultado de testes lógicos. Em diversas funções de pacotes que você utilizar, se você visitar o código fonte dessas funções, você irá encontrar este sistema sendo utilizado em algum momento, sendo portanto, uma ferramenta extremamente útil dentro do R.</p>
<p>Em resumo, se você quer extrair todos os valores de uma coluna de seu <code>data.frame</code>, você pode utilizar o sistema <code>$</code>, ou o mesmo sistema que utilizamos em matrizes, ao deixar o índice das linhas em “branco” dentro de <code>[</code>. Se você quer extrair partes específicas de sua tabela, você terá que usar <code>[</code> da mesma forma que o utilizamos em matrizes. Como as colunas de um <code>data.frame</code> são nomeados, você pode também extrair uma coluna inteira, ao colocar o nome dessa coluna entre aspas dentro dos colchetes. Todos os sistemas utilizados abaixo, nos retorna todos os valores da coluna <code>cidade</code>.</p>
<p></p>
<div class="sourceCode" id="cb132"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tabela</span><span class="op">$</span><span class="va">cidade</span></span>
<span></span>
<span><span class="va">tabela</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span></span>
<span></span>
<span><span class="va">tabela</span><span class="op">[[</span><span class="st">"cidade"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<p></p>
<p>Você deve ter percebido acima que utilizei novamente os dois colchetes, ao me referir dentro deles pelo nome da coluna desejada. Este sistema funciona exatamente da mesma forma que ele funciona em listas. Se eu utilizar um colchete, o R me retorna um <code>data.frame</code> contendo uma única coluna (neste caso, a coluna <code>cidade</code>), se eu uso dois colchetes, o R me retorna um vetor contendo apenas os valores dessa coluna.</p>
<p>Agora, voltando um pouco em nossa descrição, quando eu disse que um <code>data.frame</code> são listas, pois herdava muitas de suas propriedades, eu acabei omitindo uma dessas propriedades para evitar confusões. Você deve ter percebido pelos exemplos anteriores, que cada elemento de um <code>data.frame</code> é uma coluna de sua tabela. Você talvez tenha percebido também que todos esses elementos nos exemplos anteriores, eram vetores. Isso é uma característica marcante de um <code>data.frame</code>, pois na maioria das vezes em que você ver um, ele estará servindo apenas como um laço, que amarra e mantém diferentes vetores unidos em uma mesma estrutura, vetores esses que juntos formam uma tabela.</p>
<p>Você deve estar pensando: “Mas é claro que cada coluna é um vetor! Não faria sentido se eu incluísse matrizes ou outras tabelas em uma coluna de uma tabela! Um vetor é a estrutura que faz mais sentido para essas colunas!”. Bom, eu creio que agora é uma boa hora para “explodir” a sua cabeça!…ou pelo menos metaforicamente falando. <strong>A outra propriedade que <code>data.frame</code>’s herdam de listas, é que cada um de seus elementos também não precisam ser da mesma estrutura. </strong></p>
<p>Essa propriedade significa que eu posso incluir sim, uma matriz, ou um outro <code>data.frame</code>, como uma nova coluna de um <code>data.frame</code> que está salvo em algum objeto. Lembre-se que a principal diferença entre um <code>data.frame</code> e uma lista, é que os elementos de um <code>data.frame</code> precisam obrigatoriamente ter o mesmo número de linhas. No exemplo abaixo, eu estou criando inicialmente um <code>data.frame</code> com 10 linhas e 2 colunas, logo, se eu quiser incluir uma nova tabela como uma nova coluna desse <code>data.frame</code>, essa nova tabela (ou novo <code>data.frame</code>) deve possuir 10 linhas (mas esse novo <code>data.frame</code> pode ter quantas colunas você desejar).</p>
<p>Você pode facilmente adicionar uma nova coluna a um <code>data.frame</code>, utilizando o operador <code>$</code>. Você escreve primeiro o nome do objeto onde o seu <code>data.frame</code> está contido, abre o cifrão (<code>$</code>), e em seguida, coloca um nome de uma coluna que não existe em seu <code>data.frame</code> até aquele momento. Se não há alguma coluna neste <code>data.frame</code> que possui este nome, o R irá adicionar esta coluna a ele, e para você preencher essa coluna com algum valor, basta utilizar o símbolo de <em>assignment</em> (<code>&lt;-</code>), como se você estivesse salvando algum valor em um novo objeto. Após criar essa nova coluna, eu chamo por ela, para que o R me mostre o que tem nessa coluna, e como esperávamos, ele me retorna o novo <code>data.frame</code> que criamos.</p>
<p></p>
<div class="sourceCode" id="cb133"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tabela</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  cidade <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Belo Horizonte"</span>, <span class="st">"Londrina"</span><span class="op">)</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>,</span>
<span>  valor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">tabela</span><span class="op">$</span><span class="va">novo_dataframe</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="st">"Ana"</span>, times <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>,</span>
<span>  y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="st">"Eduardo"</span>, times <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>,</span>
<span>  z <span class="op">=</span> <span class="fl">25</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">tabela</span><span class="op">$</span><span class="va">novo_dataframe</span></span></code></pre></div>
<pre><code>##      x       y  z
## 1  Ana Eduardo 25
## 2  Ana Eduardo 25
## 3  Ana Eduardo 25
## 4  Ana Eduardo 25
## 5  Ana Eduardo 25
## 6  Ana Eduardo 25
## 7  Ana Eduardo 25
## 8  Ana Eduardo 25
## 9  Ana Eduardo 25
## 10 Ana Eduardo 25</code></pre>
<p></p>
<p>Na figura 2.9, estou utilizando a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> sobre o objeto <code>tabela</code>. Essa função nos retorna no console, uma descrição da estrutura de um objeto. No retângulo vermelho, temos a estrutura geral do objeto, vemos que o objeto <code>tabela</code> é um <code>data.frame</code> com dez linhas e três colunas. Os nomes de suas três colunas estão especificadas no retângulo verde. A direita do nome da terceira coluna (chamada <code>novo_dataframe</code>), podemos ver uma descrição de sua estrutura marcada por um retângulo azul. Vemos neste retângulo azul, portanto, a estrutura desta terceira coluna, e podemos confirmar que se trata também de um <code>data.frame</code> com 10 linhas e 3 colunas, e no retângulo roxo, podemos ver o nome das três colunas (no caso abaixo, colunas x, y e z) contidas neste segundo <code>data.frame</code>. Os falantes de língua inglesa costumam se referir a esta situação onde inserimos uma nova estrutura dentro de uma mesma estrutura, como uma <em>nested structure</em>, ou uma estrutura “aninhada”. Logo, o exemplo que estou dando, se trata de um <em>nested</em> <code>data.frame</code>. Pois estamos inserindo um <code>data.frame</code>, dentro de um outro <code>data.frame</code>.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-81"></span>
<img src="Figuras/str_dataframe_mod.png" alt="Estrutura de um `data.frame` aninhado" width="80%"><p class="caption">
Figura 2.9: Estrutura de um <code>data.frame</code> aninhado
</p>
</div>
<p></p>
<p>Se você chamar pelo nome <code>tabela</code> no console, para ver o que tem dentro deste objeto, o console irá lhe mostrar um <code>data.frame</code> com 10 linhas e 5 colunas. Pois ele lhe apresenta tanto as 2 colunas definidas como vetores em <code>tabela</code>, quanto as 3 colunas definidas em <code>tabela$novo_dataframe</code>, tudo em uma mesma tabela. Entretanto, como vimos através da função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code>, o R está considerando este objeto como um <code>data.frame</code> com 10 linhas e 3 colunas, onde a terceira coluna contém um novo <code>data.frame</code> de 10 linhas e com outras 3 colunas, e não como um único <code>data.frame</code> com 10 linhas e 5 colunas.</p>
<p>Tendo essas considerações em mente, você pode sim incluir dados que estão em qualquer uma das estruturas anteriormente mencionadas, dentro de uma coluna (ou elemento) de um <code>data.frame</code>. Essa propriedade é mais citada nos manuais originais da linguagem <span class="citation">(<a href="refer%C3%AAncias.html#ref-Rlanguage" role="doc-biblioref">TEAM, 2020a</a>, <a href="refer%C3%AAncias.html#ref-Rintroduction" role="doc-biblioref">2020b</a>)</span>, enquanto é muito pouco mencionada, ou pouco explicada em detalhes em outros livros-texto sobre a linguagem. Pois é uma propriedade que faz pouco sentido, considerando-se as principais aplicações de um <code>data.frame</code>. Porém, com essa propriedade, você pode pensar facilmente em uma outra estrutura que é muito mais útil e muito mais poderosa, para ser incluída em uma nova coluna de seu <code>data.frame</code>. Essa estrutura, é uma lista!</p>
<p>Pense um pouco sobre isso. Uma lista é um vetor em sua essência, e por isso, pode facilmente formar uma nova coluna desse <code>data.frame</code>. A vantagem de se incluir uma lista, é que agora em cada célula (ou em cada linha) dessa nova coluna, eu posso guardar um dado de um tipo, tamanho e estrutura diferentes. Se fossemos utilizar a representação visual da seção anterior, é como se a coluna de seu <code>data.frame</code> tenha se transformado em um trem, e agora cada célula, ou cada linha dessa coluna, tenha se tornado um vagão deste trem. Com essa realidade, você pode por exemplo, facilmente aplicar um modelo de regressão sobre 1.000 bases de dados diferentes, e ainda guardar os resultados em cada linha de uma nova coluna, tudo isso com apenas um comando! Dessa forma, você terá em uma coluna de seu <code>data.frame</code> contendo uma lista, lista essa que está mantendo todos esses 1.000 <code>data.frame</code>’s diferentes juntos.</p>
<p>Se você consegue entender a língua inglesa, mesmo que sutilmente, eu altamente recomendo que assista a palestra de Hadley Wickham, entitulada <em>“Managing many models with R”</em>, que está disponível no YouTube<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=rz3_FDVt9eg" class="uri"&gt;https://www.youtube.com/watch?v=rz3_FDVt9eg&lt;/a&gt;&lt;/p&gt;'><sup>26</sup></a>. Nesta palestra, ele dá um exemplo prático de como você pode implementar essa ideia, ao aplicar um modelo de regressão sobre várias bases diferentes, utilizando essa propriedade em um <code>data.frame</code>.</p>
</div>
<div id="sec:fundamentos_tibble" class="section level3" number="2.4.5">
<h3>
<span class="header-section-number">2.4.5</span> <code>tibble</code>’s como uma alternativa moderna aos <code>data.frame</code>’s<a class="anchor" aria-label="anchor" href="#sec:fundamentos_tibble"><i class="fas fa-link"></i></a>
</h3>
<p>Um <code>tibble</code> nada mais é do que uma “versão moderna” de um <code>data.frame</code>. Essa estrutura de dado é originária do pacote <code>tibble</code>, logo, se você deseja utilizá-la em algum de seus dados, você terá que chamar obrigatoriamente por esse pacote com o comando <code><a href="https://rdrr.io/r/base/library.html">library()</a></code><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Caso tenha alguma dificuldade em chamar pelo pacote, volte a seção &lt;a href="no%C3%A7%C3%B5es-b%C3%A1sicas-do-r.html#sec:pacotes"&gt;Pacotes&lt;/a&gt; para descobrir o passo que você se esqueceu de cumprir.&lt;/p&gt;'><sup>27</sup></a>. Lembre-se que o pacote deve estar instalado em sua máquina, para que você seja capaz de chamar por ele com o comando <code><a href="https://rdrr.io/r/base/library.html">library()</a></code>.</p>
<p>Portanto, essa estrutura foi criada com o intuito de melhorar alguns comportamentos do <code>data.frame</code>, que eram adequados para a sua época, mas que hoje, são desnecessários e que podem gerar um pouco de dor de cabeça. Tais estruturas podem ser criadas do zero, através da função <code><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble()</a></code>, que funciona da mesma maneira que <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code>. Você dá o nome para cada coluna, e após um igual (<code>=</code>) você define o que irá preencher cada uma dessas colunas.</p>
<p></p>
<div class="sourceCode" id="cb135"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tibble.tidyverse.org/">tibble</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">tab_tibble</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span></span>
<span>  Datas <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.Date.html">seq.Date</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/as.Date.html">as.Date</a></span><span class="op">(</span><span class="st">"2020-12-01"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html">as.Date</a></span><span class="op">(</span><span class="st">"2020-12-10"</span><span class="op">)</span>, by <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>  Usuario <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Eduardo"</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">10</span>, replace <span class="op">=</span> <span class="cn">T</span><span class="op">)</span>,</span>
<span>  Valor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2000</span>, <span class="fl">3000</span>, <span class="fl">4000</span>, <span class="fl">5000</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">10</span>, replace <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">tab_tibble</span></span></code></pre></div>
<pre><code>## # A tibble: 10 × 3
##    Datas      Usuario Valor
##    &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;
##  1 2020-12-01 Ana      2000
##  2 2020-12-02 Ana      5000
##  3 2020-12-03 Ana      3000
##  4 2020-12-04 Eduardo  3000
##  5 2020-12-05 Ana      5000
##  6 2020-12-06 Ana      5000
##  7 2020-12-07 Ana      3000
##  8 2020-12-08 Ana      5000
##  9 2020-12-09 Ana      5000
## 10 2020-12-10 Eduardo  2000</code></pre>
<p></p>
<p>Por outro lado, se você já possui um <code>data.frame</code> e deseja convertê-lo para um <code>tibble</code>, você precisa apenas aplicar a função <code><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble()</a></code> sobre ele.</p>
<p></p>
<div class="sourceCode" id="cb137"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tabela</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="va">tabela</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>A primeira melhoria dessas estruturas, se encontra no método de <code><a href="https://rdrr.io/r/base/print.html">print()</a></code>, ou em outras palavras, na forma como o R lhe mostra a sua tabela no console. Quando chamamos por um objeto que é um <code>data.frame</code>, o console acaba lhe retornando muito mais linhas do que o necessário (ele pode retornar até 1000 linhas), além de todas as colunas da tabela. Se o seu <code>data.frame</code> possui várias colunas, você pode se sentir frustrado com esse comportamento, pois se alguma coluna de sua tabela não couber ao lado das colunas anteriores, o console acaba quebrando o resultado em várias “linhas”, algo que pode tornar a leitura confusa com certa facilidade.</p>
<p>As origens do R são antigas (&gt; 50 anos), e aparentemente esse não era um comportamento muito ruim na época, talvez porque as dimensões das tabelas dessa época eram muito limitadas. Porém, com as capacidades de processamento atuais, essa atitude é desnecessária ou indesejada em quase todas as situações. Veja no exemplo abaixo, onde eu pego a base <code>flights</code> (que possui 19 variáveis diferentes), e transformo-a em um <code>data.frame</code> com a função <code><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame()</a></code>. Para que o resultado não consuma muito espaço deste material, eu ainda limito o resultado às 5 primeiras linhas da tabela com <code><a href="https://rdrr.io/r/utils/head.html">head()</a></code>. Perceba que a tabela foi dividida em 3 linhas diferentes de <em>output</em>.</p>
<p></p>
<div class="sourceCode" id="cb138"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/hadley/nycflights13">nycflights13</a></span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="va">flights</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<pre><code>##   year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time
## 1 2013     1   1      517            515         2      830            819
## 2 2013     1   1      533            529         4      850            830
## 3 2013     1   1      542            540         2      923            850
## 4 2013     1   1      544            545        -1     1004           1022
## 5 2013     1   1      554            600        -6      812            837
##   arr_delay carrier flight tailnum origin dest air_time distance hour
## 1        11      UA   1545  N14228    EWR  IAH      227     1400    5
## 2        20      UA   1714  N24211    LGA  IAH      227     1416    5
## 3        33      AA   1141  N619AA    JFK  MIA      160     1089    5
## 4       -18      B6    725  N804JB    JFK  BQN      183     1576    5
## 5       -25      DL    461  N668DN    LGA  ATL      116      762    6
##   minute           time_hour
## 1     15 2013-01-01 10:00:00
## 2     29 2013-01-01 10:00:00
## 3     40 2013-01-01 10:00:00
## 4     45 2013-01-01 10:00:00
## 5      0 2013-01-01 11:00:00</code></pre>
<p></p>
<p>Quando as suas tabelas são <code>tibble</code>’s, o console lhe retorna por padrão, apenas as 10 primeiras linhas da tabela (caso a tabela seja muito pequena, ele pode lhe retornar todas as linhas), o que já é o suficiente para vermos a sua estrutura. Além disso, caso as próximas colunas não caibam em uma mesma “linha”, ou ao lado das colunas anteriores, o <code>tibble</code> acaba omitindo essas colunas para não sobrecarregar o seu console de resultados. Lembre-se que você sempre pode ver toda a tabela, em uma janela separada através da função <code><a href="https://rdrr.io/r/utils/View.html">View()</a></code>.</p>
<p></p>
<div class="sourceCode" id="cb140"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/View.html">View</a></span><span class="op">(</span><span class="va">flights</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>Veja o exemplo abaixo, onde eu chamo novamente pela base <code>flights</code>. O primeiro detalhe que você percebe, é a dimensão da tabela (algo que não é informado, quando chamamos por um <code>data.frame</code>) no canto superior esquerdo da tabela (336.776 linhas e 19 colunas). O segundo detalhe, é que o tipo de dado contido em cada coluna, está descrito logo abaixo do nome da coluna, de acordo com a abreviação deste tipo. Por exemplo, nas três primeiras colunas estão contidos números inteiros (<em>integer</em>’s - <code>int</code>), enquanto na sexta coluna (<code>dep_delay</code>) temos números decimais (<em>double</em>’s - <code>dbl</code>).</p>
<p>Mesmo que em um <code>tibble</code>, você fique sem a possibilidade de visualizar todas as outras colunas da tabela, que não cabem na mesma linha junto com as colunas anteriores, um <code>tibble</code> sempre lhe retorna logo abaixo da tabela, uma lista contendo o nome de todas as colunas restantes, além do tipo de dado contido em cada coluna, através das mesmas abreviações que vimos nas colunas anteriores.</p>
<p></p>
<div class="sourceCode" id="cb141"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">flights</span></span></code></pre></div>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ℹ 336,766 more rows
## # ℹ 12 more variables: sched_arr_time &lt;dbl&gt;, arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;dbl&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;</code></pre>
<p></p>
<p>Além desses pontos, <code>tibble</code>’s vão sempre criar destaques, ou ênfases em certos dados no console, algo que os <code>data.frame</code>’s não fazem em nenhum momento. Por exemplo, <code>tibble</code>’s vão sempre marcar de vermelho, qualquer número que seja negativo, uma funcionalidade que é bem familiar aos usuários de Excel que utilizam formatação condicional. Um outro detalhe, é que essa estrutura também marca as casas dos milhares com um pequeno sublinhado, o que facilita muito a leitura de números muito grandes.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-87"></span>
<img src="Figuras/marcacoes.png" alt="Ênfase em valores numéricos presentes em um `tibble`" width="25%"><p class="caption">
Figura 2.10: Ênfase em valores numéricos presentes em um <code>tibble</code>
</p>
</div>
<p></p>
<p>Para mais, um comportamento muito comum de um <code>data.frame</code>, é converter os seus dados em textos, para fatores (<code>factor</code>). Este não é um comportamento de todo ruim, e nem sempre ele ocorre. Porém o principal valor dos fatores no R, está no uso de <em>dummies</em> em regressões e análises estatísticas, além da maneira como a ordenação de seus valores é executada. Estas características são importantes, mas também são irrelevantes para uma gama muito grande de situações. Em outras palavras, este é um comportamento desnecessário na maioria de nossas análises.</p>
<p>Por isso, uma outra característica que os <code>tibble</code>’s carregam, é que eles nunca transformam os seus dados para um outro tipo. Isso é um ponto muito importante! As funções com as quais nós trabalhamos no R, geralmente funcionam melhor com (ou são especializadas em) uma estrutura ou tipo de dado específico, e quando nós estruturamos as nossas análises sobre essas funções, nós desejamos evitar mudanças não autorizadas sobre os tipos e estruturas utilizados.</p>
<p>Ou seja, é sempre melhor evitar transformações implícitas de seus dados. Pois essas operações podem muito bem, levantar erros dos quais você não compreende, até que você (depois de muito tempo analisando os resultados) perceba que os seus dados foram convertidos para algo incompatível com o que você deseja realizar.</p>
<p>Dessa forma, em um <code>tibble</code> os seus dados em texto são interpretados como textos (<code>character</code>), a menos que você peça explicitamente ao R que interprete esses dados de uma outra forma. Veja o exemplo abaixo, onde utilizo a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> para ver um resumo da estrutura de cada tabela. Podemos ver abaixo, que a coluna <code>text</code> na tabela <code>tib</code> contém dados do tipo <code>character</code> (<code>chr</code>), enquanto essa mesma coluna na tabela <code>df</code>, possui dados do tipo <code>factor</code>.</p>
<p></p>
<div class="sourceCode" id="cb143"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tib</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>  text <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Eduardo"</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">10</span>, replace <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>  text <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Eduardo"</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">10</span>, replace <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">tib</span><span class="op">)</span></span></code></pre></div>
<p></p>
<pre><code>tibble [10 x 2] (S3: tbl_df/tbl/data.frame)
 $ x   : num [1:10] 0.172 0.315 0.119 -0.155 -0.165 ...
 $ text: chr [1:10] "Eduardo" "Ana" "Eduardo" "Eduardo" ...</code></pre>
<p></p>
<div class="sourceCode" id="cb145"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">df</span><span class="op">)</span></span></code></pre></div>
<p></p>
<pre><code>'data.frame':   10 obs. of  2 variables:
 $ x   : num  0.0639 -0.4522 0.7528 -1.3353 1.454 ...
 $ text: Factor w/ 2 levels "Ana","Eduardo": 2 2 2 1 2 2 1 1 2 1</code></pre>
<p>Uma última característica de um <code>tibble</code>, é que ele lhe permite criar colunas com nomes que não respeitam as regras usuais do R. Por exemplo, não é permitido criar variáveis que possuam um nome que se inicia por um número, ou então, que possuam algum tipo de espaço ao longo dele. Mas dentro de um <code>tibble</code>, você não possui tais restrições. No exemplo abaixo, eu tento ultrapassar essa regra na função <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code>, e ela acaba preenchendo o espaço no nome, com um ponto (.), e também coloca uma letra qualquer antes do número da coluna “10_janeiro”, enquanto em um <code>tibble</code>, isso não ocorre. Entretanto, mesmo que você possua essa liberdade em um <code>tibble</code>, ao se referir a essas colunas que não se encaixam nas regras do R, você terá de contornar o nome dessas colunas, com acentos graves ().</p>
<p></p>
<div class="sourceCode" id="cb147"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_frame</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>    <span class="st">"Nome coluna"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>    <span class="st">"10_janeiro"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="va">tibble</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span></span>
<span>    <span class="st">"Nome coluna"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>    <span class="st">"10_janeiro"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">data_frame</span>, <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<pre><code>##    Nome.coluna  X10_janeiro
## 1   -0.6303003 -0.640481703
## 2   -0.3409686  0.570507636
## 3   -1.1565724 -0.059723276
## 4    1.8031419 -0.098178744
## 5   -0.3311320  0.560820729
## 6   -1.6055134 -1.186458639
## 7    0.1971934  1.096777044
## 8    0.2631756 -0.005344028
## 9   -0.9858267  0.707310667
## 10  -2.8889207  1.034107735</code></pre>
<div class="sourceCode" id="cb149"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tibble</span></span></code></pre></div>
<pre><code>## # A tibble: 10 × 2
##    `Nome coluna` `10_janeiro`
##            &lt;dbl&gt;        &lt;dbl&gt;
##  1         0.223      -0.0697
##  2        -0.879      -0.248 
##  3         1.16        0.696 
##  4        -2.00        1.15  
##  5        -0.545      -2.40  
##  6        -0.256       0.573 
##  7        -0.166       0.375 
##  8         1.02       -0.425 
##  9         0.136       0.951 
## 10         0.407      -0.389</code></pre>
<div class="sourceCode" id="cb151"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tibble</span><span class="op">$</span><span class="va">`10_janeiro`</span></span></code></pre></div>
<pre><code>##  [1] -0.06965481 -0.24766434  0.69555081  1.14622836 -2.40309621
##  [6]  0.57273956  0.37472441 -0.42526772  0.95101281 -0.38923718</code></pre>
<p></p>
<p>Portanto, os <code>tibble</code>’s foram criados com o intuito de manter as funcionalidades importantes de um <code>data.frame</code>, e ao mesmo tempo, eliminar comportamentos que hoje são desnecessários ou ineficientes. Em resumo, um <code>tibble</code> é uma estrutura preguiçosa. Pois ele nunca converte implicitamente os seus dados para algum outro tipo, ele não altera o nome de suas colunas, e ele também não sobrecarrega o seu console com linhas e linhas de resultados, lhe mostrando apenas o necessário.</p>
</div>
</div>
<div id="sec:fundamentos_tipos_dados" class="section level2" number="2.5">
<h2>
<span class="header-section-number">2.5</span> Tipos de dados<a class="anchor" aria-label="anchor" href="#sec:fundamentos_tipos_dados"><i class="fas fa-link"></i></a>
</h2>
<p>Como foi destacado anteriormente, além das estruturas de dados, o R possui os tipos de dados. Tipos esses que dizem respeito a forma como o R está interpretando os seus dados, em um dado momento. Os cinco tipos de dados básicos da linguagem são:</p>
<ol style="list-style-type: decimal">
<li><p><code>character</code>: valores de texto ou caracteres.</p></li>
<li><p><code>double</code>: valores númericos inclusos no conjunto dos números reais.</p></li>
<li><p><code>integer</code>: valores númericos inclusos no conjunto de números inteiros, ou basicamente, números sem casas decimais.</p></li>
<li><p><code>logical</code>: valores <code>TRUE</code> (verdadeiro) e <code>FALSE</code> (falso), resultantes de testes lógicos.</p></li>
<li><p><code>complex</code>: valores em números complexos.</p></li>
</ol>
<p>Vários outros tipos de dados mais complexos, como datas (<code>Date</code>) e fatores (<code>factor</code>), são construídos a partir desses 5 tipos básicos da linguagem. Tendo isso em mente, o único tipo básico que não irei abordar nas próximas seções, será o tipo <code>complex</code>, pois é um tipo muito específico e extremamente raro na linguagem.</p>
<p>Vale destacar que, diferentes autores denominam essa propriedade de formas diferentes, ou, tendem a misturá-la em outros conceitos. Como exemplo, <span class="citation">PENG (<a href="refer%C3%AAncias.html#ref-peng2015" role="doc-biblioref">2015</a>)</span> denomina os “tipos de dados” como “classes atômicas de objetos” (ou, <em>“atomic classes of objects”</em>), enquanto <span class="citation">WICKHAM; GROLEMUND (<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">2017</a>)</span>, costuma se referir a essa propriedade como “tipos de vetores” (ou, <em>“vector types”</em>). Todavia, independente da forma como os autores denominam essa propriedade, a lógica permanece a mesma.</p>
<p>O termo utilizado por <span class="citation">WICKHAM; GROLEMUND (<a href="refer%C3%AAncias.html#ref-wickham2017" role="doc-biblioref">2017</a>)</span> é mais apropriado para essa situação. Não apenas porque ele representa melhor a forma como esses conceitos são apresentados nos manuais internos da linguagem <span class="citation">(<a href="refer%C3%AAncias.html#ref-Rlanguage" role="doc-biblioref">TEAM, 2020a</a>, <a href="refer%C3%AAncias.html#ref-Rintroduction" role="doc-biblioref">2020b</a>)</span>, mas também, porque o termo utilizado por <span class="citation">PENG (<a href="refer%C3%AAncias.html#ref-peng2015" role="doc-biblioref">2015</a>)</span> mistura dois conceitos importantes que são diferentes entre si: a classe e o tipo de um objeto.</p>
<p>O tipo do objeto, (isto é, o que estou chamando aqui de tipo de dado - <code>character</code>, <code>double</code>, etc.), determina a representação interna do objeto. Ou seja, como esse objeto é armazenado internamente em C <code>structs</code> e na memória RAM de seu computador. Já a classe é um atributo do objeto, que determina quais são os métodos de funções a serem aplicados sobre este objeto <span class="citation">(<a href="refer%C3%AAncias.html#ref-chambers2016" role="doc-biblioref">CHAMBERS, 2016</a>, p 45)</span>.</p>
<div id="textos-e-caracteres-character" class="section level3" number="2.5.1">
<h3>
<span class="header-section-number">2.5.1</span> Textos e caracteres (<code>character</code>)<a class="anchor" aria-label="anchor" href="#textos-e-caracteres-character"><i class="fas fa-link"></i></a>
</h3>
<p>Variáveis textuais são extremamente comuns nas mais diversas análises. Tais variáveis são geralmente denominadas de variáveis categóricas, pois em geral, elas buscam classificar os seus dados em certas categorias e grupos. Para além dessas variáveis, também é comum utilizarmos textos para definir rótulos e títulos de gráficos, ou ainda, para definir certos argumentos de funções. Para armazenar, interpretar e transformar esse tipo de dado, o R nos oferece o tipo <code>character</code>. Valores do tipo <code>character</code> também são conhecidos pelo termo <em>string</em> (ou <em>string of characters</em>).</p>
<p>Todo valor em texto no R (isto é, todo dado do tipo <code>character</code>), deve ser fornecido entre aspas (simples - <code>'</code>, ou duplas - <code>"</code>), sendo essa uma convenção utilizada em quase todas as linguagens de programação, e no R não é diferente. Esta convenção se torna ainda mais importante no R, pois ela também serve para diferenciar valores em texto de nomes de objetos.</p>
<p>Em outras palavras, quando queremos acessar os valores que estão dentro de um objeto, nós simplesmente escrevemos o nome deste objeto. Entretanto, quando estamos fornecendo um simples texto ao R, é muito comum que nos esqueçamos de contornar esse texto com aspas. Como resultado, o R acaba interpretando esse valor como o nome de um objeto e, por isso, começa a procurar por um objeto que possua um nome igual a este texto que você digitou. Caso o R não encontre um objeto com um nome equivalente a esse texto, ele vai lhe retornar um erro indicando que ele não foi capaz de encontrar um objeto com este nome em sua sessão.</p>
<p>Para mais, caso este texto que você digitou, possua algum espaço, o R vai lhe retornar um erro um pouco diferente, dizendo que o símbolo que você inseriu no console, é inesperado ou inválido. De qualquer forma, o problema desse erro é o mesmo, você provavelmente se esqueceu de contornar o texto por aspas.</p>
<p></p>
<div class="sourceCode" id="cb153"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb153-1"><a href="fundamentos-da-linguagem-r.html#cb153-1" aria-hidden="true" tabindex="-1"></a>O_ano_tem_365_dias</span>
<span id="cb153-2"><a href="fundamentos-da-linguagem-r.html#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Erro: objeto 'O_ano_tem_365_dias' não encontrado</span></span>
<span id="cb153-3"><a href="fundamentos-da-linguagem-r.html#cb153-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-4"><a href="fundamentos-da-linguagem-r.html#cb153-4" aria-hidden="true" tabindex="-1"></a>O ano tem <span class="dv">365</span> dias</span>
<span id="cb153-5"><a href="fundamentos-da-linguagem-r.html#cb153-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Erro: unexpected symbol in "O ano"</span></span>
<span id="cb153-6"><a href="fundamentos-da-linguagem-r.html#cb153-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-7"><a href="fundamentos-da-linguagem-r.html#cb153-7" aria-hidden="true" tabindex="-1"></a><span class="st">"O ano tem 365 dias"</span></span>
<span id="cb153-8"><a href="fundamentos-da-linguagem-r.html#cb153-8" aria-hidden="true" tabindex="-1"></a><span class="do">## [1] "O ano tem 365 dias"</span></span></code></pre></div>
<p></p>
<p>Vale destacar que, um par de aspas, delimita um único valor do tipo <code>character</code>. Portanto, para criar um vetor contendo vários valores do tipo <code>character</code>, você tem que contornar cada um desses valores por aspas. Caso você contorne todos os diferentes valores por um único par de aspas, você vai criar um vetor do tipo <code>character</code> que contém 1 único elemento. Tal problemática está demonstrada abaixo.</p>
<p></p>
<div class="sourceCode" id="cb154"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a, b, c, d"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb156"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">vec2</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<p></p>
</div>
<div id="números-reais-double" class="section level3" number="2.5.2">
<h3>
<span class="header-section-number">2.5.2</span> Números reais (<code>double</code>)<a class="anchor" aria-label="anchor" href="#n%C3%BAmeros-reais-double"><i class="fas fa-link"></i></a>
</h3>
<p>Em quase todos os momentos que você estiver trabalhando com dados numéricos, esses dados vão estar sendo interpretados pelo tipo <code>double</code>. Pois este tipo básico abarca todo o conjunto dos números reais. E como o conjunto de números inteiros (<code>integer</code>) está incluso no conjunto dos números reais, quando você insere um número inteiro, ou um número sem casas decimais no console, ele será interpretado inicialmente pelo R como um número real (<code>double</code>).</p>
<p>Dito de outra forma, ao inserirmos apenas o número 10 no console, o R vai interpretar este 10 como um <code>double</code>, e não como <code>integer</code>, independente do fato desse número aparecer no console sem casas decimais. Pense como se este 10, fosse na verdade para o R algo como 10,00000000000… No exemplo abaixo, eu utilizo a função <code><a href="https://rdrr.io/r/base/integer.html">is.integer()</a></code> para perguntar ao R, se ele está interpretando este valor como um <code>integer</code>, e como esperávamos a função nos retorna um <code>FALSE</code>, indicando que não se trata de um número inteiro.</p>
<p></p>
<div class="sourceCode" id="cb158"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># O R está basicamente interpretando</span></span>
<span><span class="co"># este 10 como 10.00000000, mesmo</span></span>
<span><span class="co"># que ele te mostre</span></span>
<span><span class="fl">10</span></span></code></pre></div>
<pre><code>## [1] 10</code></pre>
<div class="sourceCode" id="cb160"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/double.html">is.double</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb162"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/integer.html">is.integer</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p></p>
<p>Vale destacar, que o R é uma linguagem centralizada nos padrões americanos, e que, portanto, utiliza o ponto para definir casas decimais, ao invés da vírgula que nós brasileiros utilizamos. Por esse motivo, para criar um vetor de números decimais, você deve utilizar um ponto para delimitar as casas decimais de seus valores. As vírgulas servem apenas para separar os diferentes valores deste vetor.</p>
<p></p>
<div class="sourceCode" id="cb164"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.24</span>, <span class="fl">2.25</span>, <span class="fl">3.62381</span>, <span class="fl">7.05</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 1.24000 2.25000 3.62381 7.05000</code></pre>
<p></p>
</div>
<div id="números-inteiros-integer" class="section level3" number="2.5.3">
<h3>
<span class="header-section-number">2.5.3</span> Números inteiros (<code>integer</code>)<a class="anchor" aria-label="anchor" href="#n%C3%BAmeros-inteiros-integer"><i class="fas fa-link"></i></a>
</h3>
<p>O tipo <code>integer</code> abarca o conjunto dos números inteiros, ou basicamente todos os números sem casas decimais. Você utilizará muito este tipo, quando estiver utilizando sequências numéricas, seja para extrair partes de um objeto com a função <code>[</code>, ou gerando um índice para as linhas de sua tabela. Como vimos na seção anterior, caso você insira um número sem casas decimais no console, o R vai interpretar inicialmente este número como um <code>double</code>.</p>
<p>Assim sendo, você tem três formas de se criar um <code>integer</code> no R. A primeira é inserindo um L maiúsculo após o número que você está criando. A segunda, é transformando o seu vetor do tipo <code>double</code> para o tipo <code>integer</code>, através da função <code><a href="https://rdrr.io/r/base/integer.html">as.integer()</a></code>. A terceira, seria através de funções que lhe retornam por padrão este tipo de dado, sendo o principal exemplo, a função <code>:</code> que lhe retorna, por padrão, uma sequência de <code>integer</code>’s. Podemos confirmar se os números criados são de fato <code>integer</code>’s, usando a função <code><a href="https://rdrr.io/r/base/integer.html">is.integer()</a></code>.</p>
<p></p>
<div class="sourceCode" id="cb166"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1L</span>, <span class="fl">2L</span>, <span class="fl">3L</span>, <span class="fl">10L</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1]  1  2  3 10</code></pre>
<div class="sourceCode" id="cb168"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/integer.html">as.integer</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">10.2561</span>, <span class="fl">1.55</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1]  1  2 10  1</code></pre>
<div class="sourceCode" id="cb170"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/integer.html">is.integer</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p></p>
</div>
<div id="o-tipo-numérico-numeric" class="section level3" number="2.5.4">
<h3>
<span class="header-section-number">2.5.4</span> O tipo numérico (<code>numeric</code>)<a class="anchor" aria-label="anchor" href="#o-tipo-num%C3%A9rico-numeric"><i class="fas fa-link"></i></a>
</h3>
<p>Em alguns momentos você pode se deparar com o tipo <code>numeric</code>. Ele nada mais é do que um “apelido” para os tipos <code>integer</code> e <code>double</code>. Dito de outra forma, os tipos <code>integer</code> e <code>double</code> são conjuntamente conhecidos como o tipo <code>numeric</code> <span class="citation">(<a href="refer%C3%AAncias.html#ref-wickham2015_advanced" role="doc-biblioref">WICKHAM, 2015a</a>)</span>.</p>
<p>Entretanto, mesmo que <code>numeric</code> seja um sinônimo para os tipos <code>integer</code> e <code>double</code>, o R não costuma empregar esse nome <code>numeric</code> de forma uniforme. Na maioria das ocasiões em que o tipo <code>numeric</code> aparece, o R está na verdade, se referindo especificamente ao tipo <code>double</code>. De qualquer forma, apenas entenda que se um conjunto de dados está associado ao tipo <code>double</code> ou ao tipo <code>integer</code>, ele também está diretamente associado ao tipo <code>numeric</code>.</p>
<p></p>
<div class="sourceCode" id="cb172"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html">is.numeric</a></span><span class="op">(</span><span class="fl">1L</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb174"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html">is.numeric</a></span><span class="op">(</span><span class="fl">1.25</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p></p>
</div>
<div id="valores-lógicos-logical" class="section level3" number="2.5.5">
<h3>
<span class="header-section-number">2.5.5</span> Valores lógicos (<code>logical</code>)<a class="anchor" aria-label="anchor" href="#valores-l%C3%B3gicos-logical"><i class="fas fa-link"></i></a>
</h3>
<p>No R, valores lógicos são interpretados pelo tipo de dado <code>logical</code> e, como você já deve ter percebido, este tipo abrange apenas dois valores possíveis, que são verdadeiro - <code>TRUE</code>, e falso - <code>FALSE</code>. Valores lógicos também são muito conhecidos em diversas linguagens de programação pelo termo <code>boolean</code>. Você irá utilizar muito este tipo de dado para filtrar linhas de seu <code>data.frame</code>, para preencher uma coluna de rótulos, ou para identificar valores “não disponíveis” e <em>outliers</em> em sua base de dados.</p>
<p>Temos dois métodos de se obter esse tipo de valor no R. A primeira, é escrevê-los na mão, podendo também se referir apenas a primeira letra maiúscula de cada um, ao invés de escrever toda a palavra.</p>
<p></p>
<div class="sourceCode" id="cb176"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor_logico</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">T</span>, <span class="cn">F</span>, <span class="cn">T</span>, <span class="cn">TRUE</span>, <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">vetor_logico</span></span></code></pre></div>
<pre><code>## [1]  TRUE FALSE  TRUE  TRUE FALSE</code></pre>
<p></p>
<p>A segunda e principal forma, é através de testes lógicos. No exemplo abaixo, eu estou criando um vetor com 5 elementos, e em seguida, peço ao R que me diga se cada elemento deste vetor é maior do que 5. Vemos que apenas o terceiro e o quarto elemento deste vetor, são maiores do que 5.</p>
<p></p>
<div class="sourceCode" id="cb178"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">2.45</span>, <span class="fl">5.6</span>, <span class="fl">7.2</span>, <span class="fl">1.3</span><span class="op">)</span></span>
<span><span class="va">vetor</span> <span class="op">&gt;</span> <span class="fl">5</span></span></code></pre></div>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE FALSE</code></pre>
<p></p>
<p>O que acabamos de fazer acima, se trata de um teste lógico, pois estamos testando uma hipótese (maior do que 5) sobre cada um dos elementos deste vetor. Como resultado, o R lhe retorna um vetor com o mesmo comprimento do primeiro, porém agora, este vetor está preenchido com <code>TRUE</code>’s e <code>FALSE</code>’s, lhe indicando quais dos elementos do primeiro vetor se encaixam na hipótese que você definiu.</p>
<p>Este vetor contendo apenas valores lógicos, não é tão útil em sua singularidade. Porém, ao utilizarmos ele sobre à função <code>[</code>, podemos utilizar o sistema que mencionei anteriormente, chamado de <em>logical subsetting</em>, que é uma forma extremamente útil de extrairmos partes de um objeto. A ideia, é extrairmos qualquer elemento deste objeto que possua um valor <code>TRUE</code> correspondente em um teste lógico específico que podemos definir. Consequentemente, poderíamos utilizar o teste anterior que criamos, para extrair todos os elementos do vetor, que são maiores do que 5, desta forma:</p>
<p></p>
<div class="sourceCode" id="cb180"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span><span class="op">[</span><span class="va">vetor</span> <span class="op">&gt;</span> <span class="fl">5</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 5.6 7.2</code></pre>
<p></p>
<p>Para criar um teste lógico, você precisa utilizar algum operador lógico (como os operadores <code>&gt;</code> e <code>==</code>), ou então, alguma função que aplique este tipo de teste e lhe retorne um valor lógico como resultado (por exemplo, a função <code><a href="https://rdrr.io/r/base/integer.html">is.integer()</a></code>).</p>
</div>
</div>
<div id="sec:funcoes_str_is" class="section level2" number="2.6">
<h2>
<span class="header-section-number">2.6</span> Identificando tipos e estruturas com a função <code>str()</code> e as funções <code>is.*()</code><a class="anchor" aria-label="anchor" href="#sec:funcoes_str_is"><i class="fas fa-link"></i></a>
</h2>
<p>Na linguagem Python, a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> serve para convertermos um objeto para o tipo <em>string</em>. Porém, na linguagem R, essa mesma função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> exerce um papel completamente diferente. No R, o nome <code>str</code> representa na realidade uma abreviação para <em>structure</em> (ou “estrutura”). Por isso, a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> nos fornece uma pequena descrição da estrutura de um objeto específico.</p>
<p>Como um primeiro exemplo, quando aplicamos a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> sobre a tabela <code>diamonds</code> do pacote <code>ggplot2</code>, o R nos retorna uma descrição contendo: a estrutura na qual esse objeto se encontra (<code>tibble</code>); as dimensões dessa tabela (<code>53,940 x 10</code>); as classes associadas a esse objeto (<code>S3: tbl_df/tbl/data.frame</code>); os nomes das colunas dessa tabela (<code>$ carat</code>, <code>$ cut</code>, <code>$ color</code>, etc); além de uma abreviação que indica o tipo de dado associado a cada uma dessas colunas (<code>num</code> para <code>numeric</code>, <code>int</code> para <code>integer</code>, etc.).</p>
<p></p>
<div class="sourceCode" id="cb182"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org">ggplot2</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">diamonds</span><span class="op">)</span></span></code></pre></div>
<pre><code>## tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)
##  $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...
##  $ cut    : Ord.factor w/ 5 levels "Fair"&lt;"Good"&lt;..: 5 4 2 4 2 3 3 3 1 3 ...
##  $ color  : Ord.factor w/ 7 levels "D"&lt;"E"&lt;"F"&lt;"G"&lt;..: 2 2 2 6 7 7 6 5 2 5 ...
##  $ clarity: Ord.factor w/ 8 levels "I1"&lt;"SI2"&lt;"SI1"&lt;..: 2 3 5 4 2 6 7 3 4 5 ...
##  $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...
##  $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...
##  $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...
##  $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...
##  $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...
##  $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...</code></pre>
<p></p>
<p>Como um segundo exemplo, ao aplicarmos a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> sobre uma lista, a descrição resultante me confirma que o objeto se trata de uma lista de 5 elementos (<code>List of 5</code>). Devido à abreviação <code>chr</code> presente nos elementos <code>produto_vendido</code> e <code>data_de_registro</code>, nós também identificamos que os valores armazenados nesses elementos da lista estão associados ao tipo <code>character</code>.</p>
<p></p>
<div class="sourceCode" id="cb184"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">registro_venda</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>  produto_vendido <span class="op">=</span> <span class="st">"Leite Mua 1L"</span>,</span>
<span>  unidades_vendidas <span class="op">=</span> <span class="fl">5</span>,</span>
<span>  preco_por_unidade <span class="op">=</span> <span class="fl">3.45</span>,</span>
<span>  valor_venda <span class="op">=</span> <span class="fl">5</span> <span class="op">*</span> <span class="fl">3.45</span>,</span>
<span>  data_de_registro <span class="op">=</span> <span class="st">"2021-08-22"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">registro_venda</span><span class="op">)</span></span></code></pre></div>
<pre><code>## List of 5
##  $ produto_vendido  : chr "Leite Mua 1L"
##  $ unidades_vendidas: num 5
##  $ preco_por_unidade: num 3.45
##  $ valor_venda      : num 17.2
##  $ data_de_registro : chr "2021-08-22"</code></pre>
<p></p>
<p>Como um terceiro exemplo, quando aplicamos a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> sobre um vetor, podemos identificar o tipo de dado associado àquele vetor além de suas dimensões. Pela demonstração abaixo, sabemos através da abreviação <code>int</code> que o vetor <code>sequencia</code> contém dados do tipo <code>integer</code>, e que este vetor possui 100 elementos (<code>[1:100]</code>).</p>
<p></p>
<div class="sourceCode" id="cb186"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sequencia</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">100</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">sequencia</span><span class="op">)</span></span></code></pre></div>
<pre><code>##  int [1:100] 1 2 3 4 5 6 7 8 9 10 ...</code></pre>
<p></p>
<p>Portanto, a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> é a forma mais prática e visual de se identificar as características principais de um objeto no R. Entretanto, futuramente você vai enfrentar situações onde você deve construir um programa (isto é, um <em>script</em>) que executa determinadas ações a depender da estrutura de um objeto ou dos tipos de dados associados a ele. Ou seja, haverá momentos em que você precisa inserir dentro de seu programa, testes que realizam essas verificações de forma automática. O primeiro passo para a construção desses testes são as funções <code>is.*()</code>.</p>
<p>Em geral, toda função <code>is.*()</code> retorna um único valor do tipo <code>logical</code>, informando se o objeto em questão pertence ou não ao tipo ou estrutura definido no nome dessa função. O tipo ou estrutura para a qual você está testando é definido no próprio nome da função. Por exemplo, se eu utilizo a função <code>is.character(x)</code>, eu estou querendo testar se o objeto <code>x</code> está associado ao tipo <code>character</code>. Como demonstrado abaixo, a função <code><a href="https://rdrr.io/r/base/character.html">is.character()</a></code> me retorna um valor <code>TRUE</code> para o objeto <code>nome</code>, entretanto, o mesmo não ocorre para o objeto <code>idade</code>.</p>
<p></p>
<div class="sourceCode" id="cb188"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nome</span> <span class="op">&lt;-</span> <span class="st">"Pedro Faria"</span></span>
<span><span class="va">idade</span> <span class="op">&lt;-</span> <span class="fl">23</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/character.html">is.character</a></span><span class="op">(</span><span class="va">nome</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb190"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/character.html">is.character</a></span><span class="op">(</span><span class="va">idade</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p></p>
<p>Em resumo, se você deseja testar se um objeto possui uma certa propriedade, procure por uma função cujo nome comece por <code>"is."</code> seguido pelo nome dessa estrutura ou tipo no qual você está interessado. Como uma lista inicial, as funções para os tipos de dados são:</p>
<ul>
<li>
<code><a href="https://rdrr.io/r/base/integer.html">is.integer()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/character.html">is.character()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/numeric.html">is.numeric()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/double.html">is.double()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/logical.html">is.logical()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/is.recursive.html">is.atomic()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/complex.html">is.complex()</a></code>.</li>
</ul>
<p>Já para o caso das estruturas de dados, estamos nos referindo às seguintes funções:</p>
<ul>
<li>
<code><a href="https://rdrr.io/r/base/vector.html">is.vector()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/list.html">is.list()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/as.data.frame.html">is.data.frame()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/matrix.html">is.matrix()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/array.html">is.array()</a></code>.</li>
<li><code><a href="https://tibble.tidyverse.org/reference/is_tibble.html">tibble::is_tibble()</a></code></li>
</ul>
<p>Uma outra forma (mais informal) de se identificar o tipo de dado associado a um objeto (ou a uma parte desse objeto) é através da função <code><a href="https://rdrr.io/r/base/typeof.html">typeof()</a></code>. Ao aplicar essa função sobre um objeto específico (ou sobre uma parte desse objeto), a função nos retorna o nome do tipo de dado associado a este objeto.</p>
<p></p>
<div class="sourceCode" id="cb192"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1L</span>, <span class="fl">2L</span>, <span class="fl">3L</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "integer"</code></pre>
<p></p>
<div id="tome-muito-cuidado-com-is.vector-e-is.numeric" class="section level3" number="2.6.1">
<h3>
<span class="header-section-number">2.6.1</span> Tome muito cuidado com <code>is.vector()</code> e <code>is.numeric()</code><a class="anchor" aria-label="anchor" href="#tome-muito-cuidado-com-is.vector-e-is.numeric"><i class="fas fa-link"></i></a>
</h3>
<p>A função <code><a href="https://rdrr.io/r/base/vector.html">is.vector()</a></code> testa se um objeto é um vetor atômico. Porém, o principal problema dessa função é que ela baseia o seu teste na ausência de atributos, ao invés de se preocupar se o objeto se encaixa ou não na descrição de um vetor. Você pode encontrar mais detalhes sobre isso ao ler atentamente a documentação interna da função, com o comando <code><a href="https://rdrr.io/r/base/vector.html">?is.vector</a></code>. Mas em resumo, a função <code><a href="https://rdrr.io/r/base/vector.html">is.vector()</a></code> testa se o objeto em questão, é um vetor que não possui atributos (exceto o atributo <code>names</code>).</p>
<p>Vamos descrever o que são atributos mais a frente, mas devido a essa especificação, a função <code><a href="https://rdrr.io/r/base/vector.html">is.vector()</a></code> retorna <code>FALSE</code> para diversos tipos de vetores “não-atômicos”, como os tipos <code>factor</code>, <code>Date</code>, <code>POSIXct</code> e <code>POSIXlt</code> (vamos descrever esses tipos em capítulos posteriores), pois todos eles possuem um atributo chamado <code>class</code>. Para mais, saiba que <code><a href="https://rdrr.io/r/base/vector.html">is.vector()</a></code> retorna <code>TRUE</code> para listas, pois como descrevemos na seção <a href="fundamentos-da-linguagem-r.html#sec:estrutura_listas">Listas</a>, listas são no fundo, vetores. Além disso, listas geralmente contém no máximo um atributo <code>names</code> (o qual é permitido por <code><a href="https://rdrr.io/r/base/vector.html">is.vector()</a></code>).
Para demonstrar os resultados gerados por cada função que vou apresentar nessa seção, estou criando abaixo alguns objetos de teste, além de uma função que será responsável por aplicar a função sobre cada um desses objetos.</p>
<p></p>
<div class="sourceCode" id="cb194"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html">array</a></span><span class="op">(</span><span class="fl">1</span>, dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">l</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">v1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html">as.Date</a></span><span class="op">(</span><span class="st">"2021-01-01"</span><span class="op">)</span></span>
<span><span class="va">v2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html">factor</a></span><span class="op">(</span><span class="st">"a"</span><span class="op">)</span></span>
<span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="va">aplicar_teste</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">objs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">m</span>, <span class="va">a</span>, <span class="va">l</span>, <span class="va">d</span>, <span class="va">v1</span>, <span class="va">v2</span>, <span class="va">vec</span>, <span class="cn">NULL</span><span class="op">)</span></span>
<span>  <span class="va">r</span> <span class="op">&lt;-</span> <span class="fu">purrr</span><span class="fu">::</span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_lgl</a></span><span class="op">(</span><span class="va">objs</span>, <span class="va">x</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span></span>
<span>    <span class="st">"matrix"</span>, <span class="st">"array"</span>, <span class="st">"list"</span>,</span>
<span>    <span class="st">"data.frame"</span>, <span class="st">"Date"</span>, </span>
<span>    <span class="st">"factor"</span>, <span class="st">"double"</span>, </span>
<span>    <span class="st">"NULL"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Perceba pelo resultado abaixo, que a função <code><a href="https://rdrr.io/r/base/vector.html">is.vector()</a></code> nos retorna <code>TRUE</code> para uma lista (<code>list</code>), mas nos retorna <code>FALSE</code> para diversos vetores associados a tipos “não-atômicos” da linguagem, como os tipos <code>Date</code> e <code>factor</code>.</p>
<p></p>
<div class="sourceCode" id="cb195"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">aplicar_teste</span><span class="op">(</span><span class="va">is.vector</span><span class="op">)</span></span></code></pre></div>
<pre><code>##     matrix      array       list data.frame       Date     factor 
##      FALSE      FALSE       TRUE      FALSE      FALSE      FALSE 
##     double       NULL 
##       TRUE      FALSE</code></pre>
<p></p>
<p>Devido a essas características, caso você deseje testar se um objeto <code>x</code> é um vetor atômico de forma mais restrita (isto é, que retorna <code>FALSE</code> para listas e <code>FALSE</code> para tipos de dados “não-atômicos” como <code>Date</code> e <code>factor</code>), você pode utilizar o teste lógico <code>is.vector(x) &amp; !is.list(x)</code>. Como demonstrado abaixo, esse teste retorna <code>TRUE</code> para <code>vec</code>, mas <code>FALSE</code> para <code>l</code> e para <code>v1</code>.</p>
<p></p>
<div class="sourceCode" id="cb197"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/vector.html">is.vector</a></span><span class="op">(</span><span class="va">l</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">is.list</a></span><span class="op">(</span><span class="va">l</span><span class="op">)</span> <span class="co"># lista</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb199"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/vector.html">is.vector</a></span><span class="op">(</span><span class="va">v1</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">is.list</a></span><span class="op">(</span><span class="va">v1</span><span class="op">)</span> <span class="co"># Vetor do tipo Date</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb201"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/vector.html">is.vector</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">is.list</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span> <span class="co"># Vetor do tipo double</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p></p>
<p>Dentro dos pacotes básicos do R nós temos a função <code><a href="https://rdrr.io/r/base/is.recursive.html">is.atomic()</a></code>, mas o pacote <code>purrr</code> nos oferece uma função “irmã” chamada de <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic()</a></code> . A única diferença entre essas duas funções, é que <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic()</a></code> retorna <code>FALSE</code> para um valor <code>NULL</code>, enquanto <code><a href="https://rdrr.io/r/base/is.recursive.html">is.atomic()</a></code> retorna <code>TRUE</code>. Para além desse detalhe, você pode reparar abaixo, que ambas as funções retornam um valor <code>TRUE</code> para matrizes (<code>matrix</code>) e <em>arrays</em> (<code>array</code>).</p>
<p></p>
<div class="sourceCode" id="cb203"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://purrr.tidyverse.org/">purrr</a></span><span class="op">)</span></span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb204"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">aplicar_teste</span><span class="op">(</span><span class="va">is_atomic</span><span class="op">)</span></span></code></pre></div>
<pre><code>##     matrix      array       list data.frame       Date     factor 
##       TRUE       TRUE      FALSE      FALSE       TRUE       TRUE 
##     double       NULL 
##       TRUE      FALSE</code></pre>
<div class="sourceCode" id="cb206"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">aplicar_teste</span><span class="op">(</span><span class="va">is.atomic</span><span class="op">)</span></span></code></pre></div>
<pre><code>##     matrix      array       list data.frame       Date     factor 
##       TRUE       TRUE      FALSE      FALSE       TRUE       TRUE 
##     double       NULL 
##       TRUE       TRUE</code></pre>
<p></p>
<p>Com esses detalhes em mente, se você deseja adotar um conceito levemente mais abrangente de vetor, de forma a testar se um objeto é um vetor e incluir os diversos tipos “não-atômicos” como <code>Date</code> e <code>factor</code>, você pode utilizar a função <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic()</a></code> do pacote <code>purrr</code>. Mas também é necessário contornar o comportamento de <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic()</a></code> para matrizes e <em>arrays</em>, ao aplicar o teste lógico <code>is_atomic(x) &amp; is.null(dim(x))</code>.</p>
<p></p>
<div class="sourceCode" id="cb208"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://purrr.tidyverse.org/">purrr</a></span><span class="op">)</span></span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb209"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span> <span class="op">&amp;</span> <span class="fu"><a href="https://rdrr.io/r/base/NULL.html">is.null</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span><span class="op">)</span> <span class="co"># Matriz</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb211"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span> <span class="op">&amp;</span> <span class="fu"><a href="https://rdrr.io/r/base/NULL.html">is.null</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span> <span class="co"># Array</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb213"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic</a></span><span class="op">(</span><span class="va">v1</span><span class="op">)</span> <span class="op">&amp;</span> <span class="fu"><a href="https://rdrr.io/r/base/NULL.html">is.null</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">v1</span><span class="op">)</span><span class="op">)</span> <span class="co"># Vetor do tipo Date</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb215"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span> <span class="op">&amp;</span> <span class="fu"><a href="https://rdrr.io/r/base/NULL.html">is.null</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span><span class="op">)</span> <span class="co"># Vetor do tipo double</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p></p>
<p>Para além de <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_atomic()</a></code>, o pacote <code>purrr</code> também nos oferece a função <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_vector()</a></code>. Ao invés de se preocupar com os atributos que um objeto carrega, a função <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_vector()</a></code> verifica se o objeto <code>x</code> é armazenado (na camada mais profunda da linguagem) a partir de um vetor. Entretanto, como os vetores atômicos são a unidade fundamental das demais estruturas de dados presentes na linguagem, este conceito de vetor adotado por <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_vector()</a></code> é bastante abrangente, de modo que a função nos retorna <code>TRUE</code> para todas as estruturas e tipos de dados, como está demonstrado abaixo. Portanto, de certa forma, <code><a href="https://rlang.r-lib.org/reference/type-predicates.html">is_vector()</a></code> busca identificar se um dado objeto é construído a partir de um vetor, mas não necessariamente se ele é um vetor <em>per se</em>.</p>
<p></p>
<div class="sourceCode" id="cb217"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">aplicar_teste</span><span class="op">(</span><span class="va">is_vector</span><span class="op">)</span></span></code></pre></div>
<pre><code>##     matrix      array       list data.frame       Date     factor 
##       TRUE       TRUE       TRUE       TRUE       TRUE       TRUE 
##     double       NULL 
##       TRUE      FALSE</code></pre>
<p></p>
<p>Por último, como o tipo <code>numeric</code> é um sinônimo para os tipos <code>integer</code> e <code>double</code>, ao aplicar a função <code><a href="https://rdrr.io/r/base/numeric.html">is.numeric()</a></code> sobre um objeto, você está na verdade testando se esse objeto específico está associado ao tipo <code>double</code> ou ao tipo <code>integer</code>. Se você precisa que esse objeto esteja associado a apenas um desses dois tipos, utilize a função correspondente a esse tipo (<code><a href="https://rdrr.io/r/base/integer.html">is.integer()</a></code> ou <code><a href="https://rdrr.io/r/base/double.html">is.double()</a></code>) ao invés de <code><a href="https://rdrr.io/r/base/numeric.html">is.numeric()</a></code>.</p>
</div>
</div>
<div id="sec:coercion_R_fundamentos" class="section level2" number="2.7">
<h2>
<span class="header-section-number">2.7</span> Coerção no R<a class="anchor" aria-label="anchor" href="#sec:coercion_R_fundamentos"><i class="fas fa-link"></i></a>
</h2>
<p>Quando discuti sobre vetores e sua principal propriedade (<strong>vetores podem manter apenas um tipo de dado dentro dele</strong>), eu mencionei que caso você tentasse burlar essa regra, o R automaticamente converteria todos os valores para um único tipo de dado. Este processo é usualmente chamado por <em>coercion</em>, ou coerção, e iremos explicar como ele funciona nesta seção.</p>
<p>Em resumo, coerção é o processo em que o R converte automaticamente e, <strong>implicitamente</strong>, valores de um tipo de dado para um outro tipo. Esse processo é bem semelhante ao processo de coerção que ocorre na linguagem JavaScript, sendo a soma entre um número e um <em>string</em>, o exemplo mais clássico de coerção em JavaScript. Reproduzindo esse exemplo abaixo, nós estamos somando um valor numérico a um texto. Ao perceber essa diferença entre os tipos de dados, o JavaScript converte automaticamente o valor <code>10</code> para o tipo <em>string</em>, antes de executar a soma. Logo, ao realizar essa conversão, o JavaScript transforma uma soma entre um número e um <em>string</em>, em uma soma entre dois <em>strings</em> e, como resultado, o JavaScript apenas concatena os dois números um do lado do outro, como demonstrado abaixo:</p>
<p></p>
<div class="sourceCode" id="cb219"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb219-1"><a href="fundamentos-da-linguagem-r.html#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Em JavaScript:</span></span>
<span id="cb219-2"><a href="fundamentos-da-linguagem-r.html#cb219-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> x <span class="op">=</span> <span class="dv">10</span> <span class="op">+</span> <span class="st">"20"</span></span>
<span id="cb219-3"><a href="fundamentos-da-linguagem-r.html#cb219-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(x)</span></code></pre></div>
<script>
// Em JavaScript:
var x = 10 + "20"
print(x)
</script><p></p>
<pre><code>1020</code></pre>
<p></p>
<div class="sourceCode" id="cb221"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb221-1"><a href="fundamentos-da-linguagem-r.html#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeof</span>(x)</span></code></pre></div>
<p></p>
<pre><code>"string"</code></pre>
<p>Apesar da semelhança, processos de coerção no R, ocorrem geralmente quando estamos lidando com vetores de alguma maneira, especialmente quando estamos alterando partes de um vetor específico, ou também, quando estamos calculando um vetor a partir de uma função, e essa função nos retorna mais de 1 tipo de dado em seus resultados. Provavelmente, o exemplo mais clássico de coerção no R, está na concatenação entre um número e um texto. Perceba abaixo, que independente do vetor <code>vec</code> possuir valores do tipo <code>integer</code> (<code>1L</code> e <code>2L</code>), todo o vetor foi automaticamente convertido para o tipo <code>character</code>.</p>
<p></p>
<div class="sourceCode" id="cb223"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1L</span>, <span class="fl">2L</span>, <span class="st">"Texto"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "character"</code></pre>
<p></p>
<p>Um outro exemplo bem comum de coerção no R, é quando inserimos valores de um tipo “y” em um vetor que contém valores de um tipo “x”. Repare abaixo que, inicialmente, o vetor <code>a</code> possuía 3 elementos que pertenciam ao tipo <code>integer</code>. Porém, ao inserirmos um texto como quarto elemento desse vetor, todos os elementos desse vetor foram automaticamente convertidos para o tipo <code>character</code>:</p>
<p></p>
<div class="sourceCode" id="cb225"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1L</span>, <span class="fl">2L</span>, <span class="fl">3L</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "integer"</code></pre>
<div class="sourceCode" id="cb227"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"Texto"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "1"     "2"     "3"     "Texto"</code></pre>
<div class="sourceCode" id="cb229"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "character"</code></pre>
<p></p>
<p>Os exemplos acima são ilustrativos, pois na prática, você geralmente não provoca um processo coerção de forma proposital. Na grande maioria das vezes, você será surpreendido por tal evento. Um exemplo bastante comum no dia-a-dia de coerção ocorre durante a importação de bases de dados mal formatadas. Isso significa que, um processo de coerção pode representar, em muitos momentos, um sinal vermelho para você, lhe indicando que há algo mal formatado na sua base de dados, ou que, você não está incluindo alguma configuração importante no comando de importação da base, ou ainda, que algum de seus comandos no R está gerando um <em>bug</em>, ou um resultado que os demais comandos de seu <em>script</em> não são capazes de lidar com.</p>
<p>Por outro lado, uma situação em que é extremamente útil nos aproveitarmos dessa coerção, é quando queremos somar um vetor lógico. Pois ao convertermos um vetor <code>logical</code> para um vetor <code>integer</code>, os valores <code>TRUE</code> são automaticamente convertidos para 1, enquanto valores <code>FALSE</code> são convertidos para 0. Com isso, você pode aplicar a função <code><a href="https://rdrr.io/r/base/sum.html">sum()</a></code> sobre um teste lógico para descobrir, por exemplo, quantos elementos de um vetor são maiores do que 5. Para mais, ao calcularmos a média desse vetor lógico, com a função <code><a href="https://rdrr.io/r/base/mean.html">mean()</a></code>, estamos na verdade calculando a proporção de <code>TRUE</code>’s neste vetor.</p>
<p></p>
<div class="sourceCode" id="cb231"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.2</span>, <span class="fl">3.6</span>, <span class="fl">7.8</span>, <span class="fl">1.9</span>, <span class="fl">5.2</span>, <span class="fl">9.6</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">vec</span> <span class="op">&gt;</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode" id="cb233"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">vec</span> <span class="op">&gt;</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 0.5</code></pre>
<p></p>
<p>Um processo de coerção ocorre apenas sobre vetores atômicos. Porém, lembre-se que todas as outras estruturas são construídas a partir desses vetores, ou todas as outras estruturas podem conter esses vetores dentro delas. Por isso, uma coluna de seu <code>data.frame</code>, ou toda uma matriz, podem sofrer uma coerção, independentemente de você ter ou não requisitado por tal transformação.</p>
<div id="a-árvore-de-coerção" class="section level3" number="2.7.1">
<h3>
<span class="header-section-number">2.7.1</span> A árvore de coerção<a class="anchor" aria-label="anchor" href="#a-%C3%A1rvore-de-coer%C3%A7%C3%A3o"><i class="fas fa-link"></i></a>
</h3>
<p>Quando o processo de coerção ocorre, o R segue uma regra bem simples para escolher o tipo de dado para o qual os seus valores serão convertidos. Em resumo, o R irá sempre transformar os seus dados para o tipo de dado mais flexível, seguindo uma espécie de árvore ou hierarquia, a qual está referenciada na figura 2.11. Você pode ver que o tipo <code>character</code>, está no topo da árvore e, portanto, é o tipo mais flexível de todos, enquanto o <code>logical</code> que está na base, é o tipo mais restrito de todos.</p>
<p>Isso significa, que se você criar um vetor com valores <code>integer</code> e <code>logical</code>, todos esses valores serão convertidos para <code>integer</code>’s. Por outro lado, se for um vetor com valores <code>integer</code> e <code>character</code>, esses valores serão convertidos para <code>character</code>’s. E assim por diante. Ou seja, você é capaz de prever para qual tipo esse vetor será convertido, ao olhar para os dois tipos que estão sendo misturados neste vetor, e identificar qual deles é tipo de dado mais flexível.</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-120"></span>
<embed src="Introducao_R_files/figure-html/unnamed-chunk-120-1.pdf" title="Árvore de coerção" width="65%" type="application/pdf"></embed><p class="caption">
Figura 2.11: Árvore de coerção
</p>
</div>
<p></p>
</div>
<div id="coerções-explícitas-com-as-funções-as." class="section level3" number="2.7.2">
<h3>
<span class="header-section-number">2.7.2</span> Coerções explícitas com as funções <code>as.*()</code><a class="anchor" aria-label="anchor" href="#coer%C3%A7%C3%B5es-expl%C3%ADcitas-com-as-fun%C3%A7%C3%B5es-as."><i class="fas fa-link"></i></a>
</h3>
<p>Na seção <a href="fundamentos-da-linguagem-r.html#sec:funcoes_str_is">Identificando tipos e estruturas com a função <code>str()</code> e as funções <code>is.*()</code></a>, mostramos as funções <code>is.*()</code> que servem para identificarmos se um objeto pertence ou não a uma estrutura ou um tipo de dado específicos. Para além dessas funções, o R também nos oferece as funções <code>as.*()</code>.</p>
<p>Em suma, as funções <code>as.*()</code> servem para convertermos explicitamente os valores de um objeto para um tipo de dado específico. Ou seja, você aplica uma dessas funções quando você deseja provocar explicitamente um processo de coerção sobre um objeto. Como exemplo, se eu tenho um vetor contendo valores do tipo <code>double</code>, e desejo transformá-los em valores do tipo <code>character</code>, eu preciso apenas fornecer este vetor à função <code><a href="https://rdrr.io/r/base/character.html">as.character()</a></code>. Veja o exemplo abaixo:</p>
<p></p>
<div class="sourceCode" id="cb235"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0.5</span>, <span class="op">-</span><span class="fl">2</span>, <span class="fl">20</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="va">vetor</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "0"   "1"   "0.5" "-2"  "20"</code></pre>
<p></p>
<p>Da mesma forma como ocorre com as funções <code>is.*()</code>, o nome da função <code>as.*()</code> que você está utilizando, determina o tipo de dado com o qual essa função trabalha. Logo, a função <code><a href="https://rdrr.io/r/base/logical.html">as.logical()</a></code> busca converter um objeto para o tipo <code>logical</code>, enquanto a função <code><a href="https://rdrr.io/r/base/integer.html">as.integer()</a></code>, converte um objeto para o tipo <code>integer</code>, e assim por diante. Abaixo temos uma lista dessas funções.</p>
<ul>
<li>
<code><a href="https://rdrr.io/r/base/character.html">as.character()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/double.html">as.double()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/integer.html">as.integer()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/logical.html">as.logical()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/numeric.html">as.numeric()</a></code>.</li>
</ul>
<p>Apesar de serem funções extremamente úteis, o R não é capaz de fazer mágica. Quando uma função <code>as.*()</code> encontra algum elemento que ela não consegue converter (de alguma forma lógica) para o tipo especificado, a função acaba inserindo um valor <code>NA</code> (valor não disponível) no lugar deste elemento. Por exemplo, se eu possuo o objeto <code>D</code> abaixo, e tento convertê-lo para o tipo <code>double</code>, apenas o terceiro elemento deste objeto é de fato convertido, pois o R <strong>não sabe como</strong> converter os outros dois elementos para o tipo <code>double</code>.</p>
<p></p>
<div class="sourceCode" id="cb237"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">D</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"R$2,45"</span>, <span class="st">"Texto"</span>, <span class="st">"8.90"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/double.html">as.double</a></span><span class="op">(</span><span class="va">D</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Warning: NAs introduzidos por coerção</code></pre>
<pre><code>## [1]  NA  NA 8.9</code></pre>
<p></p>
<p>Como um outro exemplo, ao utilizarmos a função <code><a href="https://rdrr.io/r/base/logical.html">as.logical()</a></code> sobre um objeto <code>x</code>, se esse objeto <code>x</code> se encontra no tipo <code>double</code> ou <code>integer</code>, todos os valores que forem iguais a 0, serão convertidos para <code>FALSE</code>, enquanto todos os demais valores (diferentes de 0) serão convertidos para <code>TRUE</code>. Contudo, se o objeto <code>x</code> se encontra no tipo <code>character</code>, apenas textos explícitos dos valores lógicos (<code>FALSE</code> e <code>TRUE</code>), podem ser convertidos. Perceba pelo exemplo abaixo, que o R consegue converter apenas os elementos 1, 5 e 6 do vetor.</p>
<p></p>
<div class="sourceCode" id="cb240"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vetor</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"TRUE"</span>, <span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"F"</span>, <span class="st">"T"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/logical.html">as.logical</a></span><span class="op">(</span><span class="va">vetor</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1]  TRUE    NA    NA    NA FALSE  TRUE</code></pre>
<p></p>
</div>
<div id="também-podemos-converter-estruturas-de-dados-com-as-funções-as." class="section level3" number="2.7.3">
<h3>
<span class="header-section-number">2.7.3</span> Também podemos converter estruturas de dados com as funções <code>as.*()</code><a class="anchor" aria-label="anchor" href="#tamb%C3%A9m-podemos-converter-estruturas-de-dados-com-as-fun%C3%A7%C3%B5es-as."><i class="fas fa-link"></i></a>
</h3>
<p>Apesar do processo de coerção ocorrer (de forma automática e implícita) apenas sobre os tipos de dados associados a um objeto, nós também temos a capacidade de provocar um “processo de coerção” sobre a estrutura de dado empregada por um objeto, com as funções <code>as.*()</code>. Ou seja, da mesma forma que temos uma função <code>as.*()</code> para cada tipo de dado, nós também temos uma função <code>as.*()</code> para cada estrutura de dado do R. Como uma lista inicial, temos as seguintes funções:</p>
<ul>
<li>
<code><a href="https://rdrr.io/r/base/vector.html">as.vector()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/list.html">as.list()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/matrix.html">as.matrix()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/array.html">as.array()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame()</a></code>.</li>
<li>
<code><a href="https://tibble.tidyverse.org/reference/as_tibble.html">tibble::as_tibble()</a></code>.</li>
</ul>
<p>Algumas conversões são bem diretas, e simples de se compreender. Por exemplo, uma lista (<code>list</code>) pode ser facilmente convertida para um <code>data.frame</code>, pois como descrevemos na seção <a href="fundamentos-da-linguagem-r.html#sec:estrutura_data_frames">Tabelas no R: <code>data.frame</code></a>, um <code>data.frame</code> é no fundo, uma lista nomeada com elementos de mesmo comprimento. Tal conversão é demonstrada no exemplo abaixo.</p>
<p></p>
<div class="sourceCode" id="cb242"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lista</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>  produtoid <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1335</span>, <span class="fl">1335</span>, <span class="fl">1242</span>, <span class="fl">1198</span><span class="op">)</span>,</span>
<span>  preco <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.4</span>, <span class="fl">2.4</span>, <span class="fl">5.6</span>, <span class="fl">1.9</span><span class="op">)</span>,</span>
<span>  unidades <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">200</span>, <span class="fl">100</span>, <span class="fl">430</span>, <span class="fl">90</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">data_frame</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="va">lista</span><span class="op">)</span></span>
<span><span class="va">data_frame</span></span></code></pre></div>
<pre><code>##   produtoid preco unidades
## 1      1335   2.4      200
## 2      1335   2.4      100
## 3      1242   5.6      430
## 4      1198   1.9       90</code></pre>
<p></p>
<p>Por outro lado, algumas conversões podem ser estranhas. Por exemplo, ao convertermos uma matriz para uma lista, cada elemento dessa matriz é transformada em um elemento dessa nova lista. Esse mesmo processo ocorre se convertermos um vetor em uma lista. Lembre-se que, uma matriz é no fundo, um vetor com duas dimensões. Logo, ao requisitarmos a conversão de uma matriz para uma lista, é como se essa matriz fosse convertida primeiro para um vetor e, a partir desse vetor, fosse convertida para uma lista.</p>
<p></p>
<div class="sourceCode" id="cb244"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">m</span></span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4</code></pre>
<div class="sourceCode" id="cb246"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] 4</code></pre>
<p></p>
</div>
</div>
<div id="um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r" class="section level2" number="2.8">
<h2>
<span class="header-section-number">2.8</span> Um estudo de caso: importando os dados da PINTEC-IBGE para o R<a class="anchor" aria-label="anchor" href="#um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r"><i class="fas fa-link"></i></a>
</h2>
<p>Como um exemplo prático de coerção, durante um determinado dia eu (Pedro) estava analisando os dados da PINTEC-IBGE (Pesquisa de Inovação), mais especificamente, a tabela 1 da pesquisa referente à edição de 2000. Com os comandos abaixo, você pode baixar o arquivo dessa tabela em Excel para um diretório temporário de seu computador e importá-la para dentro de seu R, de modo que você possa acompanhar os próximos comandos que vou mostrar.</p>
<p></p>
<div class="sourceCode" id="cb248"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://readxl.tidyverse.org">readxl</a></span><span class="op">)</span></span>
<span><span class="va">github</span> <span class="op">&lt;-</span> <span class="st">"https://github.com/pedropark99/"</span></span>
<span><span class="va">pasta</span> <span class="op">&lt;-</span> <span class="st">"Curso-R/raw/master/Dados/"</span></span>
<span><span class="va">arquivo</span> <span class="op">&lt;-</span> <span class="st">"tab01_2000.xls"</span></span>
<span></span>
<span><span class="va">url</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="va">github</span>, <span class="va">pasta</span>, <span class="va">arquivo</span><span class="op">)</span></span>
<span></span>
<span><span class="va">dir</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tempfile.html">tempdir</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">caminho</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="va">dir</span>, <span class="va">arquivo</span>, sep <span class="op">=</span> <span class="st">"\\"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/download.file.html">download.file</a></span><span class="op">(</span><span class="va">url</span>, destfile <span class="op">=</span> <span class="va">caminho</span>, mode <span class="op">=</span> <span class="st">"wb"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">tab1</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu"><a href="https://readxl.tidyverse.org/reference/read_excel.html">read_excel</a></span><span class="op">(</span></span>
<span>  <span class="va">caminho</span>, </span>
<span>  range <span class="op">=</span> <span class="st">"A9:R57"</span>,</span>
<span>  col_names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"X"</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">18</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>Neste dia, eu estava tentado calcular uma simples soma das colunas <code>X5</code> e <code>X6</code>, porém, o R estava me retornando o erro abaixo, me indicando que alguma dessas colunas estava associada a um tipo de dado não-numérico.</p>
<p></p>
<div class="sourceCode" id="cb249"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tab1</span><span class="op">$</span><span class="va">X6</span> <span class="op">+</span> <span class="va">tab1</span><span class="op">$</span><span class="va">X5</span></span></code></pre></div>
<p></p>
<pre><code>Error in tab1$X6 + tab1$X5 : non-numeric argument to binary operator</code></pre>
<p>Este é um erro inesperado, pois quando abrimos o arquivo Excel da tabela, podemos observar que praticamente todas as colunas da tabela (incluindo as colunas <code>X6</code> e <code>X5</code>) são claramente colunas numéricas e, portanto, deveriam estar sendo interpretadas por tipos numéricos. Ao analisarmos mais de perto a estrutura do objeto <code>tab1</code> com a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code>, podemos perceber que diversas colunas da tabela (incluindo a coluna <code>X6</code>) estão sendo interpretadas pelo tipo <code>character</code>, ao invés do tipo <code>double</code>.</p>
<p></p>
<div class="sourceCode" id="cb251"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">tab1</span><span class="op">)</span></span></code></pre></div>
<p></p>
<pre><code>tibble [49 x 18] (S3: tbl_df/tbl/data.frame)
 $ X1 : chr [1:49] "Total" "Indústrias extrativas" ...
 $ X2 : num [1:49] 72005 1729 70277 10253 9491 ...
 $ X3 : num [1:49] 22698 297 22401 3024 2773 ...
 $ X4 : num [1:49] 12658.5 92.5 12566 1683.5 1559 ...
 $ X5 : num [1:49] 10355.5 68.1 10287.3 1553.2 1439.4 ...
 $ X6 : chr [1:49] "2974.6496207720083" "27.740643394384399" ...
 $ X7 : num [1:49] 18160 285 17874 2558 2320 ...
 $ X8 : num [1:49] 16753 254 16499 2331 2099 ...
 $ X9 : num [1:49] 2000 36 1964 327 318 ...
 $ X10: num [1:49] 8120.3 80.7 8039.6 1216.7 1105.9 ...
 $ X11: num [1:49] 8944 146 8798 1325 1221 ...
 $ X12: chr [1:49] "3427.0471614397024" "25.137011567518176" ...
 $ X13: chr [1:49] "2996.0692977925214" "91.851470771912076" ...
 $ X14: num [1:49] 2520.6 28.6 2492 355.6 322.8 ...
 $ X15: chr [1:49] "4276.5049681355704" "62.304616808180924" ...
 $ X16: chr [1:49] "2264.1329981437439" "6.021725515719007" ...
 $ X17: chr [1:49] "1175.6811947066112" "51.283169365446376" ...
 $ X18: chr [1:49] "836.69077528521564" "4.99972192701554" ...</code></pre>
<p>Podemos confirmar esse cenário, ao aplicarmos a função <code><a href="https://rdrr.io/r/base/character.html">is.character()</a></code> sobre a coluna <code>X6</code>, como demonstrado abaixo:</p>
<p></p>
<div class="sourceCode" id="cb253"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/character.html">is.character</a></span><span class="op">(</span><span class="va">tab1</span><span class="op">$</span><span class="va">X6</span><span class="op">)</span></span></code></pre></div>
<p></p>
<pre><code>[1] TRUE</code></pre>
<p>Portanto, identificamos a origem do erro: a coluna <code>X6</code> está sendo interpretada pelo tipo <code>character</code> e, consequentemente, não pode ser somada diretamente a uma coluna do tipo <code>numeric</code>. Poderíamos utilizar a função <code><a href="https://rdrr.io/r/base/numeric.html">as.numeric()</a></code> sobre a coluna <code>X6</code> e somar o resultado à coluna <code>X5</code> para contornarmos esse problema. Todavia, seria útil identificarmos o porquê dessa coluna estar sendo interpretada desde o início como uma coluna de texto.</p>
<p>Se no arquivo original <code>tab01_2000.xls</code>, essas colunas estão configuradas como colunas numéricas, o mesmo deveria ocorrer dentro do R. Porque o R decidiu aplicar o tipo <code>character</code> sobre essas colunas? Podemos encontrar a resposta para essa pergunta ao olharmos mais atentamente para o intervalo da linha 15 à linha 24 dessa coluna <code>X6</code>. Abaixo, estou justamente selecionando esse intervalo de linhas da coluna. Perceba que na sexta linha do resultado, temos um símbolo de menos (<code>-</code>).</p>
<p></p>
<div class="sourceCode" id="cb255"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tab1</span><span class="op">[</span><span class="fl">15</span><span class="op">:</span><span class="fl">24</span>, <span class="st">"X6"</span><span class="op">]</span></span></code></pre></div>
<p></p>
<pre><code>### A tibble: 10 x 1
##    X6                
##    &lt;chr&gt;             
##  1 47.766222201789986
##  2 53.292711161353139
##  3 0                 
##  4 1.222975124981859 
##  5 0                 
##  6 -                 
##  7 1.222975124981859 
##  8 452.69478203700271
##  9 384.49410807956616
## 10 68.200673957436564</code></pre>
<p>Pense sobre “como o R deveria interpretar esse sinal de menos?”. Considerando apenas as 10 primeiras linhas da coluna <code>X6</code>, o R claramente optaria por um tipo de dado numérico para interpretar essa coluna. Contudo, ao se deparar com esse sinal de menos, como o R converteria esse símbolo para um número? A resposta é: ele simplesmente não sabe como realizar essa conversão! Logo, como o R não sabe como converter esse sinal de menos para um número, ele optou por interpretar esse símbolo pelo tipo de dado mais flexível de todos. Isto é, o tipo <code>characater</code>. Ao interpretar esse símbolo pelo tipo <code>character</code>, o R percebeu que teria de converter toda a coluna <code>X6</code> para o tipo <code>character</code> para manter esses dados juntos em uma mesma coluna.</p>
<p>Concluindo, este é um exemplo onde uma formatação ruim da base de dados, pode levar a coerções implícitas e inesperadas no R. Como um exercício, você pode abrir o arquivo <code>tab01_2000.xls</code> no Excel, e eliminar manualmente esse símbolo de menos da coluna <code>X6</code>, e tentar importar novamente o arquivo para o R. Ao fazer isso, você vai perceber que o tipo <code>double</code> será empregado sobre a coluna <code>X6</code>, ao invés do tipo <code>character</code>, pois justamente o R não enfrentou o entrave de encontrar um símbolo ou um texto, em uma coluna que é claramente numérica.</p>
</div>
<div id="subsetting" class="section level2" number="2.9">
<h2>
<span class="header-section-number">2.9</span> <em>Subsetting</em><a class="anchor" aria-label="anchor" href="#subsetting"><i class="fas fa-link"></i></a>
</h2>
<p>As operações de <em>subsetting</em>, são extremamente importantes no R, e você irá utilizá-las com grande frequência ao longo de seu trabalho. Ao longo das seções de <a href="fundamentos-da-linguagem-r.html#sec:estruturas_dados">Estruturas de Dados</a>, eu dei exemplos sobre como utilizar o <em>subsetting</em> com cada tipo de estrutura. Tendo isso em mente, essa seção busca explicitar (ou formalizar) algumas características importantes dessas operações. Como o próprio nome dá a entender, as operações de <em>subsetting</em> servem para extrairmos ou modificarmos <em>subsets</em> (partes) de seus objetos <span class="citation">(<a href="refer%C3%AAncias.html#ref-Rlanguage" role="doc-biblioref">TEAM, 2020a</a>)</span>. Como vimos anteriormente, essas operações são realizadas pelas funções <code>[</code> e <code>[[</code>.</p>
<p>Para utilizar a função <code>[</code>, você precisa abrir um par de colchetes (<code>[ ]</code>) após o nome do objeto (ou função) com o qual está trabalhando. Já para a função <code>[[</code>, você necessita abrir dois pares de colchetes (<code>[[ ]]</code>) após o nome (ou função) com o qual você está trabalhando. Também já vimos ao longo das seções de <a href="fundamentos-da-linguagem-r.html#sec:estruturas_dados">Estruturas de Dados</a>, que para extrairmos partes de estruturas unidimensionais como vetores e listas, precisamos de apenas um índice, ou de um único conjunto de índices. Mas para extrairmos partes de estruturas bidimensionais, como matrizes e <code>data.frame</code>’s, precisamos de dois índices, ou de dois conjuntos de índices.</p>
<p>Além disso, lembre-se que como definimos anteriormente, as listas são estruturas especiais, pois podem conter diversas outras estruturas em seus elementos. Portanto, apesar das listas serem estruturas unidimensionais, elas podem conter outras estruturas bidimensionais dentro delas. Por isso, caso você esteja interessado em extrair partes de uma estrutura bidimensional, que está dentro de algum elemento de uma lista, por exemplo, você irá precisar de uma combinação entre um único índice (para acessar o elemento da lista) e outros dois conjuntos de índices (para acessar uma parte específica da estrutura bidimensional).</p>
<div id="principais-diferenças-entre-as-funções-e" class="section level3" number="2.9.1">
<h3>
<span class="header-section-number">2.9.1</span> Principais diferenças entre as funções <code>[</code> e <code>[[</code>:<a class="anchor" aria-label="anchor" href="#principais-diferen%C3%A7as-entre-as-fun%C3%A7%C3%B5es-e"><i class="fas fa-link"></i></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>A função <code>[</code> é capaz de trabalhar com todas as dimensões disponíveis de um objeto. Quais serão essas dimensões disponíveis depende da estrutura em que o objeto se encontra. Por outro lado, a função <code>[[</code> pode trabalhar apenas com uma dessas dimensões disponíveis.</p></li>
<li><p>A função <code>[</code> nos permite extrair um conjunto de elementos (ou seções) de um objeto (Ex: da 1° a 100° linha de um <code>data.frame</code>; os elementos 4, 5 e 8 de um vetor; do 3° ao 6° elemento de uma lista). Já a função <code>[[</code> nos permite extrair uma única parte, ou um único elemento de um objeto (Ex: o 5° elemento de uma lista; a 2° coluna de um <code>data.frame</code>; o 10° elemento de um vetor).</p></li>
<li><p>A função <code>[</code> geralmente lhe retorna um resultado na mesma estrutura de seu objeto original. Em outras palavras, se você utilizar a função <code>[</code> sobre uma lista, ela irá lhe retornar uma lista como resultado. Já a função <code>[[</code>, geralmente lhe retorna um resultado em uma estrutura diferente. Dito de outra forma, se você utilizar a função <code>[[</code> sobre um <code>data.frame</code>, por exemplo, ela geralmente vai lhe retornar um vetor como resultado.</p></li>
</ol>
</div>
<div id="dimensões-disponíveis-em-subsetting" class="section level3" number="2.9.2">
<h3>
<span class="header-section-number">2.9.2</span> Dimensões disponíveis em <em>subsetting</em><a class="anchor" aria-label="anchor" href="#dimens%C3%B5es-dispon%C3%ADveis-em-subsetting"><i class="fas fa-link"></i></a>
</h3>
<p>A estrutura em que um objeto se encontra, define as dimensões que estão disponíveis para as funções <code>[</code> e <code>[[</code> . Logo, se você está trabalhando com um <code>data.frame</code>, por exemplo, você possui duas dimensões (linhas e colunas) com as quais você pode trabalhar com a função <code>[</code>. Mas se você está trabalhando com uma estrutura unidimensional, como um vetor atômico, você terá apenas uma única dimensão (os elementos desse vetor) para trabalhar em ambas às funções de <em>subsetting</em> (<code>[</code> e <code>[[</code>).</p>
<p>Uma das diferenças básicas entre as funções <code>[</code> e <code>[[</code>, se encontra no número de dimensões com as quais elas podem trabalhar. A função <code>[</code>, seria uma forma mais “geral” de <em>subsetting</em>, pois ela pode trabalhar com todas as dimensões disponíveis segundo a estrutura que um objeto se encontra. Já a função <code>[[</code>, representa uma forma mais restritiva de <em>subsetting</em>, pois ela trabalha em geral com apenas uma única dimensão de seu objeto (independentemente de qual seja a sua estrutura).</p>
<p>Portanto, se temos uma estrutura bidimensional como um <code>data.frame</code>, a função <code>[</code> pode trabalhar com as suas duas dimensões (linhas e colunas). Porém, a função <code>[[</code> pode trabalhar apenas com uma dessas dimensões, sendo no caso de <code>data.frame</code>’s, a dimensão das colunas. Agora, quando estamos trabalhando com uma estrutura unidimensional, como nós possuímos apenas uma dimensão (elementos) disponível, não há diferença entre as funções <code>[</code> e <code>[[</code> no sentido estabelecido anteriormente. De qualquer maneira, a função <code>[</code> continuará sendo a forma mais geral e flexível de <em>subsetting</em> para objetos unidimensionais. Pois a função <code>[</code> lhe permite selecionar um conjunto, ou uma sequência de elementos de uma estrutura unidimensional, enquanto que com a função <code>[[</code>, você poderá selecionar apenas um único elemento dessa estrutura. Um resumo das dimensões disponíveis em cada estrutura, se encontra na tabela 2.1.</p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:label3">Tabela 2.1: </span> Resumo das dimensões disponíveis em cada estrutura</caption>
<thead><tr class="header">
<th align="left"><!-- --></th>
</tr></thead>
<tbody><tr class="odd">
<td align="left"><img src="Figuras/subsetting_table.png"></td>
</tr></tbody>
</table></div>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:label4">Tabela 2.2: </span> Notação matemática das dimensões disponíveis em cada estrutura</caption>
<thead><tr class="header">
<th align="left"><!-- --></th>
</tr></thead>
<tbody><tr class="odd">
<td align="left"><img src="Figuras/subsetting_table2.png"></td>
</tr></tbody>
</table></div>
<p>Nós também podemos ver essas diferenças entre as dimensões disponíveis em cada estrutura e para cada função de <em>subsetting</em>, sob uma perspectiva mais matemática, ao formar uma notação matemática de cada estrutura, incluindo subscritos que representem as suas respectivas dimensões. Essa visão está exposta na tabela 2.2. Por exemplo, pegando um <code>data.frame</code> chamado <span class="math inline">\(DF\)</span>, com <span class="math inline">\(i\)</span> linhas e <span class="math inline">\(j\)</span> colunas (<span class="math inline">\(DF_{i,j}\)</span>), temos que o comando <code>DF[2,4]</code> busca extrair o valor (ou valores) localizados na 2° linha da 4° coluna da tabela. Por outro lado, considerando-se uma lista chamada <span class="math inline">\(L\)</span>, contendo <span class="math inline">\(e\)</span> elementos (<span class="math inline">\(L_e\)</span>), o comando <code>L[[4]]</code>, traz como resultado, o 4° elemento dessa lista.</p>
</div>
<div id="tipos-de-índices" class="section level3" number="2.9.3">
<h3>
<span class="header-section-number">2.9.3</span> Tipos de índices<a class="anchor" aria-label="anchor" href="#tipos-de-%C3%ADndices"><i class="fas fa-link"></i></a>
</h3>
<p>Os índices que você fornece às funções <code>[</code> e <code>[[</code>, podem ser de três tipos: 1) índices de texto - <code>character</code>; 2) índices numéricos - <code>integer</code>; 3) índices lógicos - <code>logical</code>. Logo abaixo, temos um exemplo do uso de índices numéricos sobre um vetor qualquer. Lembre-se que no caso de vetores, nós podemos utilizar um único índice para extrairmos um único valor do objeto em questão, e nós utilizamos dois ou mais índices, para extrairmos um conjunto de valores deste mesmo vetor.</p>
<p></p>
<div class="sourceCode" id="cb257"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.2</span>, <span class="fl">1.3</span>, <span class="fl">4.5</span>, <span class="fl">3.7</span>, <span class="fl">5.2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vec</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 3.7</code></pre>
<div class="sourceCode" id="cb259"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 2.2 1.3 4.5 3.7</code></pre>
<div class="sourceCode" id="cb261"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">5</span>,<span class="fl">1</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 4.5 5.2 2.2</code></pre>
<p></p>
<p>Para utilizar um índice de texto (<code>character</code>), o objeto sobre o qual você está trabalhando, deve ser uma estrutura nomeada. Todas as estruturas (vetor, lista, matriz e <code>data.frame</code>) permitem o uso de nomes, que você pode acessar e definir através de funções como <code><a href="https://rdrr.io/r/base/colnames.html">colnames()</a></code>, <code><a href="https://rdrr.io/r/base/row.names.html">row.names()</a></code> e <code><a href="https://rdrr.io/r/base/names.html">names()</a></code>. Sendo que algumas estruturas, mais especificamente os <code>data.frame</code>’s, vão sempre nomear automaticamente os seus elementos. Ou seja, você sempre poderá utilizar um índice de texto em um <code>data.frame</code>, para selecionar alguma de suas colunas. Pois mesmo que você se esqueça de nomear alguma coluna, ao criar o seu <code>data.frame</code>, a função que cria essa estrutura irá automaticamente criar um nome qualquer para cada coluna não nomeada.</p>
<p></p>
<div class="sourceCode" id="cb263"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  id <span class="op">=</span> <span class="va">LETTERS</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">]</span>,</span>
<span>  nome <span class="op">=</span> <span class="st">"Ana"</span>,</span>
<span>  valor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>  <span class="st">"Belo Horizonte"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">df</span></span></code></pre></div>
<pre><code>##      id nome      valor X.Belo.Horizonte.
## 1     a  Ana -0.2843307    Belo Horizonte
## 2  &lt;NA&gt;  Ana  0.8574098    Belo Horizonte
## 3  &lt;NA&gt;  Ana  1.7196273    Belo Horizonte
## 4  &lt;NA&gt;  Ana  0.2700549    Belo Horizonte
## 5  &lt;NA&gt;  Ana -0.4221840    Belo Horizonte
## 6  &lt;NA&gt;  Ana -1.1891133    Belo Horizonte
## 7  &lt;NA&gt;  Ana -0.3310330    Belo Horizonte
## 8  &lt;NA&gt;  Ana -0.9398293    Belo Horizonte
## 9  &lt;NA&gt;  Ana -0.2589326    Belo Horizonte
## 10 &lt;NA&gt;  Ana  0.3943792    Belo Horizonte</code></pre>
<div class="sourceCode" id="cb265"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">df</span><span class="op">)</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"cidade"</span></span>
<span></span>
<span><span class="va">df</span><span class="op">[[</span><span class="st">"cidade"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>##  [1] "Belo Horizonte" "Belo Horizonte" "Belo Horizonte" "Belo Horizonte"
##  [5] "Belo Horizonte" "Belo Horizonte" "Belo Horizonte" "Belo Horizonte"
##  [9] "Belo Horizonte" "Belo Horizonte"</code></pre>
<div class="sourceCode" id="cb267"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"id"</span>, <span class="st">"valor"</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code>##      id      valor
## 1     a -0.2843307
## 2  &lt;NA&gt;  0.8574098
## 3  &lt;NA&gt;  1.7196273
## 4  &lt;NA&gt;  0.2700549
## 5  &lt;NA&gt; -0.4221840
## 6  &lt;NA&gt; -1.1891133
## 7  &lt;NA&gt; -0.3310330
## 8  &lt;NA&gt; -0.9398293
## 9  &lt;NA&gt; -0.2589326
## 10 &lt;NA&gt;  0.3943792</code></pre>
<div class="sourceCode" id="cb269"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span><span class="op">[[</span><span class="st">"valor"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>##  [1] -0.2843307  0.8574098  1.7196273  0.2700549 -0.4221840 -1.1891133
##  [7] -0.3310330 -0.9398293 -0.2589326  0.3943792</code></pre>
<div class="sourceCode" id="cb271"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span><span class="op">[[</span><span class="st">"nome"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>##  [1] "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana"</code></pre>
<p></p>
<p>Em outras estruturas como um vetor, nomes não são atribuídos automaticamente a cada um de seus elementos, e por isso, você deve nomear os elementos deste vetor, para que você seja capaz de utilizar um índice de texto nele. Para isso, basta igualar esses elementos a um valor em texto (valor entre aspas) que representa esse nome, como no exemplo abaixo:</p>
<p></p>
<div class="sourceCode" id="cb273"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span> <span class="op">=</span> <span class="fl">1</span>, <span class="st">"b"</span> <span class="op">=</span> <span class="fl">2</span>, <span class="st">"c"</span> <span class="op">=</span> <span class="fl">3</span>, <span class="st">"d"</span> <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vec</span><span class="op">[</span><span class="st">"c"</span><span class="op">]</span></span></code></pre></div>
<pre><code>## c 
## 3</code></pre>
<div class="sourceCode" id="cb275"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"c"</span>, <span class="st">"b"</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code>## a c b 
## 1 3 2</code></pre>
<div class="sourceCode" id="cb277"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[[</span><span class="st">"b"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p></p>
<p>Por último, os índices lógicos (<code>TRUE</code> ou <code>FALSE</code>) são extremamente úteis em diversas aplicações, especialmente quando desejamos realizar um <em>subsetting</em> mais “complexo”. Porém, pelo fato de que a função <code>[[</code> nos permite extrair apenas uma única parte de um objeto, os índices lógicos são de certa forma inúteis com essa função. Portanto, sempre que utilizar índices do tipo lógico para selecionar os seus dados, você muito provavelmente quer utilizá-los com a função <code>[</code>. Por padrão, as funções <code>[</code> e <code>[[</code>, vão extrair todas as partes de um objeto, que possuírem um valor <code>TRUE</code> correspondente.</p>
<p>Portanto, no exemplo abaixo, caso eu utilize o vetor lógico <code>vlog</code>, para selecionar valores do vetor <code>vec</code>, a função <code>[</code> irá selecionar o 2°, 3° e 5° valor do vetor <code>vec</code>. Pois são essas as posições no vetor <code>vlog</code> que contém <code>TRUE</code>’s. Porém, a principal forma de gerarmos esses vetores lógicos a serem utilizados na função <code>[</code>, é através de testes lógicos. Por exemplo, podemos testar quais valores do vetor <code>vec</code>, são maiores do que 3, através do operador lógico <code>&gt;</code> (maior que).</p>
<p></p>
<div class="sourceCode" id="cb279"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.2</span>, <span class="fl">1.5</span>, <span class="fl">3.4</span>, <span class="fl">6.7</span>, <span class="fl">8.9</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vlog</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="cn">TRUE</span>, <span class="cn">TRUE</span>, <span class="cn">FALSE</span>, <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vec</span><span class="op">[</span><span class="va">vlog</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 1.5 3.4 8.9</code></pre>
<div class="sourceCode" id="cb281"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[</span><span class="va">vec</span> <span class="op">&gt;</span> <span class="fl">3</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 3.4 6.7 8.9</code></pre>
<p></p>
<p>O R possui vários operadores lógicos diferentes, e o operador <code>&gt;</code> é apenas um deles. Um outro operador muito conhecido, é o de negação <code>"!"</code>. Este operador é utilizado, quando você deseja inverter um teste lógico, ou de certa forma, inverter o comportamento da função <code>[</code> quando fornecemos índices lógicos. O que o operador <code>!</code> faz na verdade, é inverter os valores de um vetor lógico. Logo, se eu aplicar este operador ao vetor <code>vlog</code>, esse será o resultado:</p>
<p></p>
<div class="sourceCode" id="cb283"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">!</span><span class="va">vlog</span></span></code></pre></div>
<pre><code>## [1]  TRUE FALSE FALSE  TRUE FALSE</code></pre>
<p></p>
<p>Portanto, os valores que antes eram <code>TRUE</code>, passam a ser <code>FALSE</code>, e vice-versa. Por isso, ao utilizarmos o operador <code>!</code> sobre um teste lógico qualquer, nós invertemos o teste em questão. Pois o operador <code>!</code> inverte os valores do vetor lógico resultante desse teste. Com isso, se eu utilizar esse operador sobre o teste anterior, onde testamos quais valores do vetor <code>vec</code> são maiores do que 3, nós estaremos efetivamente testando a hipótese contrária, de que esses valores são menores ou iguais a 3. Vale ressaltar, que esse operador deve ser posicionado antes do objeto que você deseja inverter, ou antes do teste lógico a ser realizado.</p>
<p></p>
<div class="sourceCode" id="cb285"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[</span><span class="op">!</span><span class="va">vec</span> <span class="op">&gt;</span> <span class="fl">3</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 2.2 1.5</code></pre>
<p></p>
<p>Um uso muito comum deste operador, é em conjunto com a função <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code>. Essa função, aplica um teste lógico sobre cada valor de um vetor, testando a hipótese de que esse valor se trata de um valor não-disponível (<code>NA</code>). Por isso, caso o valor em questão, seja de fato um valor não-disponível, a função <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code> irá retornar um <code>TRUE</code> correspondente, caso contrário, a função vai lhe retornar um <code>FALSE</code>. Logo, caso eu utilize a função <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code> dentro da função <code>[</code>, estaremos selecionando todos os valores não-disponíveis de um vetor. Porém, é muito mais comum que as pessoas queiram fazer justamente o contrário, que é eliminar esses valores não-disponíveis de seus dados. Por essa razão, é muito comum que se utilize o operador <code>!</code> em conjunto com a função <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code>, pois dessa forma, estaremos selecionando justamente os valores que se encaixam na hipótese contrária a testada por <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code>.</p>
<p></p>
<div class="sourceCode" id="cb287"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.2</span>, <span class="fl">1.3</span>, <span class="cn">NA_real_</span>, <span class="cn">NA_real_</span>, <span class="fl">2.5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vec</span></span></code></pre></div>
<pre><code>## [1] 2.2 1.3  NA  NA 2.5</code></pre>
<div class="sourceCode" id="cb289"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] NA NA</code></pre>
<div class="sourceCode" id="cb291"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 2.2 1.3 2.5</code></pre>
<p></p>
<p>Vamos pensar no caso de um <code>data.frame</code>. Como definimos anteriormente, temos duas dimensões com as quais podemos trabalhar na função <code>[</code>, com este tipo de estrutura. Podemos por exemplo, utilizar o operador <code>!</code> e a função <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code> sobre a dimensão das linhas desse <code>data.frame</code>. Dessa forma, podemos eliminar todas as linhas dessa tabela, que possuam algum valor não-disponível em uma coluna. Veja o exemplo abaixo, em que uma tabela chamada <code>df</code>, contém três valores não-disponíveis na coluna <code>valor</code>.</p>
<p></p>
<div class="sourceCode" id="cb293"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  id <span class="op">=</span> <span class="va">LETTERS</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">8</span><span class="op">]</span>,</span>
<span>  valor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.2</span>, <span class="fl">2.5</span>, <span class="cn">NA_real_</span>, <span class="fl">5.5</span>, <span class="cn">NA_real_</span>, <span class="cn">NA_real_</span>, <span class="fl">3.5</span>, <span class="fl">1.3</span><span class="op">)</span>,</span>
<span>  nome <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Luiza"</span>, <span class="st">"João"</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">8</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">df</span></span></code></pre></div>
<pre><code>##     id valor  nome
## 1    a   1.2   Ana
## 2 &lt;NA&gt;   2.5   Ana
## 3 &lt;NA&gt;    NA  João
## 4 &lt;NA&gt;   5.5 Luiza
## 5 &lt;NA&gt;    NA Luiza
## 6 &lt;NA&gt;    NA   Ana
## 7 &lt;NA&gt;   3.5 Luiza
## 8 &lt;NA&gt;   1.3  João</code></pre>
<div class="sourceCode" id="cb295"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nao_e_NA</span> <span class="op">&lt;-</span> <span class="op">!</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">valor</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">df</span><span class="op">[</span><span class="va">nao_e_NA</span>, <span class="op">]</span></span></code></pre></div>
<pre><code>##     id valor  nome
## 1    a   1.2   Ana
## 2 &lt;NA&gt;   2.5   Ana
## 4 &lt;NA&gt;   5.5 Luiza
## 7 &lt;NA&gt;   3.5 Luiza
## 8 &lt;NA&gt;   1.3  João</code></pre>
<p></p>
</div>
<div id="o-operador-e-a-estrutura-do-resultado" class="section level3" number="2.9.4">
<h3>
<span class="header-section-number">2.9.4</span> O operador <code>$</code> e a estrutura do resultado<a class="anchor" aria-label="anchor" href="#o-operador-e-a-estrutura-do-resultado"><i class="fas fa-link"></i></a>
</h3>
<p>Você provavelmente se lembra do operador <code>$</code>, que se trata de um atalho à função <code>[[</code>. Porém, você talvez tenha percebido também, que utilizamos o operador <code>$</code> apenas em estruturas nomeadas. Logo, apesar de o operador <code>$</code> ser um “irmão” da função <code>[[</code>, ele não herda todas as características dessa função. Por exemplo, nós não podemos utilizar índices numéricos ou lógicos com este operador, para selecionarmos alguma parte de um objeto. Isto significa, que o operador <code>$</code> se trata de uma versão ainda mais restrita de <em>subsetting</em>, em relação à função <code>[[</code>. As únicas estruturas nomeadas com as quais este operador funciona, são listas e <code>data.frame</code>’s. Em outras palavras, mesmo que você nomeie os elementos de um vetor atômico, você não poderá utilizar o operador <code>$</code> para selecionar um desses elementos.</p>
<p></p>
<div class="sourceCode" id="cb297"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span> <span class="op">=</span> <span class="fl">2.5</span>, <span class="st">"b"</span> <span class="op">=</span> <span class="fl">4.3</span>, <span class="st">"c"</span> <span class="op">=</span> <span class="fl">1.2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vec</span><span class="op">$</span><span class="va">a</span></span></code></pre></div>
<p></p>
<p></p>
<pre class="text"><code>Error in vec$a : $ operator is invalid for atomic vectors</code></pre>
<p></p>
<p>Dentre as características da função <code>[[</code> herdadas pelo operador <code>$</code>, está o fato de que este operador pode trabalhar apenas com uma dimensão de um objeto. Em listas, podemos utilizar o operador <code>$</code> para selecionarmos algum dos elementos nomeados dessa lista. Já em <code>data.frame</code>’s, o operador <code>$</code> pode ser utilizado para selecionarmos uma das colunas desse <code>data.frame</code><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Lembre-se que no fundo, &lt;code&gt;data.frame&lt;/code&gt;’s são listas, com a propriedade de que todos os elementos dessa lista, devem possuir o mesmo número de linhas. Portanto, se cada coluna desse &lt;code&gt;data.frame&lt;/code&gt; representa um elemento da lista que forma esse &lt;code&gt;data.frame&lt;/code&gt;, ao utilizarmos o operador &lt;code&gt;$&lt;/code&gt;, também estaríamos selecionando um “elemento”, que se traduz em uma coluna do &lt;code&gt;data.frame&lt;/code&gt;.&lt;/p&gt;"><sup>28</sup></a>.</p>
<p>Um outro ponto a ser discutido, é que tanto o operador <code>$</code>, quanto a função <code>[[</code>, geram um resultado em uma estrutura diferente da estrutura do objeto original. Ou seja, quando realizamos um <em>subsetting</em> por meio desses operadores, o resultado geralmente possui uma estrutura com menos componentes do que a estrutura do objeto original, de onde estamos retirando esta parte. Dito de outra forma, se utilizarmos o operador <code>$</code>, ou a função <code>[[</code> para selecionarmos a coluna <code>valor</code> do <code>data.frame df</code> abaixo, o resultado de ambas as funções, serão um vetor atômico contendo os valores dessa coluna, e não um <code>data.frame</code> contendo apenas a coluna <code>valor</code>.</p>
<p>Logo, o uso da função <code>[[</code> (ou do operador <code>$</code>) sobre <code>data.frame</code>’s, vão lhe trazer a coluna (ou o elemento) em si do <code>data.frame</code>, e não um novo <code>data.frame</code> contendo essa coluna. Podemos confirmar isso, com o uso da função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code>, que nos traz um resumo da estrutura de um objeto. Perceba nos exemplos abaixo, que em ambos os casos, o resultado da função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> está nos dizendo que o objeto resultante do uso de <code>$</code> ou de <code>[[</code>, se trata de um vetor atômico contendo dados do tipo numérico (<code>num</code>).</p>
<p></p>
<div class="sourceCode" id="cb299"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  id <span class="op">=</span> <span class="va">LETTERS</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">]</span>,</span>
<span>  valor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>  nome <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Luiza"</span>, <span class="st">"João"</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">10</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">valor</span><span class="op">)</span></span></code></pre></div>
<pre><code>##  num [1:10] 0.92 0.398 -0.408 1.324 -0.701 ...</code></pre>
<div class="sourceCode" id="cb301"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">df</span><span class="op">[[</span><span class="st">"valor"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code>##  num [1:10] 0.92 0.398 -0.408 1.324 -0.701 ...</code></pre>
<p></p>
<p>Essa característica é definida em detalhes no capítulo 4 de <span class="citation">WICKHAM (<a href="refer%C3%AAncias.html#ref-wickham2015_advanced" role="doc-biblioref">2015a</a>)</span>. Sendo exatamente esta característica, que eu estava querendo destacar na figura 2.7, quando estávamos descrevendo as listas. Se você utilizar a função <code>[</code> para selecionar um elemento de uma lista, o resultado será uma nova lista contendo esse elemento. Mas se você utilizar a função <code>[[</code> para fazer este trabalho, o resultado será apenas o elemento em si.</p>
<p>Você pode entender essa característica como uma “simplificação do resultado”, como se as funções <code>[[</code> e <code>$</code> gerassem um resultado em uma estrutura mais simples do que a do objeto original. Porém, eu creio que essa é uma forma equivocada de se enxergar esse sistema, pois estruturas não são usualmente comparadas em níveis de complexidade, mas sim por suas propriedades e características.</p>
<p>Por isso, uma forma mais útil e fiel de se enxergar essa característica, é através da representação apresentada pela figura 2.7, onde através da função <code>[[</code>, podemos selecionar o elemento em si, e não uma nova estrutura contendo este elemento. Além disso, uma outra forma útil de enxergarmos essa característica no resultado das funções <code>[[</code> e <code>$</code>, é como uma forma de eliminarmos componentes da estrutura do objeto original. Em outras palavras, podemos enxergar o operador <code>$</code> ou a função <code>[[</code>, como uma forma de gerarmos um resultado com menos componentes do que a estrutura do objeto original.</p>
<p>Por exemplo, se temos um <code>data.frame</code> chamado <code>df</code>, onde temos duas colunas simples (que são vetores atômicos), e em seguida, adicionamos duas novas colunas, uma contendo uma lista, e outra contendo um outro <code>data.frame</code> de duas colunas (<code>y</code> e <code>z</code>), nós temos uma estrutura razoavelmente complexa. Se utilizarmos a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code>, para nos fornecer um resumo da estrutura de <code>df</code>, vemos que esse objeto tem pelo menos três componentes: 1) os vetores representados pelas colunas <code>x</code> e <code>nome</code>; 2) os cinco elementos da lista alocada na coluna <code>lista</code>; 3) e as duas colunas contidas no <code>data.frame</code> da coluna <code>outro_df</code>.</p>
<p></p>
<div class="sourceCode" id="cb303"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span>,</span>
<span>  nome <span class="op">=</span> <span class="st">"Ana"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">df</span><span class="op">$</span><span class="va">lista</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>, <span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">df</span><span class="op">$</span><span class="va">outro_df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span>, z <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">df</span><span class="op">)</span></span></code></pre></div>
<pre><code>## 'data.frame':    5 obs. of  4 variables:
##  $ x       : num  0.3906 0.3814 -0.0124 -0.1244 1.4667
##  $ nome    : chr  "Ana" "Ana" "Ana" "Ana" ...
##  $ lista   :List of 5
##   ..$ : num 1
##   ..$ : num 2
##   ..$ : num 3
##   ..$ : num 4
##   ..$ : num 5
##  $ outro_df:'data.frame':    5 obs. of  2 variables:
##   ..$ y: num  0.674 1.956 -0.269 -1.245 -0.396
##   ..$ z: num  0.0974 -0.2384 -0.4118 -1.5772 -0.7973</code></pre>
<p></p>
<p>Caso eu utilize as funções <code>[[</code> e <code>$</code> para selecionarmos alguma das colunas de <code>df</code>, podemos aplicar novamente a função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> sobre o resultado, para compreendermos sua estrutura. Veja pelo exemplo abaixo, que o resultado da função <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> nos descreve uma estrutura com menos componentes do que a estrutura original. Com isso, eu quero destacar que a estrutura desse resultado não necessariamente será menos “complexa” do que a original, mas sim que essa estrutura terá menos componentes. Portanto, pelo menos um dos componentes da estrutura original, será eliminado com o uso de <code>[[</code> ou de <code>$</code>.</p>
<p></p>
<div class="sourceCode" id="cb305"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">df</span><span class="op">[[</span><span class="st">"lista"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code>## List of 5
##  $ : num 1
##  $ : num 2
##  $ : num 3
##  $ : num 4
##  $ : num 5</code></pre>
<div class="sourceCode" id="cb307"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">df</span><span class="op">[[</span><span class="st">"outro_df"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code>## 'data.frame':    5 obs. of  2 variables:
##  $ y: num  0.674 1.956 -0.269 -1.245 -0.396
##  $ z: num  0.0974 -0.2384 -0.4118 -1.5772 -0.7973</code></pre>
<div class="sourceCode" id="cb309"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">outro_df</span><span class="op">)</span></span></code></pre></div>
<pre><code>## 'data.frame':    5 obs. of  2 variables:
##  $ y: num  0.674 1.956 -0.269 -1.245 -0.396
##  $ z: num  0.0974 -0.2384 -0.4118 -1.5772 -0.7973</code></pre>
<p></p>
</div>
</div>
<div id="valores-especiais-do-r" class="section level2" number="2.10">
<h2>
<span class="header-section-number">2.10</span> Valores especiais do R<a class="anchor" aria-label="anchor" href="#valores-especiais-do-r"><i class="fas fa-link"></i></a>
</h2>
<p>Na linguagem R, possuímos alguns valores especiais, que não apenas são tratados de maneira diferente em relação a outros valores, mas que também efetivamente alteram o comportamento de algumas operações importantes na linguagem. Por exemplo, se você tentar dividir qualquer número por zero no console, ao invés do R lhe retornar um erro, lhe indicando que essa divisão é indefinida, o console vai lhe retornar o valor <code>Inf</code>, que se refere a infinito (ou <em>infinite</em>).</p>
<p>Por outro lado, de forma ainda mais estranha, se você tentar dividir zero por ele mesmo, o console vai lhe retornar o valor <code>NaN</code>, que significa <em>“not a number”</em>, ou em outras palavras, que o valor resultante da divisão não é um número.</p>
<p>Assim como várias outras linguagens de programação, o R também possui um valor “nulo”, ou, em outras palavras, um valor que representa o “vazio” ou o “nada”. Este valor é o <code>NULL</code>. Você encontra esse valor, sempre que a função ou expressão que você executou não possui um valor de retorno definido.</p>
<p>Esses são alguns exemplos de valores especiais que você pode adquirir. Porém, o valor especial mais comum, é o valor <code>NA</code>, que significa <em>not avaliable</em>, ou “não-disponível”. Este valor geralmente é resultado de uma dessas duas situações: 1) ao importar a sua base de dados para o R, a linguagem vai preencher automaticamente todas as células em sua base que estiverem vazias, com um valor <code>NA</code>; 2) quando você executa (ou causa de maneira indireta) um processo de coerção, no qual o R não consegue realizar. Ou seja, se o R não souber como converter um valor específico, para o tipo de dado ao qual você requisitou, ele vai lhe retornar um valor <code>NA</code> correspondente àquele valor.</p>
<p>Portanto, a primeira situação ocorre durante o processo de importação de dados, em todas as ocasiões em que você possuir alguma observação vazia na base de dados que você está importando. Logo, se em uma planilha do Excel, por exemplo, você possuir alguma célula vazia em sua tabela, ao importar essa planilha para o R, essas células vazias serão preenchidas com valores <code>NA</code> no R. Lembre-se que um valor <code>NA</code> indica uma observação não-disponível, o que significa que o valor correspondente aquela observação não pôde ser observado, ou não pôde ser registrado no momento de coleta dos dados.</p>
<p>Já a segunda situação, ocorre sempre quando o R não sabe como realizar o processo de coerção, pelo qual requisitamos, de uma forma lógica. Por exemplo, isso ocorre ao tentarmos converter valores de texto para números com <code><a href="https://rdrr.io/r/base/double.html">as.double()</a></code>. Pois o R não sabe como, ou não sabe qual a maneira mais adequada de se converter esses valores em texto para números. Por isso, a linguagem vai lhe retornar como resultado, valores <code>NA</code>.</p>
<div id="sec:impactos_valores_especiais" class="section level3" number="2.10.1">
<h3>
<span class="header-section-number">2.10.1</span> Os impactos desses valores especiais<a class="anchor" aria-label="anchor" href="#sec:impactos_valores_especiais"><i class="fas fa-link"></i></a>
</h3>
<p>Por que estamos falando desses valores especiais? Porque eles alteram o comportamento de certas operações importantes do R e, com isso, podem deixar você desorientado! Por exemplo, se você tentar calcular a soma de uma coluna (de um <code>data.frame</code>) que contém um valor <code>NA</code>, o resultado dessa operação será um valor <code>NA</code>. Da mesma forma, se a coluna possuir um valor <code>NaN</code>, o resultado dessa soma será um valor <code>NaN</code>. Para que isso ocorra, o valor especial pode estar em qualquer linha que seja, basta que ele ocorra uma única vez, que a sua soma não vai funcionar.</p>
<p></p>
<div class="sourceCode" id="cb311"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="cn">NA</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<div class="sourceCode" id="cb313"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="cn">NaN</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] NaN</code></pre>
<p></p>
<p>Isso não significa que esses valores especiais serão uma dor de cabeça para você, pois cada um deles tem o seu propósito, e eles o cumprem muito bem. Mas é importante que você saiba do quão especiais eles são, e dos efeitos que eles causam em certas operações no R. Com isso, se em alguma situação uma função lhe retornar um valor <code>NA</code>, quando ela deveria lhe retornar algum valor definido, ou se essa função se comportar de maneira inesperada, você pode desconfiar que algum valor especial presente em seus dados, possa ser a fonte de sua surpresa.</p>
<p>Em geral, todas as funções que são afetadas por esses valores especiais, como as funções <code><a href="https://rdrr.io/r/base/sum.html">sum()</a></code> e <code><a href="https://rdrr.io/r/base/mean.html">mean()</a></code>, possuem um argumento <code>na.rm</code>, que define se a função deve ignorar esses valores especiais em seus cálculos. Portanto, caso uma coluna de seu <code>data.frame</code> possua esses valores especiais, e você precisa ignorá-los durante o cálculo de uma soma, lembre-se de configurar este argumento para verdadeiro (<code>TRUE</code>).</p>
<p></p>
<div class="sourceCode" id="cb315"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="cn">NA</span>, <span class="fl">4</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 10</code></pre>
<p></p>
<p>Um outro tipo de operação importante que é afetada por esses valores especiais, são os testes lógicos. Como exemplo, vamos criar um teste lógico sobre os dados apresentados pela tabela <code>compras</code>. Nós temos nessa tabela, o nome da composição química dos principais remédios que estão em falta nos estoques de três grandes hospitais. Os três remédios presentes nessa tabela, são remédios bem comuns, como o valor <code>AA</code> que se refere à composição química da Aspirina (Ácido Acetilsalicílico).</p>
<p></p>
<div class="sourceCode" id="cb317"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">compras</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/structure.html">structure</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>ano <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2019</span>, <span class="fl">2019</span>, <span class="fl">2019</span>, <span class="fl">2019</span>, <span class="fl">2019</span>, <span class="fl">2019</span>, <span class="fl">2019</span>, </span>
<span><span class="fl">2019</span>, <span class="fl">2019</span>, <span class="fl">2019</span><span class="op">)</span>, mes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2L</span>, <span class="fl">4L</span>, <span class="fl">5L</span>, <span class="fl">6L</span>, <span class="fl">8L</span>, <span class="fl">8L</span>, <span class="fl">10L</span>, <span class="fl">10L</span>, </span>
<span><span class="fl">10L</span>, <span class="fl">12L</span><span class="op">)</span>, hospital1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"AA"</span>, <span class="cn">NA</span>, <span class="st">"dexametasona"</span>, <span class="st">"AA"</span>, <span class="cn">NA</span>, </span>
<span><span class="st">"doxiciclina"</span>, <span class="cn">NA</span>, <span class="st">"AA"</span>, <span class="st">"doxiciclina"</span>, <span class="cn">NA</span><span class="op">)</span>, hospital2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"AA"</span>, </span>
<span><span class="st">"doxiciclina"</span>, <span class="st">"dexametasona"</span>, <span class="st">"dexametasona"</span>, <span class="st">"AA"</span>, <span class="cn">NA</span>, <span class="st">"dexametasona"</span>, </span>
<span><span class="st">"AA"</span>, <span class="st">"dexametasona"</span>, <span class="st">"AA"</span><span class="op">)</span>, hospital3 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"AA"</span>, <span class="st">"AA"</span>, <span class="st">"dexametasona"</span>, </span>
<span><span class="cn">NA</span>, <span class="st">"dexametasona"</span>, <span class="st">"doxiciclina"</span>, <span class="st">"dexametasona"</span>, <span class="cn">NA</span>, <span class="cn">NA</span>, <span class="st">"AA"</span></span>
<span><span class="op">)</span><span class="op">)</span>, row.names <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, class <span class="op">=</span> <span class="st">"data.frame"</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="va">compras</span></span></code></pre></div>
<pre><code>##     ano mes    hospital1    hospital2    hospital3
## 1  2019   2           AA           AA           AA
## 2  2019   4         &lt;NA&gt;  doxiciclina           AA
## 3  2019   5 dexametasona dexametasona dexametasona
## 4  2019   6           AA dexametasona         &lt;NA&gt;
## 5  2019   8         &lt;NA&gt;           AA dexametasona
## 6  2019   8  doxiciclina         &lt;NA&gt;  doxiciclina
## 7  2019  10         &lt;NA&gt; dexametasona dexametasona
## 8  2019  10           AA           AA         &lt;NA&gt;
## 9  2019  10  doxiciclina dexametasona         &lt;NA&gt;
## 10 2019  12         &lt;NA&gt;           AA           AA</code></pre>
<p></p>
<p>Por exemplo, se nós quiséssemos identificar todas as linhas na tabela <code>compras</code>, em que a composição química da Aspirina (valor <code>AA</code>) aparece em pelo menos um dos hospitais (ou dito de outra forma, em pelo menos uma das colunas), poderíamos aplicar um teste lógico sobre a tabela <code>compras</code>. O teste lógico abaixo, serve para esse propósito, mas se olharmos para o resultado desse teste, podemos identificar que algo está errado.</p>
<p></p>
<div class="sourceCode" id="cb319"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">teste</span> <span class="op">&lt;-</span> <span class="va">compras</span><span class="op">$</span><span class="va">hospital1</span> <span class="op">==</span> <span class="st">"AA"</span> <span class="op">|</span></span>
<span>  <span class="va">compras</span><span class="op">$</span><span class="va">hospital2</span> <span class="op">==</span> <span class="st">"AA"</span> <span class="op">|</span></span>
<span>  <span class="va">compras</span><span class="op">$</span><span class="va">hospital3</span> <span class="op">==</span> <span class="st">"AA"</span> </span>
<span></span>
<span><span class="va">teste</span></span></code></pre></div>
<pre><code>##  [1]  TRUE  TRUE FALSE  TRUE  TRUE    NA    NA  TRUE    NA  TRUE</code></pre>
<p></p>
<p>Perceba acima, que o teste lógico detectou com sucesso todas as linhas da tabela <code>compras</code>, que possuem um valor <code>AA</code> em pelo menos uma de suas colunas. Mais especificamente, as linhas de posição 1°, 2°, 4°, 5°, 8° e 10°. Porém, podemos também identificar, que para as linhas de posição 6°, 7° e 9° na tabela, o teste lógico <code>teste</code> nos retornou valores <code>NA</code>. Ou seja, ao invés do teste lógico nos retornar um valor <code>FALSE</code>, para as linhas que não possuem um valor <code>AA</code> ao longo de suas colunas, ele acaba nos retornando um valor <code>NA</code>, pelo simples fato de que temos um valor <code>NA</code> em pelo menos uma das colunas. Isso se torna um grande problema, a partir do momento em que desejamos filtrar a nossa tabela <code>compras</code>, ao fornecer o nosso vetor <code>teste</code>, à função de <em>subsetting</em>.</p>
<p></p>
<div class="sourceCode" id="cb321"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">compras</span><span class="op">[</span><span class="va">teste</span>, <span class="op">]</span></span></code></pre></div>
<pre><code>##       ano mes hospital1    hospital2    hospital3
## 1    2019   2        AA           AA           AA
## 2    2019   4      &lt;NA&gt;  doxiciclina           AA
## 4    2019   6        AA dexametasona         &lt;NA&gt;
## 5    2019   8      &lt;NA&gt;           AA dexametasona
## NA     NA  NA      &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;
## NA.1   NA  NA      &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;
## 8    2019  10        AA           AA         &lt;NA&gt;
## NA.2   NA  NA      &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;
## 10   2019  12      &lt;NA&gt;           AA           AA</code></pre>
<p></p>
<p>Portanto, o problema gerado pelos valores <code>NA</code> presentes no resultado do teste lógico, é que eles geram indiretamente um novo problema a ser resolvido. O objetivo principal está em identificar as linhas da tabela <code>compras</code>, que possuem um valor <code>AA</code>, em pelo menos uma de suas colunas, e filtrá-las da tabela. Porém, ao fornecermos esse vetor <code>teste</code> à função de <em>subsetting</em>, a função <code>[</code> acaba adicionando uma nova linha ao resultado, para cada valor <code>NA</code> presente no vetor <code>teste</code>. Logo, o resultado que era para ter 6 linhas, acaba tendo 9. Com isso, teríamos um novo trabalho de eliminar essas novas linhas de <code>NA</code>’s, para chegarmos às linhas que queremos filtrar da nossa tabela <code>compras</code>.</p>
</div>
<div id="valores-especiais-também-estão-associados-a-algum-tipo-de-dado" class="section level3" number="2.10.2">
<h3>
<span class="header-section-number">2.10.2</span> Valores especiais também estão associados a algum tipo de dado<a class="anchor" aria-label="anchor" href="#valores-especiais-tamb%C3%A9m-est%C3%A3o-associados-a-algum-tipo-de-dado"><i class="fas fa-link"></i></a>
</h3>
<p>Vale destacar que, assim como qualquer outro valor no R, os valores especiais do R também estão associados a algum dos 5 tipos básicos de dados apresentados na seção <a href="fundamentos-da-linguagem-r.html#sec:fundamentos_tipos_dados">Tipos de dados</a>. Como exemplo, os valores <code>Inf</code>, <code>-Inf</code> e <code>NaN</code> são valores associados ao tipo <code>double</code>.</p>
<p></p>
<div class="sourceCode" id="cb323"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="cn">Inf</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "double"</code></pre>
<div class="sourceCode" id="cb325"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="op">-</span><span class="cn">Inf</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "double"</code></pre>
<div class="sourceCode" id="cb327"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="cn">NaN</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "double"</code></pre>
<p></p>
<p>Por outro lado, o valor <code>NA</code> é por padrão, um valor do tipo <code>logical</code>. Porém, diferentemente de <code>Inf</code>, <code>-Inf</code> e <code>NaN</code>, o valor <code>NA</code> possui diferentes “versões” para cada um dos 5 tipos de dados. Essas versões são <code>NA_character_</code>, <code>NA_real_</code>, <code>NA_complex_</code> e <code>NA_integer_</code>. Temos também outras “versões” referentes a tipos de dados mais complexos, como <code>NA_POSIXct_</code> e <code>NA_Date_</code> que se referem aos tipos <code>POSIXct</code> e <code>Date</code>, os quais vamos descrever no capítulo <a href="introdu%C3%A7%C3%A3o-%C3%A0-vari%C3%A1veis-de-tempo-com-lubridate.html#sec:lubridate_var_tempo">Introdução à variáveis de tempo com <code>lubridate</code></a>.</p>
<p></p>
<div class="sourceCode" id="cb329"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="cn">NA</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "logical"</code></pre>
<div class="sourceCode" id="cb331"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="cn">NA_character_</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "character"</code></pre>
<div class="sourceCode" id="cb333"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/typeof.html">typeof</a></span><span class="op">(</span><span class="cn">NA_real_</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "double"</code></pre>
<p></p>
<p>Portanto, valores como <code>Inf</code>, <code>-Inf</code> e <code>NaN</code> estão presentes apenas no tipo <code>double</code>, enquanto o valor <code>NA</code> possui uma “versão” para cada tipo de dado no R. Tanto que, se tentarmos converter um valor como <code>NaN</code> para algum outro tipo, como o tipo <code>logical</code>, ele será automaticamente convertido para um valor <code>NA</code> do tipo <code>logical</code>, como demonstrado abaixo.</p>
<p></p>
<div class="sourceCode" id="cb335"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/logical.html">as.logical</a></span><span class="op">(</span><span class="cn">NaN</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<p></p>
</div>
<div id="como-identificar-valores-especiais" class="section level3" number="2.10.3">
<h3>
<span class="header-section-number">2.10.3</span> Como identificar valores especiais<a class="anchor" aria-label="anchor" href="#como-identificar-valores-especiais"><i class="fas fa-link"></i></a>
</h3>
<p>Por serem valores especiais, o R nos oferece um conjunto de funções para cada um desses valores especiais, as quais estão listadas abaixo:</p>
<ul>
<li>
<code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/is.finite.html">is.finite()</a></code>.</li>
<li>
<code><a href="https://rdrr.io/r/base/is.finite.html">is.infinite()</a></code>.</li>
<li><code><a href="https://rdrr.io/r/base/is.finite.html">is.nan()</a></code></li>
</ul>
<p>A função <code><a href="https://rdrr.io/r/base/is.finite.html">is.finite()</a></code> busca identificar se um valor numérico é finito, o que significa basicamente, um valor do tipo <code>numeric</code> diferente de <code>Inf</code>, <code>-Inf</code>, <code>NaN</code> e de <code>NA</code>. Perceba abaixo que, quando digo que a função <code><a href="https://rdrr.io/r/base/is.finite.html">is.finite()</a></code> busca testar valores numéricos, estou querendo dizer que essa função é irrelevante para testar valores do tipo <code>character</code>, dado que ela nos retorna <code>FALSE</code> para qualquer valor textual. Repare também que essa função nos retorna <code>TRUE</code> para dados do tipo <code>logical</code>, dado que, no fundo, valores do tipo <code>logical</code> são armazenados através de 1’s e 0’s do tipo <code>integer</code>.</p>
<p></p>
<div class="sourceCode" id="cb337"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://purrr.tidyverse.org/">purrr</a></span><span class="op">)</span></span>
<span><span class="va">objs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="cn">Inf</span>, <span class="cn">NaN</span>, <span class="cn">NA</span>, <span class="st">"texto"</span>, <span class="fl">1.25</span>, <span class="fl">1L</span>, <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_lgl</a></span><span class="op">(</span><span class="va">objs</span>, <span class="va">is.finite</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span></span>
<span>  <span class="st">"Inf"</span>, <span class="st">"NaN"</span>, <span class="st">"NA"</span>,</span>
<span>  <span class="st">"character"</span>, <span class="st">"double"</span>,</span>
<span>  <span class="st">"integer"</span>, <span class="st">"logical"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span></code></pre></div>
<pre><code>##       Inf       NaN        NA character    double   integer   logical 
##     FALSE     FALSE     FALSE     FALSE      TRUE      TRUE      TRUE</code></pre>
<p></p>
<p>Ao descobrir o valor <code>NA</code>, você talvez tenha pensado que você seria capaz de identificar esse valor especial por um simples teste de igualdade. Entretanto, como descrevemos na seção <a href="fundamentos-da-linguagem-r.html#sec:impactos_valores_especiais">Os impactos desses valores especiais</a>, valores especiais alteram o comportamento de testes lógicos tradicionais, de modo que, um teste de igualdade como <code>x == NA</code> vai sempre resultar em um novo valor <code>NA</code>.</p>
<p></p>
<div class="sourceCode" id="cb339"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="cn">NA</span></span>
<span><span class="va">x</span> <span class="op">==</span> <span class="cn">NA</span></span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<p>
Portanto, a forma adequada de se testar se um determinado objeto no R contém um valor <code>NA</code>, é aplicar a função <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code> sobre o objeto em questão. Caso o seu objetivo seja justamente o contrário (isto é, testar se o objeto não contém um valor <code>NA</code>), você precisa apenas inverter o teste lógico ao adicionar o operador <code>!</code> sobre a função.</p>
<p></p>
<div class="sourceCode" id="cb341"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb343"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Fazendo o teste inverso:</span></span>
<span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p></p>
<p>Já as funções <code><a href="https://rdrr.io/r/base/is.finite.html">is.infinite()</a></code> e <code><a href="https://rdrr.io/r/base/is.finite.html">is.nan()</a></code> funcionam exatamente da mesma forma, com a diferença que, essas funções testam se o objeto contém valores infinitos (<code>Inf</code> e <code>-Inf</code>) e valores <code>NaN</code>, respectivamente.</p>
<p></p>
<div class="sourceCode" id="cb345"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/is.finite.html">is.infinite</a></span><span class="op">(</span><span class="cn">Inf</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb347"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/is.finite.html">is.nan</a></span><span class="op">(</span><span class="cn">NaN</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p></p>
</div>
</div>
<div id="exercícios-1" class="section level2 unnumbered">
<h2>Exercícios<a class="anchor" aria-label="anchor" href="#exerc%C3%ADcios-1"><i class="fas fa-link"></i></a>
</h2>
<p><strong>Questão 2.1.</strong> Em cada item desta questão, temos um simples <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> de um objeto qualquer. Com base apenas nessa primeira imagem do objeto, tente identificar a estrutura (vetor, matriz, lista, <code>data.frame</code>) na qual esse objeto se encontra:</p>
<p>2.1.A) Objeto 1:</p>
<p></p>
<pre><code>## [[1]]
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</code></pre>
<p></p>
<p>2.1.B) Objeto 2:</p>
<p></p>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<p></p>
<p>2.1.C) Objeto 3:</p>
<p></p>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,] "MG" "MG" "DF" "SP" "MG"
## [2,] "MS" "DF" "DF" "SP" "DF"
## [3,] "DF" "DF" "MG" "SP" "MG"
## [4,] "MG" "SP" "MG" "SP" "MG"
## [5,] "SP" "SP" "MG" "DF" "MG"</code></pre>
<p></p>
<p>2.1.D) Objeto 4:</p>
<p></p>
<pre><code>##    id valor
## 1   1 -0.29
## 2   2 -0.30
## 3   3 -0.41
## 4   4  0.25
## 5   5 -0.89
## 6   6  0.44
## 7   7 -1.24
## 8   8 -0.22
## 9   9  0.38
## 10 10  0.13</code></pre>
<p></p>
<p>2.1.E) Objeto 5:</p>
<p></p>
<pre><code>## $estado
## [1] "MG"
## 
## $cidade
## [1] "Belo Horizonte"
## 
## $n_municipios
## [1] 853
## 
## $regiao
## [1] "Sudeste"</code></pre>
<p></p>
<p>2.1.F) Objeto 6:</p>
<p></p>
<pre><code>##  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA</code></pre>
<p></p>
<p><strong>Questão 2.2.</strong> Em cada item abaixo, você deve criar um teste lógico que seja capaz de testar as condições postas no enunciado. Em alguns itens, será fornecido o código necessário para que você crie certos objetos (como <code>v_seq</code>, <code>v_rep</code>, <code>lst</code>, etc.), pois os testes lógicos se baseiam nesses objetos, ou devem ser aplicados diretamente sobre esses objetos. Portanto, lembre-se de copiar o código fornecido pela questão, colar em seu console, e apertar <code>Enter</code> para recriar esses objetos em sua sessão do R.</p>
<p>2.2.A) Crie um teste lógico que seja capaz de identificar quais dos cinco objetos abaixo, são um vetor atômico.</p>
<p></p>
<div class="sourceCode" id="cb355"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="va">v_seq</span> <span class="op">&lt;-</span> <span class="fl">10</span><span class="op">:</span><span class="fl">25</span></span>
<span>      <span class="va">v_rep</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="st">"abc"</span>, times <span class="op">=</span> <span class="fl">30</span><span class="op">)</span></span>
<span>      <span class="va">lst</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">)</span></span>
<span>      <span class="va">mt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>, nrow <span class="op">=</span> <span class="fl">4</span>, ncol <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span>      <span class="va">dt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span><span class="fl">15</span>, <span class="st">"A"</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.2.B) Imagine que você receba em sua sessão do R, o objeto <code>lst</code> abaixo. Tente criar um teste lógico que possa confirmar se esse objeto é uma lista. Pelo código abaixo, você já sabe que este objeto é sim uma lista. Entretanto, nem sempre você terá acesso fácil ao código que criou certo objeto, ou, nem sempre você consegue prever que tipos de objetos serão criados a partir dos comandos escritos por outras pessoas. Por isso, quando você não conhece o <em>input</em> que você vai receber, é sempre importante se basear em teste lógicos que possam lhe assegurar que os seus objetos estão na estrutura desejada.</p>
<p></p>
<div class="sourceCode" id="cb356"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="va">lst</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>        estado <span class="op">=</span> <span class="st">"MG"</span>,</span>
<span>        cidade <span class="op">=</span> <span class="st">"Belo Horizonte"</span>,</span>
<span>        n_municipios <span class="op">=</span> <span class="fl">853</span>,</span>
<span>        regiao <span class="op">=</span> <span class="st">"Sudeste"</span></span>
<span>      <span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.2.C) Utilizando a mesma lista <code>lst</code> do exercício acima, crie um teste lógico capaz de identificar se essa lista possui um item chamado “estado”. Primeiro, aplique o seu teste lógico sobre <code>lst</code>, e confira se o resultado do teste é <code>TRUE</code>. Em seguida, aplique esse mesmo teste lógico sobre a lista <code>lst_sem_estado</code> abaixo, e veja se o resultado do teste é de fato <code>FALSE</code>.</p>
<p></p>
<div class="sourceCode" id="cb357"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="va">lst_sem_estado</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>        regiao <span class="op">=</span> <span class="st">"Sudeste"</span>,</span>
<span>        n_municipios <span class="op">=</span> <span class="fl">853</span></span>
<span>      <span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.2.D) Suponha que você possua a tabela <code>tab</code> abaixo. Crie um teste lógico que possa identificar se a coluna <code>total</code> é do tipo <code>double</code>.</p>
<p></p>
<div class="sourceCode" id="cb358"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="va">tab</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>        unidade <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Centro"</span>, <span class="st">"Gameleira"</span>, <span class="st">"Santa Efigênia"</span>, <span class="st">"Centro"</span>,</span>
<span>                    <span class="st">"Barro Preto"</span>, <span class="st">"Centro"</span>, <span class="st">"Gameleira"</span>, <span class="st">"Centro"</span>,</span>
<span>                    <span class="st">"Barro Preto"</span>, <span class="st">"Santa Efigênia"</span><span class="op">)</span>,</span>
<span>        mes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>,</span>
<span>        vendas <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1502</span>, <span class="fl">1430</span>, <span class="fl">1100</span>, <span class="fl">1200</span>, <span class="fl">1443</span>, <span class="fl">1621</span>, <span class="fl">1854</span>, <span class="fl">2200</span>,</span>
<span>                  <span class="fl">1129</span>, <span class="fl">1872</span><span class="op">)</span>,</span>
<span>        total <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5362.14</span>, <span class="fl">5105.1</span>, <span class="fl">3927</span>, <span class="fl">4284</span>, <span class="fl">5151.51</span>, <span class="fl">5786.97</span>, </span>
<span>                  <span class="fl">6618.78</span>, <span class="fl">7854</span>, <span class="fl">4030.53</span>, <span class="fl">6683.04</span><span class="op">)</span></span>
<span>      <span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.2.E) Utilizando a mesma tabela <code>tab</code> acima, crie um teste lógico que possa identificar se a tabela possui exatamente 10 linhas, <strong>E</strong>, se essa tabela possui uma coluna chamada “vendas”, <strong>E</strong>, se a 3° coluna da tabela é do tipo <code>character</code>. Perceba no enunciado desta questão, os E’s separando cada condição a ser testada. Esses E’s estão indicando que essas condições são dependentes, ou, em outras palavras, elas precisam ser satisfeitas ao mesmo tempo.</p>
<p>2.2.F) Se eu te der um número qualquer, referente a um ano específico (por exemplo, 2005 ou 1997), crie um teste lógico capaz de atestar se esse ano fornecido é um ano bissexto. Um ano bissexto é definido pelas seguintes condições: 1) a cada 4 anos, temos um ano bissexto; 2) a cada 100 anos, nós não devemos ter um ano bissexto; 3) a cada 400 anos temos um ano bissexto. Um detalhe: as últimas regras são mais importantes do que as primeiras, ou seja, a regra 3 prevalece sobre as regras 1 e 2, da mesma forma que a regra 2, prevalece sobre a regra 1. Caso essas definições não estejam muito claras, elas basicamente significam o seguinte: 1) o ano deve ser múltiplo de 4; 2) o ano não deve ser múltiplo de 100 a não ser que ele seja múltiplo de 400; 3) se o ano é múltiplo de 400, ele é obrigatoriamente um ano bissexto.</p>
<p><strong>Questão 2.3.</strong> Em cada item abaixo, fornecemos um vetor formado pela função <code><a href="https://rdrr.io/r/base/c.html">c()</a></code>. Perceba que em cada um desses vetores, valores de diferentes tipos são misturados. Como definimos na seção <a href="fundamentos-da-linguagem-r.html#sec:coercion_R_fundamentos">Coerção no R</a>, quando dados de diferentes tipos são colocados dentro de um vetor atômico, o R automaticamente realiza um processo de coerção, ao converter todos esses dados para um único tipo. O seu objetivo nessa questão é simplesmente adivinhar o tipo (<code>double</code>, <code>integer</code>, <code>logical</code>, ou <code>character</code>) de dado, para o qual esses dados serão convertidos. Caso esteja na dúvida, basta copiar e colar o código em seu console que você terá uma visão do resultado.</p>
<p>2.3.A)</p>
<p></p>
<div class="sourceCode" id="cb359"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.2</span>, <span class="fl">2.4</span>, <span class="st">"3.1"</span>, <span class="fl">1.9</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.3.B)</p>
<p></p>
<div class="sourceCode" id="cb360"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="va">integers</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span></span>
<span>      <span class="va">doubles</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.23</span>, <span class="fl">9.87</span>, <span class="fl">3.2</span><span class="op">)</span></span>
<span>      </span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">integers</span>, <span class="va">doubles</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.3.C)</p>
<p></p>
<div class="sourceCode" id="cb361"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.56</span>, <span class="fl">3L</span>, <span class="fl">1L</span>, <span class="fl">5L</span>,  <span class="fl">2.32</span>, <span class="fl">9.87</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.3.D)</p>
<p></p>
<div class="sourceCode" id="cb362"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fl">1.5</span>, <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>2.3.E)</p>
<p></p>
<div class="sourceCode" id="cb363"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"p"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="cn">TRUE</span>, <span class="fl">2L</span>, <span class="fl">4.318</span><span class="op">)</span></span></code></pre></div>
<p></p>
<p><strong>Questão 2.4.</strong> Os próximos exercícios serão voltados para <em>subsetting</em>. Ao longo desses exercícios, estaremos utilizando o <code>data.frame</code> <code>flights</code>, que provêm do pacote <code>nycflights13</code>. Por isso, lembre-se que para ter acesso a essa tabela, é necessário que você chame por esse pacote em sua sessão, com o comando <code><a href="https://rdrr.io/r/base/library.html">library()</a></code>. Caso você não tenha o pacote instalado em sua máquina, execute o comando <code><a href="https://rdrr.io/r/utils/install.packages.html">install.packages()</a></code> mostrado abaixo.</p>
<p></p>
<div class="sourceCode" id="cb364"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>      <span class="co">### Caso você não possua o pacote nycflights13</span></span>
<span>      <span class="co">### instalado, execute o comando:</span></span>
<span></span>
<span>      <span class="co">### install.packages("nycflights13")</span></span>
<span></span>
<span>      <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/hadley/nycflights13">nycflights13</a></span><span class="op">)</span></span>
<span></span>
<span>      <span class="co">### Após o comando library() você</span></span>
<span>      <span class="co">### terá acesso à tabela flights</span></span>
<span>      <span class="va">flights</span></span></code></pre></div>
<p></p>
<p>2.4.A) Encontre todas as linhas da tabela <code>flights</code> em que <code>carrier</code> seja igual a <code>"B6"</code>, e que <code>month</code> seja igual a 5.</p>
<p>2.4.B) Todos os voos descritos na tabela <code>flights</code>, correspondem a voos que ocorreram no aeroporto de Nova York, ao longo do ano de 2013. A coluna <code>dep_delay</code> apresenta o tempo de atraso (em minutos) no momento de partida do aeroporto, e a coluna <code>arr_delay</code> apresenta o tempo de atraso (em minutos) no momento de chegada ao aeroporto. Tendo isso em mente, no ano de 2013, quantos voos obtiveram um tempo de atraso total acima do tempo médio de atraso?</p>
<p>2.4.C) Selecione as linhas da tabela <code>flights</code> que se encaixam em pelo menos uma dessas duas condições: 1) possuem um <code>arr_delay</code> abaixo de 2 minutos, e que o aeroporto de destino (<code>dest</code>) seja <code>"BOS"</code>; 2) cujo horário de partida programado (<code>sched_dep_time</code>) seja de 6:00 (ou <code>600</code>), e que o mês de ocorrência do voô seja igual a 1.</p>

</div>
</div>




  <div class="chapter-nav">
<div class="prev"><a href="no%C3%A7%C3%B5es-b%C3%A1sicas-do-r.html"><span class="header-section-number">1</span> Noções Básicas do R</a></div>
<div class="next"><a href="introduzindo-o-universo-do-tidyverse.html"><span class="header-section-number">3</span> Introduzindo o universo do tidyverse</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#fundamentos-da-linguagem-r"><span class="header-section-number">2</span> Fundamentos da Linguagem R</a></li>
<li><a class="nav-link" href="#sec:fundamentos_R"><span class="header-section-number">2.1</span> Introdução</a></li>
<li><a class="nav-link" href="#mais-detalhes-sobre-objetos"><span class="header-section-number">2.2</span> Mais detalhes sobre objetos</a></li>
<li><a class="nav-link" href="#como-o-r-organiza-e-interpreta-os-seus-dados"><span class="header-section-number">2.3</span> Como o R organiza e interpreta os seus dados</a></li>
<li>
<a class="nav-link" href="#sec:estruturas_dados"><span class="header-section-number">2.4</span> Estruturas de dados</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#sec:vetores_estrutura"><span class="header-section-number">2.4.1</span> Vetores</a></li>
<li><a class="nav-link" href="#matrizes"><span class="header-section-number">2.4.2</span> Matrizes</a></li>
<li><a class="nav-link" href="#sec:estrutura_listas"><span class="header-section-number">2.4.3</span> Listas</a></li>
<li><a class="nav-link" href="#sec:estrutura_data_frames"><span class="header-section-number">2.4.4</span> Tabelas no R: data.frame</a></li>
<li><a class="nav-link" href="#sec:fundamentos_tibble"><span class="header-section-number">2.4.5</span> tibble’s como uma alternativa moderna aos data.frame’s</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#sec:fundamentos_tipos_dados"><span class="header-section-number">2.5</span> Tipos de dados</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#textos-e-caracteres-character"><span class="header-section-number">2.5.1</span> Textos e caracteres (character)</a></li>
<li><a class="nav-link" href="#n%C3%BAmeros-reais-double"><span class="header-section-number">2.5.2</span> Números reais (double)</a></li>
<li><a class="nav-link" href="#n%C3%BAmeros-inteiros-integer"><span class="header-section-number">2.5.3</span> Números inteiros (integer)</a></li>
<li><a class="nav-link" href="#o-tipo-num%C3%A9rico-numeric"><span class="header-section-number">2.5.4</span> O tipo numérico (numeric)</a></li>
<li><a class="nav-link" href="#valores-l%C3%B3gicos-logical"><span class="header-section-number">2.5.5</span> Valores lógicos (logical)</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#sec:funcoes_str_is"><span class="header-section-number">2.6</span> Identificando tipos e estruturas com a função str() e as funções is.*()</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#tome-muito-cuidado-com-is.vector-e-is.numeric"><span class="header-section-number">2.6.1</span> Tome muito cuidado com is.vector() e is.numeric()</a></li></ul>
</li>
<li>
<a class="nav-link" href="#sec:coercion_R_fundamentos"><span class="header-section-number">2.7</span> Coerção no R</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#a-%C3%A1rvore-de-coer%C3%A7%C3%A3o"><span class="header-section-number">2.7.1</span> A árvore de coerção</a></li>
<li><a class="nav-link" href="#coer%C3%A7%C3%B5es-expl%C3%ADcitas-com-as-fun%C3%A7%C3%B5es-as."><span class="header-section-number">2.7.2</span> Coerções explícitas com as funções as.*()</a></li>
<li><a class="nav-link" href="#tamb%C3%A9m-podemos-converter-estruturas-de-dados-com-as-fun%C3%A7%C3%B5es-as."><span class="header-section-number">2.7.3</span> Também podemos converter estruturas de dados com as funções as.*()</a></li>
</ul>
</li>
<li><a class="nav-link" href="#um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r"><span class="header-section-number">2.8</span> Um estudo de caso: importando os dados da PINTEC-IBGE para o R</a></li>
<li>
<a class="nav-link" href="#subsetting"><span class="header-section-number">2.9</span> Subsetting</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#principais-diferen%C3%A7as-entre-as-fun%C3%A7%C3%B5es-e"><span class="header-section-number">2.9.1</span> Principais diferenças entre as funções [ e [[:</a></li>
<li><a class="nav-link" href="#dimens%C3%B5es-dispon%C3%ADveis-em-subsetting"><span class="header-section-number">2.9.2</span> Dimensões disponíveis em subsetting</a></li>
<li><a class="nav-link" href="#tipos-de-%C3%ADndices"><span class="header-section-number">2.9.3</span> Tipos de índices</a></li>
<li><a class="nav-link" href="#o-operador-e-a-estrutura-do-resultado"><span class="header-section-number">2.9.4</span> O operador $ e a estrutura do resultado</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#valores-especiais-do-r"><span class="header-section-number">2.10</span> Valores especiais do R</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#sec:impactos_valores_especiais"><span class="header-section-number">2.10.1</span> Os impactos desses valores especiais</a></li>
<li><a class="nav-link" href="#valores-especiais-tamb%C3%A9m-est%C3%A3o-associados-a-algum-tipo-de-dado"><span class="header-section-number">2.10.2</span> Valores especiais também estão associados a algum tipo de dado</a></li>
<li><a class="nav-link" href="#como-identificar-valores-especiais"><span class="header-section-number">2.10.3</span> Como identificar valores especiais</a></li>
</ul>
</li>
<li><a class="nav-link" href="#exerc%C3%ADcios-1">Exercícios</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/pedropark99/Introducao_R//blob/main/02-fundamentos.Rmd">View source <i class="fas fa-book-open"></i></a></li>
          <li><a id="book-edit" href="https://github.com/pedropark99/Introducao_R//edit/main/02-fundamentos.Rmd">Edit this page <i class="fas fa-book-open"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Introdução à Linguagem R: seus fundamentos e sua prática</strong>" was written by Pedro Faria. It was last built on 2023-07-17.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
